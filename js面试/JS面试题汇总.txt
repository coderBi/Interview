1，函数的调用方式
答案：有四种，分别是函数式、方法式、构造器式调用和上下文调用模式
1）函数式：func()
2）方法式：o.method()
3）构造器式调用(即new 构造函数)：
构造函数中不需要return，因为会默认返回this。如果手动的return了void或者基本数据类型或者null或者undefined，那么这个return无效，还是会返回this。如果是返回一个对象，那么这个对象就替换掉了this，this被丢弃。
4)上下文调用：
func.apply(对象,参数列表构成的数组或者伪数组) 
func.call(对象，参数列表)
---由于apply是将参数列表放到一个数组或者伪数组中进行传递的，一般比call更实用。
---note: 如果没有传入对象或者传入null或者undefined，那么函数里面的this指代的是window。如果传入的是基本数据类型，那么会被转换为对应的包装类型。
----扩展：由于apply的参数列表可以接受伪数组，常常用这个特性进行一些特殊的数组操作，例子如下
	var a = {};  //这是一个对象，不是数组，构成伪数组
	a[0] = 'a'; a[1] = 'b';
	a.length = 2;
	var arr = [];  //一个空数组
	arr = arr.concat(a); //concat连接两个数组,这里的伪数组不能得到正确结果，因为实际上它将a这个对象作为一个整体追加到了arr里面。但是使用下面的apply可以解决这个问题.
	arr = Array.prototype.concat.apply(arr,a); //使用apply第二个参数接受伪数组并进行伪数组展开的特性可以得到正确的结果。

2，setTimeout与setInterval的最小执行间隔
答案：
编码的时候，可以将参数设置为0，但是实际执行的效果不会马上执行。理论上在苹果操作系统上，可以认为是10s，在windows操作系统上可认为是15s。在html中定义的最小时间间隔是4s，而Firefox中给出的最小时间间隔的定义是10s。如果要设置最小时间间隔执行，一般可设置setTimeout(function,1,参数1，参数2，...)
--note:测试的时候，指的注意的是，如果打开firebug，由于console.log有自己的最小时间，所以，如果设置的时间间隔很小，将会看到，执行的明显减低了，关闭firebug可以看到真实的执行效率。


3，下面的代码的执行结果是什么
	var tt = 'aa';
	function test(){
		alert(tt);
		var tt = 'dd';
		alert(tt);
	}
	test();
答案：
输出undefined和dd，原因是js中一开始就判断函数内部对全局的变量tt进行了屏蔽，所以在函数执行的过程中不会考虑全局的tt，又由于第一个alert的时候局部的tt还没有定义，所以会出现一个undefined。
---note: 同样的打印如果出现在C/C++中，会打印aadd，原因是在第一个打印的语句的时候判断在函数的内部还没有对全局的tt进行屏蔽，所以会打印出aa。值得注意的是在php和js中没有复合语句的单独作用域，只会区分函数内还是函数外，这点与c和c++不同。


4,下面的代码输出什么
	var a;
	alert(typeof a === undefined);
	alert(typeof a == undefined);
答案：
typeof a输出的结果是字符串类型，a由于只有申明没有定义，所以这里的值是undefined的，类型是"undefined"。所以typeof a 得到的是 "undefined"的这个字符串。这个字符串内容不为0 0.0或者空，所以a != undefined，当然更不可能 ===,因为二者的类型都不同，undefined的类型是一个独立的类型.


5，typeof null返回的是什么
答案：
返回的是"object"，以后的ES可能会返回"null"

6，js中的数据类型
答案：
1）bool类型  
2）数值类型(没有单独的float int double，他们都是同一个数值类型 typeof得到的结果是"number")
3）string类型
4）null类型  但是比较特殊的是这种类型的typeof返回的是"object"
5）undefined类型，表示没有定义只有申明的值，typeof undefined = "undefined"
6）数组类型 typeof结果为object
7）对象类型(function)
8）regex类型 typeof得到的也是object


7，什么是ECMAScript
答案：
ECMA是欧洲计算机制造商协会，ECMAScript就是遵循这个协会定义得标准的Script。目标对ECMA标准的实现主要有火狐的JavaScript和微软的JScript，但是市面上很多时候并没有区分这两种script。JavaScript本身是一种脚本语言，与BOM和DOM构成了用户进行浏览器端交互开发的技术手段。

8,$符号在JavaScript中有什么作用
答案；
并没有什么作用，js中规定变量的命名规则可以是用数组下划线字母和$符号，但是数字不能写在开头，一般来说$命令的函数和变量建议只出现在中间生成代码中。目前$更多的用在一些第三方JS库中，用作选择器函数，例如jquery.

9，下面的表达式的结果是多少
	false ? 1 : 2 ? 3 : 4 ? 5 : 6
答案与分析：
和C++一样js中对于这两的连续的三目运算存在短路现象，第一个三目运算计算的结果是2，然后2作为判断条件计算 (2 ? 3 : 4 ? 5 : 6)，2判断为真然后短路直接返回3，不会进行后续的计算。（note：php中也是从左往右进行扫描，但是没有短路效果）


10，js中的switch与php中的switch有何异同
答案：
js和php中的switch都可以对各种数据类型进行判断，这一点和C++ java等强类型的语言不同。但是php中的case中的匹配是进行弱类型的匹配，也就是使用的是==，而js中switch里面的case条件的匹配是严格匹配的，会考虑传入的数据类型，也就是使用的是===。例如下面的代码在php中匹配到了""而在js中使用严格匹配匹配到了后面的0:
		switch(0){
		case '':
			break;
		case 0: 
			break;
		}

11，非严格比较中，那些值是假值（注意区分概念，假值并不是与false相比，false也是个假值）
答案：
0 0.0 "" false null undefined NaN
以下是实测结果与代码：
	/*
		1）0.0 和 0没有任何区别
		2）虽然"0" == 0但是“0” 和 “0.0”不是假值，如果放到括号中判断，结果是真(值)。
		3）假值与false不是完全一回事，false也是个假值。false!=undefined undefined!=0 但是他们都是假值
		4）是否值真值与是否==false并不完全一致，例如undefined的是假值，但是undefined != false，类似的还有null,NaN。相应的,==false的并不一定可以用作假值，例如"0","0.0"（尽管他们与0相等）。所以if(a)是用来判断a是否是假值的，而if(a == false)是用来判断a是否==false(其实false也是0，所以会与0,0.0,'','0','0.0'都相等，但是不与null undefined NaN相等)的
	*/
	function equals2false(compare){
		//判断是是否与false ==
		if(false != compare){
			console.log(".. " + compare + " not equals to false");
		}else{
			console.log(".. " + compare + " equals to false");
		}
		//判断是假值还是真值，这里与false == 的结果并不完全相同，应该规避这个误区
		if(compare){
			console.log("-- " + compare + " works as true value");
		}else{
			console.log("-- " + compare + " works as fasle value");
		}
	}
	equals2false(undefined); //undefined是假值，但是!=false
	equals2false(0); //0是假值，也==fasle
	equals2false(0.0); //0.0与0是一个东西，是假值与false==
	equals2false(""); //是假值，==false
	//字符串类型中只有空串为假值，下面的"0" "0.0"都不是false
	equals2false("0"); //是真值，但是==false
	equals2false("0.0"); //是真值，但是==false
	equals2false(null); //是假值，但!=false
	equals2false(NaN); //是假值，但!=false

12，js中如果函数没有返回值，默认返回的是什么
答案：
在js中如果一个函数的参数没有传入，这个参数的默认值是undefined，如果一个函数的返回值没有指定那么默认值是undefined。可以通过将传入的参数的$a === undefined判断参数是否进行了传入，也可以通过typeof a === "undefined"判断是否有参数的传入（因为类型为"undefined"的只有undefined这一个）.


13，下面的代码执行结果是什么
	if([])
		alert('yes');
	else
		alert('no');
分析：
js中空数组是真值，不是假值。所以会打印no。但是注意php中空数组是empty的所以用在判断条件中结果是假(php中if(a)和if(!empty(a))作用一样)


14，js中如何使用异常，catch到的异常变量的作用域是什么
分析与答案：
	var msg = "";
	try{
		throw Error('wrong');
	}catch(e){
		msg = e.message;
	}finally{
		//一定会执行得到的代码，但是据说在ie7和之前的版本存在bug
	}
js中抛出的是Error，而php中使用的Exception，捕获是php中catch会申明为Exception e，而js中直接是一个无类型的e。
在js中，和php一样存在函数内部的作用域和函数外部的作用域的区别，但是对于catch语句块存在一个意外，就是catch语句块中捕获到的异常变量的作用返回只有catch语句块可见(但是在catch语句块中定义的变量对整个函数都是可见的)。

15，一个变量赋值为undefined和只是申明没有赋值的undefined跟使用没有申明的变量有何区别
答案：
var a = undefined. 和 var a 没有任何区别，一个变量只是申明，没有定义（赋值）那么默认值就是undefined。而使用了没有定义的变量，虽然typeof操作符得到的结果是undefined的，但是不能直接进行取值运算，例如a == undefined也会报一个引用了未定义的变量的错误，变量在没有申明的情况下不能用作右值。
下面是具体的代码的测试结果:
	/*
	使用总结：
		1）没有申明的变量，只能用作左值（进行赋值），不能用作右值进行取值。
		2）没有申明的变量，可以使用typeof运算符，得到的结果是"undefined"，这个基本上是未申明变量唯一的可以使用的运算
		3）由于不能用为右值，所以 undefined == 未定义的变量  和 undefined === 未定义的变量 都会报错:  is not defined
	*/

	/*
	//用做判断条件 这里其实也是当右值用，所以报错：the reference a is not defined
	if(a){
		console.log("the value is true");
	}else{
		console.log('the value is false');
	}
	*/

	//用作typeof操作符的操作数，结果是"undefined"
	console.log(typeof a);
	/*
	//取值 用作右值。由于没有定义，所以不能用作右值（取值）
	console.log(a + "");
	console.log(a);
	*/

	/*未申明的变量不能用作左右，也不能与undefined相比*/
	//console.log(undefined == a);

16，如果简单进行正数与字符串之间的转换
答案：
因为是正数，所以对于字符串，只需要使用一个整数符号就可以转换。而数字到字符串的转换只需要"" + 数字就行。
1）整数到字符串： "" + a
2）字符串到数字: + "1"
3）在js中可使用parseInt和parseFloat将其他类型转换为int和float浮点型

17，js中的void是什么
答案：
js中void是一个操作符，无论传入任何表达式，其返回值都是undefined（一般的函数如果没有指定返回值，那么默认返回undefined）。实际上很多代码存在对void和typeof操作符的不正常使用，例如 href=“JavaScript:void(0)”,首先void是一个操作符，void()是计算一个()表达式然后将表达式的值赋给操作符void，所以括号完全是多余的，void也并不是什么函数。其次void操作符返回undefined，而这里的href写成这样往往意味着什么也不做（除非有人要在void操作数表达式上进行运算，不过这个基本没有意义）,可以直接写成href="JavaScript:undefined"


18,js中的逻辑运算符||的返回值是什么，与php有何不同。js中的&&运算符返回值与php中是否一样
答案：
1）||在js中，如果左边的表达式不是假值，那么返回左边的表达式的值，否则返回右边的表达式的值，最终的返回值不一定是bool类型的。而在php中||运算返回的是bool类型，要么是true要么是false（所有存在这里样的php面试题 if($a = 2 && $b = 5)这个表达式会将后面的$b=5然后与2进行&&得到true赋给$a）。
2）&& 在js中，如果左边的运算数是真值就返回右边的值，如果左边的是假值就进行逻辑短路直接返回值这个假值。同样php中所有的逻辑运算返回的都是bool类型
3）js中常常利用||运算符的特性，给数据设置默认值. var a = a || 'hello world'（一个小问题是，这里的变量前面最好要加上var，如果在形参中有这个变量的申明，那么这里是再次申明没有问题。如果是形参中写漏了之类的，这里如果没有var，就会导致出现一个全局的变量，如果外层的确存在这个变量，那么测试过程中就可能会出现无法预料的问题）
下面是进行测试的部分代码：
	//下面的测试应该注意算符运算符高于逻辑运算符，所以要加上括号
	console.log("2 || 3 : " + (2 || 3)); //2，前面的为真值就进行逻辑短路，直接返回前面的值
	console.log("0 || 3 : " + (0 || 3)); //3，前面的为假值就返回后面的

	console.log("2 && 3 : " + (2 && 3)); //3，前面为真值就返回后面
	console.log("0 && 3 : " + (0 && 3)); //0，前面为假值就直接返回前面的假值，进行逻辑短路

	//测试||运算符左边是假值
	console.log(0 || 3); //3
	console.log(0.0 || 3); //3
	console.log(false || 3); //3
	console.log(null || 3); //3
	console.log(undefined || 3); //3
	console.log('' || 3); //3
	console.log(NaN || 3); //3

19,对一个函数进行typeof操作得到的是什么
答案：
function。js中函数也是对象，可以有属性。


20, js中一个函数的length属性有什么用。js中的命名的函数表达式是什么，和函数的name属性有什么关系
分析：
1)在函数内部如果使用arguments.length属性可以获取到传入的实参的个数，但是如果要获取形参列表中申明了多少个形参，就得使用函数的length属性。这个属性可以获取到一个函数的形参列表中的参数的个数。（注意：js中函数是对象，所以可以有各种属性，用户也可以在给函数设置个性化的属性值进行驻留，用给下一次的调用）
2)js中定义一个函数一般可以直接使用function加上函数名和函数体进行定义。同时还有另一种常用的方法，是使用函数表达式的形式，具体的格式为 var func = function(){}; 这个时候function就成了一个操作符，而整写法就成了一个赋值语句。上面的写法是一般的匿名函数表达式，也可以使用命名函数表达式 var func = function namedFunc(){}; 这个函数的名称是namedFunc，可以通过func.name获取到。
3）对于命名函数表达式，其中的函数名只是函数名了，不能用来进行函数的调用。例如上面的 typeof namedFunc = 'undefined'。函数的调用只能通过通过表达式左边的var变量进行。
4）对于命名的函数表达式，一般将名称与左边的var的变量名写成一致。在早期的ie中，typeof namedFunc的结果是function（也就是说会创建两个变量）。还有如果二者的名称不一样，容易造成一些混淆。除非函数的名称在函数体中被用到，否则一般大家都是简写成匿名的函数表达式。

补充说明：
1）通过测试，如果函数表达式是匿名的，那么函数的name默认就是赋值表达式左边的变量名，又通过上面的分析，推荐将命名函数表达式的名称写成跟定义的var变量的名称一致（避免混淆）。那么这里得到的结论是命名函数表达式的用处基本没有。
2）函数变量进行传递的时候，尽管调用的形式各异，但是函数的名称不会改变
3）因为老版本的ie中存在命名函数表达式会创建两个符号的情况，而匿名函数表达式各种浏览器之间不存在兼容问题，都是创建一个变量然后将函数的name属性设置为默认的var变量的名称。所以从兼容性和实用性上看，都应该避免使用（除非自己独特安排和考量）命名函数表达式。
测试代码如下：
	//函数的length属性，与arguments.length属性
	function test(a, b){
		console.log("函数的形参个数：" + test.length); //2 固定的2
		console.log("函数的实际传入参数个数：" + arguments.length);
	}
	test(1); //输出2 1
	test(1,2,3,4); //输出 2 4，对于传递的额外的参数会被舍弃掉

	//匿名函数表达式
	var func1  = function(){
		console.log("func1");
	};
	console.log(func1.name); //func1

	//命名函数表达式
	var func2  = function namedfunc(){
		console.log("func2");
	};
	console.log(func2.name); //namedfunc
	console.log(typeof namedfunc); //函数的名称不会单独创建一个符号，这里的结果为undefined（但是在老版本的ie中可能存在创建了两个符号而这里的结果为function的情况）

	//函数间赋值,函数变量进行传递，但是函数名称不会改变
	var func3 = func1;
	console.log(func3.name); //func1


21，什么是作用域提升
答案：
指的是将变量的申明进行提升，例如在函数内部，会对函数体中的所有的变量的申明进行提升到函数体的最顶端（这个是js解释器做的事情），这样这些变量对于整个函数的作用域都是可见的。但是这里提升的只是申明，对于变量的赋值并没有同时提升。所以在赋值之前这些变量是默认值undefined。由于存在作用域的这种提升，所以将申明写在使用之后并不会出现is not defined的错误，而是使用了一个undefined的值。同样的分析适合于全局变量，他们将提升到所有代码执行之前


22，全局环境下,下面的语句执行结果是什么，原因是什么
	if(false){
		var a = "hello";
	}
	alert(a);
分析：
首先，在全局作用域下，无论是否使用var申明，a都是全局的变量，而且js中不存在复合语句块作用域。其次，js中存在变量作用域的提升，所有的申明会提升到最顶端（如果是函数内部，会提升到函数执行体的最顶端）。所以在alert(a)之前a是拥有申明的，但是由于赋值不会进行提升，而且这里的if判断条件为假导致没有提升的赋值语句不会执行到，所以a的内容是undefined。从上面的描述可以得到alert(a)打印的是undefined，不会报is not defined的错误，而是使用了一个undefined的值。同样的分析适合于全局变量.

23，对于函数表达式和函数申明两种类型的函数定义的形式，其进行作用域的提升有什么不同
答案：对于函数表达式形式的函数定义，在提升的过程中只是提升了申明，所以在定义语句之前这个函数的类型是undefined的，但是如果是函数申明形式的函数定义，那么函数的定义（实现）是一起提升的，相当于将函数的定义放到了作用域的顶部。
下面的测试代码可以说明问题：
	(function(){
		console.log(typeof express); //undefined, 函数表达式，只是提升了申明，没有提升定义
		console.log(typeof declare); //function，函数申明，提升的是定义
		var i = 1;
		var express = function(){};
		function declare(){};
	})();


24，什么是闭包，什么是作用域链
答案：闭包就是一个函数和其非局变量（也就是函数的外部）的环境。php是从5.3开始支持闭包和函数表达式(例如：$func=function($a,$b){})的。一个函数可以访问这个函数定义所在环境中的变量，这种父级函数和子级函数的关系形成了一条链，就是作用域链。js解释器进入一个函数的时候会将这个函数的局部收集起来存放到一个特殊的variables对象中。而在函数定义的过程中会设置其scope属性，这个属性指向了外部函数的variables对象（如果外部是全局的环境，那么保存的是全局的variables对象的引用），这个scope属性不是在执行阶段而是在定义阶段确定的。
全局环境下分析下面的程序执行过程：
	var i = 1;
	function test(){
		var sum = function(){return a + b + i;};
		var a = 2, b = 3;
		return sum();
	}
	test();
分析：首先构建全局的variables对象对象，其中存在一个var i = 1和test函数，test由于是一个函数，所以会设置一个scope属性指向全局的variables对象。然后执行test()，进入test函数体，构建test环境函数内部的variables对象，这这里面有一个sum函数和a、b变量，由于sum是一个函数所以会存在一个scope属性指向test函数内部的variables对象。然后执行return sum()会转入sum函数的定义体，在sum函数内部没有a和b的定义，所以会访问sum函数的scope属性也就是外部的test函数的variables对象，这里面可以找到a和b的定义，所以会引用这的a和b，但是test函数的内部也没有i的定义，所以会进一步的访问test函数的scope属性也就是全局的variables对象，找到了i的定义。故sum函数返回了6。


25，js和php中对于全局变量的访问有什么不同
答案：php中默认是不能函数外部变量的，也即是不能直接访问全局变量，默认情况下也不能直接访问闭包环境中的外部函数中的变量。如果要使用全局变量可以是用global $a。如果要使用父级环境中的变量可以使用use $var。而在js中对于闭包环境中的变量（包括全局变量）可以直接访问。


26，下面的代码是否正确
	function func(){
	}();
	function(){
	}();
答案：不正确，对于匿名函数可以直接function(){}()进行调用。但是对于命名函数，因为使用的函数申明的语法而不是函数表达式的语法，所以不能直接使用（）调用。如果要修正，可以将整个函数申明用分组运算符（）括起来，这样就将函数申明转换为函数表达式并且立即执行。修正后的语句为:
	(function func(){
	})();
另一方面，第二个写法也有问题，我们不能写成var res = function func(){}();因为一个函数申明的后面不能直接跟上括号调用。但是如果是一个匿名的函数直接funciton(){}()这个也是有问题，如果没有用返回值进行接收，那么js解释器会依然解释为函数申明，这个时候会出现函数申明没有提供函数名的错误。正确的写法是:
	(funciton(){})();或者是 var res = function(){}();

27,立即函数有什么作用
答案：立即函数又叫自执行或者自调用函数或者立即调用函数表达式。是指函数定义之后立即执行的一种语法。可以有以下两种形式：
	var res = function(){}();  (function func(){})();
立即函数的作用主要有进行初始化工作和通过对立即函数中变量的引用实现变量的私有化。例如下面的例子：
	var func;
	//立即函数很多只执行一次，用于进行初始化。如果直接在全局换进行书写代码初始化，那么在其中使用到的变量可能会造成全局环境的污染。
	function(){
		var i = 121; //这个变量在立即函数内部，实现了私有
		//这个外部的函数的定义在闭包之中
		func = function(){
			alert(i);
		};
	}();


28，下面的代码输出为何
	var funcs = [];
	for(int i = 0; i < 3; ++i){
		funcs[i] = function(){
			return i;
		};
	}
	console.log(funcs[0]());
分析：
js中的闭包保存的都是对外部变量的引用，所以在定义funcs[i]的时候其定义体中只是指明对i进行引用。在循环执行结束之后i=3，由于三个函数的函数体是一样的，所以这个时候funcs[0] funcs[1] funcs[2]返回的都是3。上述代码如果要修改为每次返回不同的i，可以使用立即函数，将i作为形参输入的方式去定义funcs[i]，这样内部的函数体每次返回的是对一个不同的局部变量的引用（每次执行都会构建不同的variables对象，而每一个的函数的scope只有一个）。具体的代码如下：
	var  funcs = [];
	for(int i = 0; i < 3; ++i){
		funcs[i] = function(arg){
			//每一次传入不同的arg，不同的arg用不同时期的i进行初始化
			return function(){
				return arg;
			};
		}(i);
	}
	console.log(funcs[0]()); //返回0


29,call调用和apply调用有什么区别
答案：最明显的区别就是call的参数列表第一个是调用的对象，后面是参数列表。而apply第一个参数是调用对象，后面是一个数组。

30,setTimetout的参数列表
答案：
setTimeout表示多久时间之后执行一个函数，其参数列表为setTimeout(func,time,参数列表...)。但是实际使用中，第一个参数也可以接受字符串，在setTimeout的内部会检测第一个参数是否为string，如果是字符串，会进行eval调用，否则会进行func()调用。


31，js中的方法和属性有何不同。
答案：js中函数也是对象，方法和属性没有本质的不同，不过方法可以进行调用而已。js中没有类，继承是通过原型的。

32，构造器函数中的返回值类型对最终构造的对象有何影响
答案：
构造器函数中如果没有return或者return了基本数据类型，那么构造器会坚持返回this。如果构造器中返回的是一个对象，那么this将会失效，函数采用的是返回的指定对象。这种情况下，称之为构造器调用，这个时候new func()和直接将构造器当初普通函数执行func()一般是没有区别的。使用构造器调用，会导致instanceof运算符和constructor属性与预期的不一致。
下面是构造器调用的代码：
	//构造器中返回基础数据类型的时候，会依然返回this
	function Func1(){
		return 1;
	}
	var f1 =  new Func1;  //和其他的语言一样，如果使用的是默认的初始化列表，new操作符后面类名中的括号可以省略。
	console.log(f1 instanceof Func1); //true

	//构造器中返回对象，那么就不会返回this了。this被舍弃，这个时候instanceof和constructor属性不会正常显示
	function Func2(){
		return {
			'a' : "hello"
		};
	}
	var f2 = new Func2(); //这个时候完全可以去掉new，所以称之为构造器调用
	console.log(f2 instanceof Func2); //false
	console.log(f2 instanceof Object); //true。因为是直接量，所以原型是Object.prototype
	console.log(f2.constructor === Object); //Object.prototype.constructor属性指向的是Object


33，构造器函数如果没有new，那么其中的this会指代到window，这个时候可能出现一些意想不到的污染。如何避免。
答案：
一方面，对于构造器函数，首字母要大写。这样让调用者很清楚的知道调用意图。另一方面，构造器函数在执行的时候，如果不是通过new调用，那么内部的所有this会指代到window，通过这一点，可以在构造器函数的入口判断this是否是window或者是其他的不符合类型的对象，如果是不符合类型的对象就重新new一个当前构造器的实例返回，如果this的确是当前需要的类型，就接着往下面走进行属性的设置。（注意：在ES5中的严格模式下，是可以检测到这种一样的this的，并且解析报错）
下面的代码展示如何避免丢失new而造成的意外。值得注意的是一个对象一旦创建其原型链就不能更改(注意，这里说的原型链其实是__proto__链，而prototype属性是开放的设置接口)，prototype属性不能修改，所以使用instanceof检查原型链来判断是否是某一个类型的实例是可靠的，但是如果是使用constructor属性进行检查，由于这个属性是可更改的，会出现问题:
	//修改构造器函数入口，如果this不是要求的类型的实例，就重新new
	function Func(){
		if(!(this instanceof Func))
			//没有通过new进入，所以重新new
			return new Func();
		this.attr = "hello";
	}
	var va = Func();
	console.log(va); //{attr:"hello"}

	var vb = {"key":"value"};
	var vc = Func.call(vb); //vb的原型链上没有Func，所以还是会创建新的实例对象
	console.log(vc);


34，为何Function instanceof Object和Object instanceof Function都是true
分析：
Array Function 和 Object都是内置的构造器函数，所有的构造器函数的__proto__都是指向Function.prototype的，随意Object是Function的实例。而Function.prototype这个对象的__proto__属性又指向了Object.prototype，这样所有的构造器函数的原型链上都有了Object.prototype。所以Function是Object的实例。
补充：
Array Object Function都是内置的对象。用户用function关键词创建的函数是由js解释器创建的对象，他们都是由Function创建的，他们的原型属性__proto__也是指向Function.prototype。Function在创建这些函数的同时会创建一个默认的原型对象，这个Foo.prototype中默认只有一个__proto__属性指向了Object.prototype和constructor被初始化为当前函数Foo的引用。由于Foo.prototype.__proto__指向了Object.prototype，所以通过new Foo创建的对象也是Object的实例。
实测代码：
	console.log("Array Object Function的__proto__都是Function.prototype:");
	console.log(Array instanceof Function); //ture
	console.log(Object instanceof Function); //ture
	console.log(Function instanceof Function); //ture
	console.log("Function.prototype.__proto__是Object.prototype，所以所有的函数都是Object的实例:");
	console.log(Function.prototype.__proto__ === Object.prototype); //ture


35，通过new Foo()创建的对象可以访问那些方法
答案：
首先在Foo中通过this设置的属性都是这个new创建对象的属性，其中的方法是可以访问的。除了这个对象上的直接的方法，还可以访问原型链也就是__proto__属性对象上方法。所有的构造器函数在创建的时候都会创建一个默认的原型对象用其prototype属性指向，这个默认的原型对象的__proto__指向的是Object.prototype，所有在默认的情况下，new出来的对象可以访问其自身和Object.prototype中的方法。当然在new之前相应的函数的prototype属性是可以修改的，如果修改了指向那么可以访问这个指向对象中的方法。同样，由于new出来的对象指向了这个函数的prototype属性，那么如果将方法直接加给这个函数的prototype，那么也是可以访问的到的。


36，new出来的对象有没有constructor属性，使用function申明的函数有没有默认的constructor属性。
答案：
一方面new出来的对象和function申明的函数对象这两个对象的直接属性上都没有constructor属性。constructor属性是Function创建构造器函数的时候为其原型对象上设置的一个属性，这个属性保存的是构造器函数的引用。在没有人为的修改constructor属性的情况下，可以通过new出来的这个对象直接访问constructor属性获取创建自己的函数（当然，由于这个属性可以修改，所以并不保险）。constructor由于可以修改，所以很多时候在判断时候使用instanceof而不是通过访问这个属性。instanceof操作符是通过查看原型链上面是否存在相应的构造器函数的prototype来判断是否是一个构造器函数的实例。由于一个对象创建之后其__proto__属性是不可以修改的，所以这种判断方法是保险的（当然，由于函数的prototype可以修改，结果可能与预期不一样，但这个结果是正常的，因为函数修改后本来就不是原来的预期的样子了）
另一方面，所有的原型链的最后两级都是Object.prototype和null，而Object作为构造器函数也是由Function创建，所以Object.prototype.constructor = Object，这样所有的对象的原型链上是有constructor的


37，说明Object.prototype Function.prototype Array.prototype。它们的__proto__都指向了什么
答案与分析：
Function.prototype.__proto__和Array.prototype.__proto__都是Object.prototype，正是由于这个原因，所有new出来的对象都是Object的实例。Object.prototype.__proto__为null。
代码实测：
	console.log(Function.prototype.__proto__ === Object.prototype); //true
	console.log(Array.prototype.__proto__ === Object.prototype); //true
	console.log(Object.prototype.__proto__ === null); //ture，这里可以得到一个结论，所有的原型链的最后两级一定是Object.prototype和null


38,一个函数，如果将其prototype设置为null或者基础数据类型，会有什么后果
答案：
instanceof等涉及到原型链的访问的操作会出现问题，由于new出来的对象的__proto__为函数的prototype，这个时候由于prototype为null所以这个__proto__会直接指向Object.prototype。所以创建的对象只是Object的实例。这个时候如果访问test instanceof Test，会由于Test.prototype为null抛出异常
实测代码；
	function Test(){
		this.name = "test";
	}
	Test.prototype = null;
	var test = new Test();
	console.log(test instanceof Object); //ture
	console.log(test instanceof Test); //抛出异常，提示prototype of Test is not an object


39，一个变量保存了一个属性的名称字符串。那么如果通过对象访问这个这个属性。
答案：
访问对象的属性，一般可以通过o.attr或者是o[attr]，由于属性的名称是保存为字符串，那么如果是使用o.attr会造成歧义，这种情况下只能使用o[atrr]。o[attr]其中会进行变量的解析。


40,设计一个函数，获取到一个对象中的非方法的属性。返回字符串格式为"属性名1：值1，属性名2：值2"
分析：
如果一个属性是方法，那么可以通过typeof获取到，typeof得到的是一个字符串"function"。所以可以遍历一个对象，过滤掉其中的方法，然后将键值对构成返回的结果字符串。
实际编码：
	function func(obj){
		//遍历obj的属性列表，将非方法的属性键值对加入array
		var arr = [];
		for(var key in obj){
			//通过typeof筛选掉方法
			if(typeof obj[key] !== 'function')
				arr.push(key + ":" + obj[key]);
		}
		//组成字符串 join函数类似与php中的implode
		return arr.join(',');
	}

	var obj = {
		name : 'coder',
		age : 13,
		func : function(){
			alert('i am a function');
		}
	};
	console.log(func(obj));  //name:coder,age:13


41,for in是否可以获取到原型属性上的属性
分析：
js中的for in是遍历对象的所有的属性。这里包括原型链上的对象的属性。但是for in只能用于遍历得到用户自定义的属性，内置的属性是不能被遍历到的。
实测代码：
	var proto = {
		name : 'coder',
		age : 11
	};

	function Func(){
		this.address = 'china';
	}
	Func.prototype = proto;
	var obj = new Func;
	for(var key in obj){
		//这可以遍历到三个属性，所以说明是可以访问的到圆形链上的上级对象的属性的
		console.log(key + ":" + obj[key]);  
	}


42,如何判断一个对象的属性是自身的还是继承自原型链
答案：
可以通过Object.property上面的hasOwnProperty来判断是这个对象本身拥有的属性。


43，js中能否通过.来访问数组，php中能否通过->来访问数组
答案：
js中对象和数组的访问形式没有区别，都可以通过[]或者.进行访问。在php中对象可以通过->或者[]访问，但是对于数组，只能通过[]访问，如果->的做操作数是一个数组，会出现一个notice：trying to get property of non-object
代码：
	var arr = [1,2,3];
	arr.name = 'coder'; //通过对象的访问形式访问数组
	console.log(arr['name']); //"coder"


44,说明Object.create()
分析：
Object.create()是ECMAScript5的一部分，来自于json的发明者Douglas Crockford提出的begetOjbect函数。作用是返回一个以指定对象为原型的对象。begetObject函数的如下：
	function begetObject(proto){
		//使用一个临时函数，将其原型属性设置为传入的参数
		function F(){}
		F.prototype = proto;
		return new F;
	}
个人改进版begetObject，将F函数直接放到begetObject函数的prototype上，这样就不用每次进行函数都创建一个F():
	function begetObject(o){
		//利用将F保存到原型，避免每次创建F
		var F = begetObject.prototype.F = begetObject.prototype.F || function(){};
		F.prototype = o;
		return new F();
	}


45，实现一个extend函数extend(parent,child)，将parent的属性拷贝给child
分析：
for in 会访问所有的非内置属性，包括原型链上面的对象的属性。所以可以通过for in 遍历parant，然后进行属性的拷贝赋值。
代码：
	function extend(parent,child){
		//利用for in遍历parent的所有属性，然后依次拷贝到child
		for(var key in parent){
			child[key] = parent[key];
		}
	}
	var o1 = {
		'name':'coder'
	};
	var o2 = {
		'age':11
	};
	extend(o2,o1);
	console.log(o1);


46，实现一个extend(Child,Parent)函数，让构造器函数Child经典继承构造器函数Parent
分析：
最简单的想法是直接Child.prototype = Parent.prototype，但是这里存在一个问题就是这样修改了Child.prototype原本的constructor，如果直接在这个新的原型上进行修改，那么由于js中对象是引用传递，那么就是直接修改Parent.prototype，这样就会导致用Parent创建的对象中的constructor不正确。所以考虑再创建一个对象，让其原型为Parent.prototype，然后将Child.prototype指向这个新对象。最后在这个新对象上修正constructor。根据书上的介绍，为了方便，可以在这个新对象上增加一个parent名称的属性，保存Parent的引用以方便可能的引用
代码：
	function extend(Child,Parent){
		//利用一个临时函数，将其prototype设置为parent.prototype
		function F(){}
		F.prototype = Parent.prototype; //通过分析，不能直接Child.prototype进行传递，因为不方便纠正constructor属性
		Child.prototype = new F;
		//修正Child.prototype.constructor
		Child.prototype.constructor = Child;
		//增加一个Parant的引用
		Child.prototype.parent = Parent;
	}


47, 使用window.o和全局环境下使用var o，两者有什么区别
答案：
window引用全局对象。在全局环境下通过var申明的对象都会自动的添加到window下。所以全局环境下通过var申明的变量通过window.o访问也是一样的。二者只存存在一个区别就是通过window.o直接赋值的属性可以通过delete进行删除(删除之后通过window.o访问得到undefined，也就是访问了一个对象的未定义的属性，但是如果直接访问o，会报错说明o is not defined)。但是通过var申明的全局变量不能删除。
测试代码：
	var o1 = 11;
	window.o2 = 22;
	//以下四个访问都是正常的
	console.log(window.o1); 
	console.log(window.o2);
	console.log(o1);
	console.log(o2);
	//var申明的全局变量不能删除，而window.o添加的变量可以通过delete删除
	delete o1;
	delete o2;
	console.log(o1); //11 还是可以访问，说明删除失败
	console.log(window.o2); //undefined 访问了一个对象的未定义的属性
	console.log(o2); //error: reference o2 is not defined。访问了一个未定义的变量，因为并没有内置对象o2


48，全局对象拥有哪些内建属性（全局属性）和方法
答案：
属性有三个：NaN（例如1 * 'a'的结果） Infinity(例如1/0的结果)  undefined（例如只有申明没有赋值的变量的内容和类型都是undefined）
全局函数有9个：
	eval(): 和php中的eval函数类似，但是由于存在不安全和变量运行环境的污染问题，所以一般不使用
	isNaN(): 对应php中的is_nan()，检测传入的参数是否是NaN
	isFinite(): 类似与php中的is_finite()检测是否传入的值是否是有穷的，如果传入的是Infinity，那么会返回false
	parseInt(number,base默认为10): 类似与php中的intval()
	parseFloat(): 类似与php中的floatval()
	encodeURIComponent()和decodeURIComponent(): 类似与php的urlencode()和urldecode()
	encodeURI和decodeURI: 这两个函数与上面的两个函数的区别在于不会对主机名前面的http://进行编码和解码，另一个方便不会对&进行编码。而encodeURIComponent()是会对&和http://中的:和//都进行编码的。
---note：
	在讨论js的时候escape和unescape函数不是ECMAScript的一部分，是属于有BOM的，它们的工作方式和encodeURI encodeURIComponent不一样。据书上说明程序员应该避免使用这两个BOM中的函数。



49, 利用parseInt将传入的一个形如#ffffff的16进制的颜色表示转换为形如rgb(255,255,255)形式的rgb的表示
分析：
首先通过slice将传入的16进制提取出r、g、b三个部分，然后将各个部分转换为10进制表示，最后拼接字符串
代码：
	function hex2Rgb(hex){
		var r = parseInt(hex.slice(1,3), 16);
		var g = parseInt(hex.slice(3,5), 16);
		var b = parseInt(hex.slice(5,7), 16);
		return "rgb(" + r + "," + g + "," + b + ")";
	}


50，全局对象上有哪些内建构造器
答案：
Object() Array() RegExp() Function() String() Number() Boolean()  Date() Error()
说明：
①：Object() Array RegExp() Function() 他们一般用来使用其原型或者是直接使用这个构造器对象的方法例如Object.create()。由于这四个构造器的对象一般是用直接量直接书写，所以很少的用new的方式创建它们的对象。
Object()构造器：
	其对象一般直接书写为var v = {} 而不是去new Object()。这样更简洁。但是Object构造器是可以接受一个参数的，如果这个参数有传入，那么会根据参数的类型选择其他的特定构造器进行对象的构建，例如new Object('hello')由于传入的参数是string类型，那么会将对象的构造委托给String()构造器。值得注意的是，如果这样使用，传入一个参数，那么会显得有些多余的同时会不能在调用的时候很显现的知道实际构造的对象的类型。所以这种带参数的构造一般也是不进行使用的。
Array()构造器：
	其对象一般书写为直接量[]而不是进行new Array()。这个构造器也可以传入一个参数，如果是一个数字，那么这个数字指定创建的初始数组的长度，也就是给length属性赋值，但是实际位置并没有开辟空间仍然是undefined（注意如果传入的参数是数字，那么只能是整型，如果是浮点会报错）。如果传入的是字符串，那么会创建只有一个元素的数组，这个元素就是传入的参数。通过上面的描述可以发现带参数的构造也是不好用的。所以Array的实例也是用直接量书写[1,'2',3]
RegExp()构造器：
	new RegExp('[a-z]')，直接使用构造器进行对象的构造一般原因是传入了一个字符串。一般情况下是使用直接量定义 /[a-z]/。另外，构造器如果直接当做一个函数使用，是实现将字符串转换生成一个正则对象，实现的结果和new出来的结果是一样的。也就是RegExp('[a-z]')和new RegExp('[a-z]')是完全一样的。
Function()构造器:
	可以通过new Function('a,b','return a + b;')或者不用new直接Function('a,b','return a + b;')这种形式创建一个函数对象（如果只要一个参数，表示没有形参，传入的是一段代码）。不过这种形式不是很常用。在有些环境下这样使用可以替代eval()，因为eval函数会污染调用eval的上下文环境,但是Function('dosomething')()由于会创建临时环境，可以避免污染(另一个细节点是Function创建的本地作用域的scope指向的是全局环境)。
②：String()构造器：
	一方面可以使用new String('xxx')创建一个String对象，但是由于存在装箱机制，所以可以直接用原始类型的字符串进行方法的调用，所以这种new对象的实用性不强。另一方面，String作为一个函数直接使用可以将参数强制转换为原始的字符串类型，例如String(1)是将数组的1装换成字符串"1"
③：Number()构造器：
	可以使用new Number(传入数字或者字符串)构建Number对象。如果不使用new，而是Number('1.1')返回的是基本数据类型，进行了一次强制类型转换。注意数字的基本类型，不能直接进行方法的调用，不过可以通过使用()将数字包裹起来然后进行调用。例如3.tofixed(2)是不合法的，但是可以通过(3).toFixed()变得合法。所以一般也没有new对象的需要。
④：Boolean()构造器：
	基本不使用new进行构造，new Boolean(fasle)，作为一个对象其值也是真。!new Boolean(false)返回的是false。
⑤：Error()构造器：
	可以使用new Error()或者是其他的错误构造器抛出一个自己的错误。对于错误，跨浏览器可用的属性一般有两个，一个name表示构造器的名称（例如Error），一个是message,为错误提示信息。程序中也可以抛出任何的拥有name和message属性的对象。例如 throw{name:'myerror',message:'an error occured'}
⑥：Date()构造器：
	主要的构造形式有new Date(时间戳或者一个形如"December 11,2000"这样的日期字符串) new Date(年,月，日 [,时，分，秒，毫秒])。


51，Object.prototype上面的方法有哪些
答案：
toString(): 对于任何直接量对象，Object的原型上的代码返回的是"[object Object]"，对于Array返回的是"object Array"，对于JSON返回的是"[object JSON]"。相比与typeof操作符获取到的可能只是一个简单的Object，利用toString()可以获取到更丰富的信息（可以显示用来创建对象的内部类的信息）。
toLocaleString():转换为本地字符串，对于不同的区域可能会显示的有所不同，这一点在对new Date().toLocaleString()上可以看得更明显，在美国欧洲和中国会显示成不同的当地接受的显示格式。
valueOf(): 对于对象直接量、数组、正则对象和函数这样的常规对象这个方法返回的是其调用者本身。而对于包装类型Boolean Number返回的是其基本类型。对于Date类型返回的是时间戳，效果和new Date().getTime()相同。
hasOwnProperty(): 可以用来区分一个属性是自身的还是原型链上面继承的。
isPrototypeOf(): 判断某一个对象是否在传入的参数的原型链上。例如Array.prototype.isPrototypeOf([])和Object.prototype.isPrototypeOf([])都为真。
constructor属性： 用来保存构造器函数的引用


52，for in循环中是否可以遍历到原型继承来的属性，如何实现循环中只操作自己的属性而不操作继承来的属性
答案：
使用hasOwnProperty函数进行过滤，如果不是自己本身的属性就接着进行属性的遍历
	for(var key in obj){
		if(!obj.hasOwnProperty(key))
			continue;
		dosomething(); //实际应该进行的操作
	}


53，Array.prototype有那些方法和属性
答案：
length属性：这个属性指示数组的长度，但是这个属性是可以修改的，如果是单独的进行这个属性的修改，那么实际通过脚标访问到的元素依然是undefined。
push():和php中的array_push()类似，将一个元素追加到数组的后部。php中是面向过程的函数array_push($arr,v1,v2,...)，而js中是Array.prototype上的方法[1].push(2,3)这个方法返回更新之后数组的length
pop(): 从数组中删除最后一个元素，并且返回这个删除的元素。和php中的array_pop()类似
unshift(): 在数组的头部添加元素，内部会设计到后续数组脚标的修改，返回新的length。
shift()： 删除第一个元素并且返回这个元素。这个函数删除第一个元素之后会修改后续元素的脚标，让他们进行前移。
concat(): 类似于php中array_merge()。a.concat(b)函数操作的两个数组对象本身不会被修改，返回一个新的合并之后的数组。concat()可以传入多个参数，如果参数是非数组，那么会被当做一个简单元素直接加入最后的结果集中，如果参数传入的是数组那么会进行元素的合并。
sort():默认是自然排序，可以接受一个回调，实现定制的排序。arr.sort(function(a,b){return b - a;})就是实现一个反序的数字排序
slice(): 和php中的array_slice()有所不同，php中第二个参数传入的是长度，设计是类C的。而js中第二个参数传入的是结束的索引（索引-1代表最后一个元素，如果不传入，第二个参数默认是length。注意这个函数截取的子数组中不包括结束的索引位置）
splice(): 类似与php中的array_splice()函数。js中splice函数第一个参数是起始删除位置的索引，第二个参数是长度。后面的参数个数是任意的，是在删除的位置插入的新元素。和php中一样，splice函数会修改元素的脚标，内部的实现可以认为是将删除位置的前半部分+待添加的元素+删除位置后面的元素进行concat操作。从第三个参数开始，会将元素依次添加到调用数组中，即使传入的参数是一个数组，也会将这个元素当做一个单一元素加入到调用的数组中。上述的描述基本和concat一致，区别是concat不会操作原数组，而splice函数就是在调用者本身上面进行操作，还有就是concat参数的参数如果是数组，会将数组的元素依次取出来进行追加，而splice函数是直接将这个数组对象追加到调用的数组上。splice函数和php中一样返回的是删除的元素构成的子数组。
reverse(): 类似与php中的array_reverse()是将数组中的元素进行反序对调。
join(): 类似与php中的implode函数，只是这里是面向对象的调用方式，将一个数组中的元素取出来构成一个字符串。例如arr.join(',')就会将数组中的元素依次取出来用逗号进行连接。js中String.prototype.split(',')与php中的explode函数类似，是将字符串切割成数组。


54，下面的代码结果是什么
	var arr = [1];
	arr.length = 10;
	console.log(arr[1]); //undefined
	arr[99] = 99;
	console.log(arr.length); //100
分析：
js中的数组的length和php中的count()函数进行统计是不同的。js中的length只是会设计到数字脚标的计算，这个脚标是从0开始依次递增的。arr.length = 10，只是单纯的修改了length属性，并没有添加arr[1~9]所以访问arr[1]得到的是undefined。arr[99] = 99会向数组中添加一个新元素，新元素的脚标是99，内部会重置length，将length修改为100.


55，关于concat函数，下面的输出结果是什么
	var a = [1,2,'a'], b = [1,2,'b'];
	var c = a.concat('c',b);
	console.log(a); //不变
	console.log(b); //不变
	console.log(c); //先将a加到新的数组，然后将‘c’加进去，最后将数组b中的元素追加到结果中
分析：
concat()函数位于Array.prototype上，其操作是返回一个新的对象，不会修改传入的数组，所以传入的数组的不会改变。concat函数可以传入多个参数，如果一个参数不是数组，就会当做一个单一元素直接添加到结果数组中，如果是数组，会遍历其中的元素，然后依次追加到结果数组中。


56，使用sort函数进行数字序列从大到小的反序排序。使用sort写一个元素的打乱排序。
分析：
无论是反序还是打乱，出发点都是对sort函数传入一个回调函数，这个回调函数如果返回整数就表示第一个元素在后面，如果是负数就表示第一个元素在前面,如果是0那么他们的相对顺序不变。
实际编码：
	//进行数字的从大到小排序
	var numbers = [2,4,3,1];
	numbers.sort(function(a,b){
		return b - a;
	});
	console.log(numbers);  //Array[4,3,2,1]

	//进行数组的打乱排序 这里利用Math.random()产生随机数
	numbers.sort(function(a,b){
		return Math.random() - 0.5; //因为random出来的元素是0~1分布，所以减去0.5刚好构成随机的打乱
	});
	console.log(numbers); //打乱


57，Array.prototype.splice()函数第三个参数如果传入的是一个数组，那么会不会像concat函数那样将数组中的元素依次添加到调用的数组上 。
答案：
不会，因为splice不会像concat那样进行传入参数是数组类型的判断。而是会直接将这个数组对象当做单一元素直接追加到调用的数组上。
代码：
	var input = [1,2,3,4,5,6,7,8,9,10];
	var slice = input.splice(2,2,'a',['xx','heh'],'b'); //返回的结果是截取的删除元素的子数组[3,4]
	console.log(input);  //[1,2,'a',Array[2],'b',5,6,7,8,9,10]，即使传入的追加元素是一个数组也是直接当做一个普通元素进行追加
	console.log(slice);


58，下面的代码运行的结果是什么
	function gimme(){
		return /a-z/;
	}
	var a = gimme();
	var b = gimme();
	console.log(a === b);  //false 但是据书上说明在ES3中这个表达式的值是true
分析：
在ES3中存在一个情况就是所有的正则直接量只会解析一次，所以a === b。但是在后续的js中没有这个情况了，内部创建了两个不同的对象


59，RegExp()构造器，有那些限定符
答案：
g： 是global的意思，是进行全局匹配，而不是只匹配一个。其实就是在匹配之后将内部的指针后移，如果不进行这种后移，那么每次匹配的都只会是第一个匹配。
m：multiline的意思，是进行多行匹配。如果是多行匹配，那么会修改^$这两个的意思，^变成了行首而$变成了行尾，例如如果写成/^a/m会匹配到每一行的行首的a。
i: 忽略大小写。
---补充：
	上面的三种限定符，在默认的情况下都是false，也就是都是不生效的。可以通过new RegExp('[a-z]','gmi')或者是/[a-z]/gmi在创建对象的时候进行限定。另一方面在创建对象之后对reg.ignoreCase  reg.global reg.multiline这三个属性是不可以进行修改的，这三个属性是不可直接修改的,可以通过重新赋值正则直接量，或者是通过compile函数创建新的正则对象
---note:
	指定限定符其实是初始化正则上面的对应的属性。只有创建的时候才能进行这几个属性的指定，创建之后相应的属性(所有属性包括:source  lastIndex global multiline ignoreCase)是不能直接修改的，如果要修改相应的属性可以通过compile函数（这个函数内部其实是重新创建对象）。


60，下面的代码运行的结果是什么
	var reg = /^a/;。
	reg.multiline = true;
	console.log(reg.test("b\na")); //属性不能直接更改
答案：
结果是false，因为正则对象创建之后，属性是不能直接被程序员修改的。所以这里reg.multiline一直是false，没有多行匹配的情况下不能匹配到第二行的a


61，正则对象上本身有那些属性
答案：
source： 表示匹配的模式字符串（不包括限定符）
lastIndex： 最后一个匹配之后的位置。起始在0，如果没有设置global匹配，那么每一次匹配之后这个属性是不动的，如果设置了全局匹配，这个指针会在每一次匹配之后后移。在最后发现不匹配之后会重置为0.
global: 全局匹配。
mulitiline: 多行匹配
ignoreCase： 忽略大小写。
---note： 上面的所有的属性是不能直接通过对象访问的方式进行更改的。


62，RegExp.prototype上面有哪些方法
答案：
compile('模式字符串','限定符')： 其实就是重置内部对象
test('要匹配的字符串'): 测试一个字符串中是否有相应的匹配，如果匹配到返回true
exec(): 对一个传入字符串进行一次匹配。返回的结果是一个数组，第一项是整个匹配结果，后面依次是子表达式的匹配。如果没有匹配到返回null（在global匹配的情况下，如果返回null会将lastIndex重置为0)。值得注意的是返回的结果数组存在两个属性一个是input保存是这次匹配的输入字符串，另一个是index保存的是这次匹配的位置。
toString():  返回的字符串格式是 "/^a/gmi"


63，写出利用exec进行所有的匹配的代码：
答案：
	var reg = /[abc]/g; // 要进行所有匹配，应该设置全局匹配
	var str = 'azsbcdad';
	var result;
	while(null !== (result = reg.exec(str))){
		console.log(result);
	}


64，比较Function(code)()和eval()和区别
答案：
一是Function构造器会创建的函数对象会有一个本地环境，其scope指向了全局环境。所以不会对调用的上下文构成污染。另一个方面，由于scope指向的是全局的环境，所以不能直接引用调用上下文中的变量了。而eval可以直接引用调用环境中的变量但是存在污染调用环境的情况
代码：
	(function(){
		var v = 'hello';
		//使用Function创建本地作用域不会污染当前这个function的环境，但是也不会引用到这个调用环境中的变量
		Function("var f = 'function'; console.log(f); console.log('undefined' === typeof(v));")(); //打印function和true，也就是在内部是看不到v的
		console.log('undefined' === typeof(f)); //ture，不会污染到调用环境

		//使用eval可以直接引用调用上下文的变量，同样在eval中定义的变量也会对这个调用上下文构成污染
		eval("var e = 'eval'; console.log(e); console.log('undefined' === typeof(v));"); //打印eval和false，也就是在内部是可以看到调用上下文的
		console.log('undefined' === typeof(e)); //false，在eval中执行的代码污染到了调用环境
	})();


65,new Function('')对象上有那些属性和方法
答案：
length属性：是直接存在在函数对象上的，表示预期的形参数量。
name属性：也是直接存在在函数对象上的。但是不是ECMAScript的一部分，表示函数的名称。
call(调用对象,参数1，参数2...): 存在于Function.prototype上
apply(调用对象,[参数列表数组]): 存在于Function.prototype上


66，String.prototype上有那些属性和方法。String对象本身上有那些属性
答案：
String 对象本身上有一个length属性加上每一个字符。例如new String('ab')上面存在length=2和0=>'a' 1=>'b'
String.prototype上面的属性如下：
length属性：指示字符串的长度，对应php中的strlen
indexOf()：查找一个字符第一次出现的位置，相当于php中的strpos($str,'a')
lastIndexOf(): 查找最后一次出现的位置，相当于php中的strrpos()
charAt(): 获取某一个索引位置的字符，在php中可以直接使用$str[0]形式访问
charCodeAt(): 获取的对应的字符的assic码
toLowerCase(): 相当于php中的strtolower($str)
toUpperCase(): 相当于php中的strtoupper()
concat('a','b'): 拼接上其他的字符串
substring(开始索引，结束索引)：js中String.prototype上还有个slice函数和这个函数是一样的功能。至于substr()函数接受的第二个参数是长度，但是这个函数不是标准中的。
localeCompare(): 和一个传入的字符串进行自然比较，如果更大返回正数。
split(): 类型与php中的explode，是将一个字符串用某个字符串切割成为数组。这里的切割模式的传参可以是正则表达式。
search(): 查找一个字符串出现的位置，传入的参数可以是正则。如果没有找到返回的是-1。注意php中的strstr()函数也是查找一个子串，但是返回的是查找的位置开始到原串结束的子字符串。
replace()：这个和php中的str_replace()有所不同，如果第一个参数是传入一个字符串模式，那么只会替换一个查找到的匹配。如果要进行所有的匹配替换需要将第一个参数传入正则，并且带上g限定符。正因为如此，所以js中的replace()函数的调用为了明确的表达自己的意图第一个参数应该统一的传入正则比较妥当。replace()第二个参数如果传入的是字符串，那么这个字符串中可以使用$1~$n指代前面匹配到的子表达式。另外第二个替换的传入参数可以是一个回调，格式为replace(匹配模式,function(match,index,input){//其中match是匹配到的内容,index是匹配到的位置，input是输入字符串})。注意这里的回调的最后两项形参是查到的索引和传入的源字符串（一直不会改变），而前面的match很可能对象多个传参，第一个传参是完全匹配，后续的是子表达式对应的匹配。
match()：传入一个正则表达式，如果带有g限定符，那么这个函数的作用相当于php中的pre_match_all，如果没有g限定符那么就是一次匹配（只进行一次匹配的时候和RegExp.prototype.exec效果一样）。match函数如果没有任何的匹配会返回null。无论是否是一次匹配，这个函数返回的都是一个数组，数组中的每一项对应一个匹配到的字符串。这个函数不会进行子表达式的保存，所以如果要获取相应的字表达式的匹配，可以在这个结果的基础上进一步处理。


67，形如"a, b , c  ,  d"的字符串，写一个算法将这个字符串切割成为数组['a','b','c','d']
分析：
String.prototype.split函数传入的切割模式是可以是一个正则表达式的。这里可以传入一个/\s*,\s*/进行切割。
代码:
	console.log(String.prototype.split.call('a, b , c  ,  d', /\s*,\s*/));  //Array['a','b','c','d']



68，形如"张三,李四,王五"这样的格式，利用replace将内容修改为"三张,四李,五王"
分析：
一方面，可以在替换的字符串设定上使用$1 $2这样的子表达式进行书写。另一方面，也可以使用回调函数进行处理。 
代码：
	//使用子表达式
	console.log("张三,李四,王五".replace(/([^,])([^,]+)/g, '$2$1'));
	//使用回调
	console.log("张三,李四,王五".replace(/([^,])([^,]+)/g, function(){
		//arguements最后两个形参是index和input对应查找的位置和输入的源字符串。前面的三个参数是完全匹配和两个子表达式对应的匹配
		return arguments[2] + arguments[1]; //操作两个子表达式
	}));


69，Number构造器本身有那些属性，Number.prototype上有哪些方法
答案：
Number()上常见的属性有：
	Number.MAX_VALUE: 为最大的double，大约为1.79 * 10^308
	Number.MIN_VALUE: 5e-324，为何为这个数暂时不清楚
	Number.POSITIVE_INFINITY: 最大的正数，值为 Infinity
	Number.NEGATIVE_INFINITY: 最大的负数，值为 -Infinity
	Number.
	Number.NaN: 等于NaN
Number.prototype上面常用的方法有：
	toFixed(2): 保留两位小数
	toExponential(): 转换为科学计数法表示的字符串
	toPrecision(3): 保留三位有效数字，也是科学计数法表示。


70，下面的代码的结果是什么
	Number('3,2');
	parseInt('3,2');
答案：
Number构造器作为函数进行类型的强制转换，对传入的参数要求更为严格，如果传入的字符串不是一个合法的数字，那么会返回NaN，所以Number('3,2')得到的是NaN。而parseInt和parseFloat()对传入的参数，会从头计算一直到不合法的位置，所以parseInt('3,2')和parseFloat('3,2')都会返回3


71，数字基本类型有没有自动装箱
答案：
没有，所以形如2.toPrecision(3)是不合法的，会抛出error。但是可以通过一对圆括号将他们括起来或者是使用Numbe当做转换函数。合理的调用方式是(2).toPrecision()或者是Number(2).toPrecision()


72,js中的Math和JSON是不是构造器
答案：
这两个都是内置的对象，不是构造器。Math对象上常用的方法：
	round ceil floor max min  sqrt(开方)  pow(7,2)表示7的2次方 random生成0~1的随机数  exp  log


73，如何得到一个Date对象的时间戳
答案：
可以使用Number函数进行转换，也可以是使用算数运算符例如 +new Date()。还可以是用Date.prototype.getTime()

74, Date()构造器上有什么方法，Date.prototype上有那些方法
答案：
Date上有的方法一般会使用Date.parse()是传入一个时间格式的字符串会返回对一个的时间戳。Date.UTC()，和parse类似，但是对应的是一个传入年月日时分秒毫秒这样的构造器，返回的同样是时间戳。
Date.prototype上的属性主要有：
	setYear getYear setMonth getMonth setDate getDate getDay setDay(注意getDate是获取日期，但是getDay是获取星期的索引，星期日对应0) getMinutes setMinutes getSeconds setSeconds  getTime()获取时间戳  setTime()设置时间戳  toString转换为国际通用格式  toLocaleString()转换为本地常用时间格式  toDateString()转换为只有年月日的字符串  toLocaleDateString()


75,ES5相比ES3主要的更新有哪些
答案：
ES3之后直接进入ES5，原因是ES4是被废掉的。
①：引入了严格模式： 严格模式是不向后兼容的，可以使用"use strict"语句进行设置。如果浏览器不支持严格模式，这一条语句将被忽略。严格模式下，有些js的功能和结构是不允许的。主要有： 
	使用with语句  
	使用未申明的变量  
	使用arguments.callee或者是arguments.caller
	试图给只读的属性赋值，例如window.Infinity = 0，这个语句在ES3中是可行的。
	试图删除不可配置的属性
	带有重复属性的对象直接量
	形参名称重复的函数。在ES3中 function(a,a,a)是可行的。
②：引入了属性特性： 一个属性有一个value特性和三个布尔类型的特性，它们是：可枚举、可写、可配置（一般可以理解为可删除或者是修改一个属性，由于还有可写属性的控制，所以可配置更多的是考虑可删除）。在ES3中没有属性描述符，所以所创建的所有属性都是可变的。如果是不可配置的，那么一定是不可写的，也就是如果将configurable设置为false，那么writable也必须是false的。enumerable表示法是否可枚举也就是是否可以出现在for in循环中。
③：新的api：
Object()构造器上的新增：
	Object.create(指定的原型对象, 要创建的对象本身的属性构成的对象): 这个函数第二个参数传入的对象中的属性的值可以是属性描述符{value:'xx', enumerable: false, writable: false, configurable: false}。注意如果传入的是一个属性描述符，那么默认的三个特性都是false，也就是{value:'xx'}和后面跟上三个特性值为false的情况是一样的。另一方面，兼容ES3，如果提供的不是一个属性描述符而是一个简单的类型或者其他对象，那么所有的属性描述符上的特性都是true（也就是像ES3中那样默认都是可以枚举可写可配置的）
	Object.getOwnPropertyDescriptor(obj对象，要获取的属性的名称): 通过这个方法，可以获取到一个属性对应的属性描述符对象。如果要进行属性描述符的修改，不可以直接修改这个返回的对象而是应该使用Object.defineProperty()
	Object.defineProperty(obj对象，属性名称, {属性描述符对象}): 使用属性描述符定义一个已创建对象的属性
	Object.defineProperties(obj对象，{属性名1：{属性描述符1}}): 同时定义多个属性
	Object.isExtensible(obj): 判断是否可以扩展，也就是是否可以给对象新增属性
	Object.isSealed(obj): 判断是否封存一个对象，如果是封存的状态，不仅不可扩展，还不可删除属性
	Object.isFrozen(obj): 判断一个对象是否冻结，一个对象冻结了就是在封存的基础上所有的属性不可写了
	Object.preventExtensions(obj): 会将可扩展属性设置为false
	Object.seal(obj): 会将封存属性设置为true
	Object.freeze(obj): 会将冻结属性设置为true
	----note:  关于上面的对象的阻止扩展，封存，冻结的三个函数，一旦对对象使用，之后这个操作是不可逆的。例如一旦冻结了，这个对象就没法解冻，永远都只能是只读不可删除可添加属性的状态了。
	Object.keys(obj): 获取一个对象自身的可枚举的属性的名称数组，不获取继承的属性
	Object.getOwnPropertyNames(obj): 获取一个对象自身的所有的属性名称数组。包括不能枚举的属性
	Object.getPrototypeOf(): 获取一个对象的原型，注意__proto__并不是js标准里面的，ie中就不存在__proto__。但是ES5中将getPrototypeOf作为标准可以获取到只读的原型对象的引用。
Array()构造器上的新增：
	Array.isArray(): 可以用于区分对象和数组。判断创建对象的内部构造器是不是Array
	Array.prototype.indexOf()和Array.prototype.lastIndexOf()：这两个函数是获取某一个值第一次出现和最后一次出现的位置。注意这两个函数的传入参数在内部是进行强类型匹配的。也就是说Array.indexOf(1)和Array.indexOf('1')的结果可能是不同的。这也是php中的array_search()函数不同的地方。
	Array.prototype.foreach(function(){这个函数会传入三个参数，第一个是当前遍历到的元素，第二个是当前遍历的所以，第三个整个数组对象}): 对一个数组中的元素进行遍历操作。
	Array.prototype.filter(function(item){这个函数的参数是每一个遍历到的元素，这个函数如果返回true就是通过了过滤，如果返回了false这个元素就被过滤掉})：对数据进行过滤，返回过滤后的数组。
	Array.prototype.some(function(item){这个函数进行过滤，只要有一个item匹配，这个函数返回true，那么整个some函数就直接返回true}): 判断一个数组中是否存在某种元素
	Array.prototype.every(unction(item){这个函数进行过滤，只要有一个item不匹配，这个函数返回false，那么整个every函数就直接返回false})： 判断一个数组中的元素是否都满足某种要求
	Array.prototype.map(function(item){return 每一个元素处理之后的结果}): 会将每一个元素处理之后的结果组成一个新的数组进行返回。这个函数返回的是处理之后的新数组。
	Array.prototype.reduce(function(第一个参数很特殊除了第一次遍历处理这个参数是输入的后面每一次这个参数会置成前一个reduce的计算的结果, 遍历的元素item, 遍历的index, 遍历的整个数组), 初始传入给回调函数的第一个参数的值): 这个函数会遍历整个数组依次进行处理，每一次处理得到的结果会传入下一次处理，具体的是作为回调的第一个形参传入。
	Array.prototype.reduceRight(): 和reduce类似，只是遍历元素的顺序是从右往左的。
String.prototype上新增：
	trim()函数：类似于php中的trim()。有的环境会提供trimLeft() trimRight()，但是这两个函数不是标准中的 
Date上新增：
	Date.now(): 效果等同于(new Date()).getTime(),是获取当前时间戳
	Date.prototype.toISOString()和Date.prototype.toJSON(): 这两个函数的返回结果一样的，内部处理是一个。首先一个对象的toJSON方法，在JSON.stringify()函数调用的时候如果自定义了toJSON方法，会执行这个方法，使用它的返回值作为得到的JSON字符串。其次toISOString()函数的意义是将时间对象转换为ISO标准的字符串，在内部采用的是toJSON同一个方法。
Function.prototype新增：
	Function.prototype.bind(要绑定的执行对象): 一个方法如果通过闭包传递出去，那么如果直接执行这个函数中的this指代的是全局对象。要想在调用之前修改接下来执行这个函数的this，可以使用这个函数绑定执行对象。注意，bind方法不是在原对象上进行设置的而是返回新对象，原因也很简单，因为，原来的函数对象可能会在其他的地方被调用。
JSON()构造器上新增：
	JSON（javascript object notation）是js对象标记。使用js对象和数组直接量编码任意数据的一种数据交互格式。在ES5中新增了JSON.stringify()和JSON.parse()分别表示将对象转换为 json字符串和将json字符串转换为js对象。


76，ES5下引入了Array.isArray()，如何在代码中进行ES3环境的兼容
分析：
Object.prototype.toString()方法，对于对象会返回"[object 创建这个对象的内部构造器,大部分情况都是直接为Object，有些时候可以是Function、Array等]"。所以可以在ES3环境下自己给Array添加isArray属性
代码：
	if(!Array.isArray){
		Array.isArray = function(obj){
			return "[object Array]" === Object.prototype.toString.call(obj);
		};
	}
	//isArray()相当于php中的is_array()函数，判断一个变量是否是数组
	console.log(Array.isArray({})); //false
	console.log(Array.isArray([])); //true


77，一组姓名序列组成的数组，写一个函数过滤出其中的所有的姓王的人
分析：
	利用Array.prototype.filter()过滤，传入一个回调函数，里面使用正则测试。
代码：
	var names = ['张三','李四','王五','狗剩','王小二'];
	(function(names){
		//输出Array['王五','王小二']
		console.log(names.filter(function(item){
			return item.match(/^王/);
		}));
	})(names);


78，书写代码判断一个数组中元素是否全是数字，进一步判断这些数字中是否存在负数
分析：
ES5中新增的Array.prototype.every可以检查是否所有元素都是数字，而Array.prototye.some()可以判断是否其中存在负数.
代码：
	var arr = [1,2,3,'22',-1];
	//判断是否全是数字，因为这里有'22'，所以结果是false
	console.log(arr.every(function(item){
		return typeof item === 'number';
	}));

	//判断是否存在负数
	console.log(arr.some(function(item){
		return typeof item === 'number' && item < 0;
	}));


79,Array.prototype.map和Array.prototype.reduce的返回结果是什么，它们会不会修改原来的数组.
答案：
map是将没有一个元素进行处理，然后将处理之后的结果添加到一个新的数组进行返回。由于是返回的新数组，所以不会操作原数组的元素。
reduce是依次遍历所有的元素进行处理，但是上一个处理的结果会作为参数传入下一个处理的过程。整个函数最终返回的结果是所有元素处理完成之后的结果。由于不涉及原数组元素的修改，原数组只是输入，所以不会修改原数组元素。
代码：	
	//使用Array.prototype.map
	var arr = [1,2,3,4];
	console.log(arr.map(function(item){
		//返回的是每一个元素处理之后的结果，这个结果会添加到最终的返回结果数组中
		return	'^' + item + '$';
	})); //Array['^1$','^2$','^3$','^4$']
	console.log(arr); //不会修改原数组

	//使用Array.prototype.reduce
	console.log(arr.reduce(function(result,item,index,input){
		//上一次的处理结果会通过result传入
		return result + item + ' ';
	}, 'the content of the input  array is: ')); //the content of the input array is: 1 2 3 4
	console.log(arr); //不会修改原数组


80，如何修改JSON.stringify()函数的执行结果
答案：
JSON.stringify()函数执行的时候，如果对象上自定义了toJSON方法，会执行这个方法，将它的返回值作为最终的JSON字符串。所以可以通过给对象添加这个toJSON方法修改默认的stringify()执行结果。一个例子就是Date.prototype.toJSON()方法，将Date对象转换为比较合适的JSON字符串。
实测代码：
	//自定义toJSON方法
	var o = {
		name : 'o',
		number : 1,
		toJSON : function(){
			return "my name is " + this.name + " and my number is " + this.number;
		}
	};
	console.log(JSON.stringify(o)); //"my name is o and my number is 1"

	//一个例子，Date.prototype.toJSON就是将Date对象格式化为JSON字符串。这个函数一般不会自己调用，而是供给JSON.stringify()函数使用的
	console.log(JSON.stringify(new Date)); //"2017-10-22T14:34:39.351Z"
	console.log(JSON.parse("2017-10-22T14:34:39.351Z"));  //会报错，因为传入的并不是JSON字符串，所以转换不了JSON对象


81,Date.now() === +new Date,这一句代码执行结果是true还是false。
答案：
是true。一开始认为，两次获取时间戳(秒)应该会有不同。但是这两次获取的时间间隔很短(时间片)，所以是一个数值。两条指令的之间间隔是时间片为毫秒级而时间戳的数字单位是秒。


82，简述Function.prototype.bind()方法：
答案：
是ES5新增的方法，可以对一个函数执行之前绑定里面的调用对象。下面是一个例子:
	var obj = {name : 'hello', func : function(){alert(this.name);}}
	var func = obj.func;
	//如果直接调用func，那么其中的this指代的是全局对象，alert的是undefined
	func(); //undefined
	//使用Function.prototype.bind()
	func = func.bind(obj); //bind方法不是在原对象上进行设置的而是返回新对象
	func(); //hello，因为绑定了obj对象，所以结果是返回的obj对象的name


83，简单描述shim技术
答案：
shim技术有时候又叫polyfills技术，是用于在比较旧的环境中通过对内建对象和原型的修改来模拟新的api。例如if(!Date.now){Date.now = function(){return new Date().getTime();};}就可以在旧的环境中模拟ES5中对Date的新增API。但是不是所有的新增的api都是可以使用shim模拟的，例如ES5中新增的严格模式和属性描述符的所有相关处理方法。


84，如何让属性和方法进行私有，如何进行私有属性和方法的暴露。
答案：
构造器中间凡是没有使用this.进行赋值的属性和方法都是私有的。私有的属性和方法的暴露可以参考下面的代码
	var obj = (function(){
		var a = 1; //私有属性1，不是对象（这里的对象包括数组、函数等）
		var b = [1,2]; //私有属性2，是一个对象属性
		//是一个私有方法，也是一个私有的对象属性
		function c(){
			console.log('i am a private method, and i can see the public var d is : ' + public_api.d);
		}
		//共有的属性和方法都放到这个对象中，要暴露的私有属性和方法可以在这里面指定
		var public_api = {
			getA : function(){ return a;}, //私有属性a非对象，所以这里可以选择直接赋值传出
			getB : function(){return JSON.parse(JSON.stringify(b));}, //利用json进行对象的深拷贝传出，保证内部的私有属性不会被修改
			methodC : function(){return c();}, //这里之所以不是直接写成c函数赋值，因为如果直接将c赋给methodC，那么由于是函数也是对象传递，会将一个私有方法完全公开了，外部获取了引用可能会修改这个函数。
			d : "this is a public atrrubute"
		};
		return public_api; 
			

		//note，这里还有另一种方案：“揭示模式”，指的是前面将所有的属性和方法全部私有，然后在这里进行选择暴露，但是这种方式不实用的地方就是在函数定义的地方不能一样看到是否是暴露的(为了解决这个问题可以加上一些注释说明)
		return {
			a : a,
			b : b,
			c : c
		};
	}());


85,js中如何定义常量
答案：
js中并没有现成的定义常量的方式，虽然有的js环境中提供const PI = 3.14之类的写法，但是js中不存在"常量"这样的内容。不过可以通过闭包来模拟php中的define() defined() constant(), 注意php中是不允许常量是对象的，只能是基本类型。
代码：
	//模拟Math JSON这样的内部对象，将所有的常量相关的数据和计算放到一个自定义的Constant对象中
	var Constant = (function(){
		var constants = {}; //存储定义的所有常量
		var allows = {string:1, number:1, boolean:1}; //定义所有可以保存的常量数据的类型，这里只允许字符串数字和bool类型
		return {
			define: function(key,value){
				//定义失败 返回false
				if(this.defined(key) || !allows.hasOwnProperty(typeof value))
					return false;
				constants[key] = value;
				//定义成功 返回true
				return true;
			},
			defined: function(key){
				return undefined !== constants[key]; //已定义返回true
			},
			constant: function(key){
				//如果确实已经定义了就返回定义的常量，否则返回null
				return this.defined(key) ? constants[key] : null;
			}
		};
	}());
	//测试
	console.log(Constant.defined('key')); //false
	console.log(Constant.define('key',{})); //false   不允许值类型为对象
	console.log(Constant.define('key',1)); //true
	console.log(Constant.define('key',2)); //false 重定义
	console.log(Constant.defined('key')); //true
	console.log(Constant.constant('key')); //1


86,在js中没有命名空间和模块的概念。那么在程序中一般是怎么模拟的。
答案：
在js中一般可以将一个应用或者是一个库中定义一个全局变量，然后所做的一切其他的事情都放到这个全局变量下面。一般这个全局变量会是全大写的有显示意义的词，例如APP。这个APP上面本身可以拥有一些方法。另一方面，对于js中没有的模块的概念，可以通过在这个全局对象上添加属性，然后通用的是将这个属性.module指向一个function，这个function就是一个功能模块。这里有一个小点就是，一般为了不会在进行全局对象的属性赋值的时候出现意想不到的覆盖，所以会在APP下面实现给namespace方法，用于进行属性的检测和创建。
具体的实例代码如下：
	//创建一个全局变量，这个全局变量表示一个库或者是一个应用，接下来所有的操作和变量都这个全局变量的内部进行
	var APP = {
		//定义一个namespace方法，目的是为了进行APP属性的检测和创建。这样可避免在已经创建了一个属性的前提下进行意外的覆盖
		namespace : function(ns){
			var parts = ns.split('.'),
				parent = APP,
				i;
			//如果传入的属性名称的最前面是APP.，那么将其从截断的数组中移除
			if(parts[0] === 'APP')
				parts.splice(0, 1);
			for(i = 0; i < parts.length; ++i){
				//一次判断每一级的属性是否存在，如果不存在就进行创建
				if('undefined' === typeof parent[parts[i]])
					parent[parts[i]] = {}; //创建一个直接量赋给这个分支
				parent = parent[parts[i]];
			}
			//最后返回获取经过了或许没有进行内部创建的分支属性
			return parent;
		}
	};
	//创建一个模块， 一般的代码是App.namespace('模块名称').module = 一个立即函数,这个立即函数通过闭包可以实现有些属性的私有
	//这里创建一个常量处理的模块
	APP.namespace('constant').module = (function(){
		var self = APP.constant; //可以保留一个当前分支的对象引用，然后在这个函数内部是用，这样可以不用带上APP...之类的前缀
		var constants = {}; //保存所有定义的常量
		var allows = {string : 1,
			number : 1,
			boolean : 1
		}; //保存允许定义的常量的类型，这里是允许基本类型
		//return的对象中揭示共有的API
		return {
			define : function(key,value){
				//如果已经定义 或者是定义的变量类型是不允许的，就返回false
				if(this.defined(key) || !allows.hasOwnProperty(typeof value))
					return false;
				//定义常量并返回true
				constants[key] = value;
				return true;
			},
			defined : function(key){
				return 'undefined' !== typeof constants[key]; //如果定义了返回true
			},
			constant : function(key){
				return this.defined(key) ? constants[key] : null; //没定义就返回null
			}
		};
	}());
	//调用模块  下面的前缀可以在是使用之前赋值引用var ref = APP.constant.module
	console.log(APP.constant.module.define('test','value')); //true 成功定义
	console.log(APP.constant.module.defined('test')); //true 
	console.log(APP.constant.module.constant('test')); //value 


87，简述CommonJS和AMD
答案：
CommonJS和AMD(Asynchronous Module Definition)都是用于将一个模块包含到另一个模块或者程序中的。他们都不是Ecma International或者w3c指定的标准，属于社区驱动项目，目标是让开发者对于跨环境的js代码的常用做法达成一致。
CommonJS：
	目前没有浏览器在本地实现CommonJS模块，但是在NodeJS等环境有所支持。模块规范其实属于CommonJS中的最流行的一部分。在CommonJS中，一个文件中如果要提供共有api就将这个属性添加到一个exports变量上，这样在其他模块中可以引用这个属性。在NodeJS中是用文件名充当的模块标识符，下面是NodeJS中使用CommonJS的小实例，在其他的文件中利用require引入另一个js文件
		//以下是hi.js中的代码
		var i, j; //文件中直接定义的变量和函数都是私有的
		//添加到exports对象上的属性是暴露的api
		exports.sayHi = function(){ alert('hi, i is : ' + i + ' and j is : " + j);};
		
		//在其他文件中引入hi.js并调用其方法
		var hi = require('./hi.js'); //require函数其实返回的就是exports对象
		hi.sayHi();
AMD:
	AMD是通过return一个对象来指定公有api而不是添加到一个exports对象。AMD最流行的是RequireJS，AMD的辅助函数库会帮助引入额外的模块，并且在模块可用的时候调用回调函数。下面是使用AMD的一个小例子：
		//使用define函数定义一个模块，第一个参数是定义的模块名，第二个参数是这个模块需要的其他模块，第三个是具体的模块内容
		define('hi',['hello，需要另一个模块的名称'], function(){
			var i,j; //私有
			return {
				say : function{} //暴露的公有api
			};
		});
		//使用require函数在程序中引用这个hi模块。第一个参数是引入的模块名，第二个参数是回调函数，当引入模块成功的时候(例如新的文件传入成功)会调用
		require('[hi]',function(){
			hi.say();
		});


88,介绍几个实用的文档与测试工具
答案：
MDN： 是ff在线学习资源。
MSDN： 关于ie的学习地方
JSDoc Toolkit 和 YUIDoc：可以通过注释生成文档，为了更好的说明代码的用途，文档系统一般提供一些新标签例如 @inherits @class @constructor等
Jasmine 和 Selenium: 是两种辅助进行单元测试的项目
JSCoverage： 在运行单元测试之前可以使用它获取测试的代码覆盖。
JSLint: 在很多ide中有内嵌，也可以作为编辑器插件使用。可以帮助检查js的语法错误。还要一个类似的工具JSHint(相比较JSLint，它更宽松一些，更容易接受一些).