<?php
/*
题目描述：
	能否使用use访问全局变量，为何。use进行引用传递和值传递的差异。
分析：
	use表示引入父级函数范围内的变量，所以如果是全局的函数可以使用use访问全局变量，而如果不是全局函数使用use不能成功访问到全局的变量，这个时候应该使用global。php中闭包中默认是不能访问外部的变量的，如果要访问全局变量可以使用global引入，如果是要访问父级函数中的变量，可以使用use引入。use如果没有指定为use(&$a)这样的引用引入，一般是进行值的传递，也就是在内部函数定义的时候会在闭包类中保存外部函数中use指定变量的副本(具体存放一个public $static属性，这个属性是一个是一个数组，数组中的每一项对应个一个use引用，如果一个use指定的变量在外部没有定义，那么保存的为null)。形如use($a,&$b)，其中$b便进行了引用的传递，这个和函数的引用传参是类似的，如果是引用传递，那么效果和js中的引用传递是一样的，也即是函数调用之前被引用到的外部的函数中的变量的更改可能会影响到最终的执行结果。
补充分析：
	php中只有函数表达式才能构成闭包，而对于一般的函数申明，只能构成一般函数，use关键字只能使用在闭包函数上面，否则会编译错误（表示未预料到的use）。这一点和js中不同，js中所有的函数都是闭包函数。
*/
$i = 1;
//闭包，引入了全局的i
$f1 = function() use($i){
	
};
var_dump($f1); 
//闭包，没有进行任何的引入
$f2 = function(){
	global $i;
};
var_dump($f2);
//普通函数申明
function f3(){
	
}
var_dump($f3); //NULL，因为没有这个变量(notice：undefined f3)

/*
//编译错误，因为php中只有函数表达式才能构成闭包，而只有闭包中函数上才能使用use。对于这种函数申明的形式定义的函数只能构成普通的函数，不能构成闭包函数s
function f4() use($i){
	
}
*/

/*多重闭包加引用传递测试*/
$out1 = function(){
	$a = 2;	
	$b = 3;
	$out2 = function() use($b){
		$inner = function() use(&$a,&$b){
			var_dump($a); //NULL，因为use只能在父级函数的内部进行查找，不会主动的查找到祖父级
			var_dump($b); //int(3)
			$a = 100;
			return $a;
		};
		return $inner;
	};
	return $out2;
};
$res = $out1();
$res = $res();
var_dump($res());