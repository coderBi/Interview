1，extern的作用
答案：
extern的作用有两个：
①：用于变量或者函数前，用以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他的模块中寻找定义。extern int g_Int只是一个申明，这样在编译阶段不会报错，编译器会在链接阶段寻找其定义。
②：extern "C" void fun(int a,int b);用来告诉编译器在编译这个函数的时候按照C规定的规则去翻译相应的函数名而不是C++的。C++中由于存在函数的重载，所以会有不同。

2，strstr函数
答案：
strstr(const char* s1, const char* s2)是查找s1中是否存在子字符串s2，如果存在就返回第一次出现的位置（地址），否则返回NULL。

3，windows下线程的优先级问题
参考：
每一个线程都有一个“优先级”，范围是0~31,0最低，31最高。当系统决定哪个线程需要调度的时候，首先查看是否存在优先级为31的可调度线程，如果存在，就从中选择一个进行调度。当该线程的时间片达到之后，系统查看是否有另一个优先级为31的可调度线程，如果存在就调度它。只要有一个优先级为31的，那么系统不会调度0~30的线程。
高优先级的线程会打断低优先级的线程，即使低优先级的线程的时间片只用了一半。
当系统引导的时候，系统创建了一个特殊的线程，成为“zero page”（0页）线程。它是整个系统中唯一的一个优先级为0的线程，当系统没有任何其他线程需要执行的时候，该线程负责将系统中所有的RAM页面清零（也就是资源回收）
对于进程而言，windows有一个“优先级类”的概念。这些优先级类作用于进程的所有线程。windows 2000/xp/2003/vista支持六个优先级类：
①：Real-time
②：High
③：Above normal
④：Normal
⑤：Below normal
⑥：Idle
一个进程应该避免使用“实时”优先级类，因为使用该优先级类会导致其他进程中的线程很难被调度，甚至会打断或者抢断系统线程的执行。高优先级类也尽量避免使用，除非有特殊的工作需要使用这个优先级类。
当一个进程的“优先级类”被确定以后，接下来就考虑这个进程中各个线程之间的优先级关系，对于进程中的线程而言，有一个“相对线程优先级”的概念，可以确定一个进程中的多个线程间的优先级关系。Windows支持7中“相对线程优先级”：
①：Time-critical: 关键时间（最高的相对线程优先级）
②：Heightest: 最高
③：Above Normal
④：Normal
⑤：Below Normal
⑥：Lowest：最低
⑦：Idle：空闲
程序中使用“优先级类”和“相对线程优先级”，windows负责映射到具体的0~31的优先级上，对于不同的版本的windows，这种映射关系可能不同。


4，交换x与y的值
答案：
最常用的写法：c = a; a = b; b = c;
利用加法不使用第三个变量：a += b; b = a -b; a = a-b;这种写法有一个问题就是可能出现加法溢出。
利用异或不使用第三个变量（一般最优写法）： a ^= b; b ^= a; a ^= b; 这种写法没有溢出问题。


5，指针的自加与引用
答案：
指针的自加，得到的新地址取决于指针的类型，例如 int *p; 那么p++实际上是让p的地址增加四个字节，而 int *p[10]由于p是指向一个10个元素的int数组，那么每次p的自增会导致p向前移动sizeof(int) * 10。
指针的引用写法是 int * &p; 使用指针的引用是为了方便修改指针的值。


6，前置++与后置++
答案：
前置++表达式的值是++之后的值，而后置++表达式的值是++之前的原来的变量值。


7，inline的作用
答案：
引入内联函数是为了解决函数调用中断影响程序执行效率的问题。inline函数在编译的时候，编译器会将调用的表达式用函数体进行替换，这样做会增加目标程序的代码量，也就是用目标代码的增加来换取程序执行时间的节省。内联函数是编译阶段进行替换，而不是像一般函数那样在运行时被调用。
inline函数的定义如下:
inline int add(int x, int y, int z){
	return x+y+z;
}
内联函数一般不能含有复杂的逻辑，例如内联函数里面不能存在循环语句和switch语句(可以有简单的if)。
在类结构中直接定义的函数默认是内联的。


8，ifndef的作用
答案：
ifndef是if not defined的缩写，是预处理功能（包括文件包括、宏定义、条件编译）中的条件编译，可以根据是否定义一个变量来进行分支选择。
#ifndef主要的目的是防止文件的重复包含和编译。有时候也用于调试开关等。

9，kmp算法
答案：
KMP算法在一个字符串中快速查找子字符串的线性复杂度算法。其核心是利用一个next数组，在每一次出现不匹配的时候，并不会像传统的O(n*n)的算法那样，在要查找的字符串中接着从头开始匹配待查找的子字符串，而是通过查询next数组，在保持父字符串遍历指针不回溯的情况下，从待查找的子字符串的某一个位置进行新的查找。由于要查询的父字符串的索引一直没有回溯，最终将复杂度压缩到了O(n)。算法最关键的地方是构建next数组，next数组理论上的构成是next[i]表示待查找的子字符串的i脚标的字符串不匹配的时候，下一次从next[i]重新进行匹配，为了找到这个next[i]做法是查找之前已经比配的子字符串的部分，比较它的前缀跟后缀的最长重合部分，这个就是next[i]。但是鉴于复杂度的考虑，一般不会重复比对一个子串的前缀与后缀，而是通过前一个next[i-1]的关系进行线性构造next[i]，这个构造基于一下事实：如果要查找的子字符串s，其s[i] = s[next[i-1]]那么可以得出 next[i] = next[i-1] + 1。如果s[i] != s[next[i-1]] 那么假设k = next[i-1]，进一步比较s[i] 与 s[next[k]]，上面出现了一个递归描述，只要控制要base，也就是next[0] = -1和next[1] = 0就可以实现线性构造next数组。


10，函数调用方式
答案：
C++中函数调用的方式有stdcall、cdecl、fastcall、thiscall、naked call
首先，调用函数时，计算机常用栈来存储传递给函数的参数。函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得数据，并进行计算。函数计算结束以后，或调用者或函数本身修改栈，使其恢复原状。C++中的各种调用方式的区别就在于当参数多于一个时按照什么顺序将参数压栈和函数调用之后由谁将栈恢复原状。
1)__stdcall
stdcall调用方式又被称为Pascal调用方式。在Microsoft C++系列的C/C++编译器中，使用	PASCAL宏、WINAPI宏和CALLBACK宏来指定函数的调用方式为stdcall。
形式： int __stdcall function(int a, int b)
C语言中__stdcall的特点：
	---参数从右向左一次压栈
	---由被调用函数自己来恢复栈
	--- 函数名自动加前导下划线，后面紧跟着一个@，其后紧跟着参数的尺寸(所有参数所占的字节数) 例如上面的 function(int a, int b)会被翻译为 _function@8。注意这个函数名称可以用汇编直接调用。
C++编译时__stdcall特点：
	---以“？”标识函数名的开始，后面跟上函数名
	---函数名后面以"@@YG"标识参数列表的开始，后面跟上参数列表。
	---参数列表以代号标识： 
		X-void D-char 
		E-unsigned char
		F-short H-int I-unsigned int
		J-long K-unsigned long
		M-float N-double _N-bool
		PA-表示指针，后面的代号表名指针的类型，如果相同类型的指针重复连续出现，就用一个"0"代替，一个"0"代表重复一次。
	---参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型，指针类型为PA加上所指数据类型
	---参数列表后以"@Z"标识整个名称的结束，如果该函数无参数，那么以"Z"的标识结束(此时参数类型为X，实际会以XZ结束)。例如void __stdcall function(int a, int b)编译之后的名称是?function@@YGXHH@Z 而void __stdcall function()编译之后的名称是 ?function@@YGXXZ
----扩展： pascal语言是一种老的教学语言，采用的是__stdcall但是它的入栈顺序是从左到右。C++标准调用方式是__stdcall的，window api系统调用都是__stdcall的，但是C++中是从右到左的入栈顺序。（VC中的默认调用方式还是cdel的，所以会看到很多函数前面加上了WINAPI字样）
2）__cdecl
cdecl调用方式又称为C调用方式，是C Declaration的缩写。是C语言的缺省调用方式（也就是没有__stdcall之类的形式符，C程序默认就是cdecl的）。
形式：
	int function(int a, int b)  //缺省默认
	int __cdecl function(int a, int b) //指明调用方式
C语言编译时__cdecl特性：
	参数从右向左依次压栈
	由调用者恢复栈，由于是由调用者来恢复栈，所以C调用方式允许函数的参数个数是不固定的。例如调用 void function(int a, int b)的过程是：push b, push a, call function 然后add esp,8 最后这个add esp，8就是清理栈。
	函数名自动加前导下划线，例如void function(int a)就被翻译为 _function。可以看到被调用者不会要求调用者传递多少参数，调用者传递过多或者过少都不会产生编译阶段的错误。
C++编译时__cdecl特性：
	函数命名的时候和__stdcall基本一样，只是一点就是原来的参数列表是@@YG开头 而__cdecl调用的参数列表开头是@@YA
3）fastcall
fastcall是一种快速调用方式，前两个参数用exc和edx进行传递，后面的参数向__stdcall那样传递,从右向左进行入栈，函数编译之后的名称规则和__stdcall一样，调用完成之后被调用者清理栈，函数编译之后的名称和__stdcall基本一样，只是函数列表的开始是@@YI。
形式：
	int fastcall function(int a, int b)
4）thiscall
thiscall调用方式是唯一一种不能显示指定的修饰符。它是C++成员函数的缺省调用方式。由于成员函数的调用还有一个this指针，因此必须使用这种特殊的调用方式。
thiscall特性：
	参数从右向左入栈
	如果参数个数确定，this指针通过ecx传递给调用者，如果参数个数不确定，this指针在所有的参数都入栈之后被压栈。
	参数个数不确定时，由调用者清理栈，参数个数确定时，由函数清理栈。
5）naked call
一种很少见的调用方式，一般高级程序设计语言不常见。
函数的申明调用方式和实际调用方式必须一致，否则必然产生编译器的混乱。


11，重载函数
答案：
重载函数是函数的一种特殊情况，指的是几个功能相近的同名函数，但是这些函数的形式参数（参数的个数、类型、顺序）必须不同，也就是同一个函数名完成不同的运算，这就是重载函数。重载函数常常用来实现功能类似而实际处理数据类型不同的问题。两个重载函数之间必然存在参数的个数或者参数的类型的不完全相同。
定义：
	同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。
为何要有重载函数：
	对于同一个功能，数据类型的不同的函数取一个名称增加程序的可读性，方便使用。
	类的构造函数跟类名相同，如果没有重载机制，那么要实例化不同的对象，就不方便。
	操作符重载，本质上是函数重载，它大大丰富了已有操作符的含义，方便使用，例如+可以连接字符串等。指的注意的重载不能改变操作符的优先级。
重载函数的调用匹配：
为了确定哪个重载函数最合适，需要依次按照下列的判断规则
	1）精确匹配：参数匹配而不用做任何的转换（或者是微不足道的转换，例如数组名到指针）
	2）提升匹配：即整数提升（如bool到int char到int  short到int  float到double等）
	3) 使用标准转换匹配：如int到double、double到int、double到long double、Derived*到Base*、T*到void*、int到unsigned int
	4）使用用户自定义匹配。
	5）使用省略号匹配：void function(int x,...)


12，合并两个有序链表
答案：
可以写出 O(M+N)的算法，方法是设置两个指针分别定位在两个链表的头部，进行两个链表的遍历。如果存在某一个链表中的数据数据小于另一个链表就将这个链表的节点追加到新的链表中同时向后移动这个链表的指针，如果两个链表中的数值相同，就将其中的一个节点追加到新的链表中，同时将两个链表的指针都向后移动一位。如果其中一个链表已经遍历完成，那么将另一个链表中剩下的数据完全拷贝到新的链表中。至此，所有的合并操作完成。

13，从100亿条数据中找出重复最多的前10条
答案：
由于数据量比较大，所以不能一次性加入内存，首先可以利用散列，将100亿条记录分割成一批数量较小(例如，模上10001，每一个相同模结果的记录放到同一个文件中)的数据，这种分割算法，保证只要两个记录是相同的就一定会被映射到同一个文件中。然后对每一个记录文件，构建一个AVL，每一个节点保留一个属性用来记录出现的次数，如果插入相同的记录，就将记录数加1。最后遍历AVL树，取出所有的节点，然后按照记录出现的次数构建最大堆，使用 O(10*log(n))的时间复杂度找出每一个文件中的出现次数前10的记录。将这10001个文件中所有的前十综合起来也就是 10001 * 10条记录放到一起，构造优先队列，使用最大堆取出出现次数最多的前10.（凡是海量数据处理，一定涉及到hash，这也是mapreduce的原理）


14，设计一个双向链表，并且提供可以根据值删除元素的函数。
答案：
跟单向链表相比，删除的时候最主要的不同是要修改指向前面的指针，在删除头的时候要修改头而在删除尾的时候还得修改尾部。核心的代码大致如下：
	typedef int ElementType; /*利用抽象的数据结构，方便一会可能进行的修改和复用*/

	struct Node
	{
		ElementType val;
		Node * previous;
		Node * next;
	};

	struct DoubleLinkedList
	{
		Node * head;
		Node * tail;
	};

	/*
		按照值删除元素
	@param DoubleLinkedList* L 要操作的链表
	@param ElementType val 要删除的值
	@version 1.0 功能性实现
	@version 2.0 细节优化：由于是双向链表，所以不用向单链表那样，删除之前还需要保存上一个节点。这里去除掉循环里面的previous保存
	*/
	void DeleteByVal(DoubleLinkedList * L, ElementType val){
		if(!L)
			return;
		Node *p = L->head, *previous = NULL, *next = NULL;
		for(;p && val != p->val; p = p->next){
			//version 2.0 双向链表不用保存了
			//previous = p; //保存要删除节点的前一个节点
		}
		if(p){
			//找到了值，进行删除
			next = p->next;
			previous = p->previous;  //version 2.0
			if(previous)
				previous->next = next;
			else
				L->head = next; //删除的是头节点，需要修改头结点指针
			if(next)
				next->previous = previous;
			else
				L->tail = previous; //删除的是尾节点，需要修改尾部指针
			//删除p
			delete p;
		}
	}

15，二叉树多种遍历的实现
答案：
对于二叉树的遍历，一般又可以分为先序、中序和后序。其中先序遍历类似与DFS，而后序遍历可以用来计算一个目录的大小(目录中所有的子目录和文件的大小相加然后加上目录本身的文件大小（目录本身也是文件，在有的系统中也是算独立大小的）)，中序遍历一般用于一些数学表达式之类的遍历。各种遍历的大致代码如下：
	typedef int ElementType;

	struct Node
	{
		ElementType val;
		Node * left;
		Node * right;
	};

	typedef Node* BinaryTree;

	/*
		C++11增加了一批的to_string()函数，这里由于MingW版本低，所以自己利用流实现以个to_string
	*/
	std::string to_string(int n){
		ostringstream stream;
		stream << n;
		return stream.str();
	}

	/*
		二叉树的先序遍历,递归实现
	@param BinaryTree T 要遍历的二叉树
	@return std::string 遍历之后得到的结果字符串
	*/
	std::string PreOrder(BinaryTree T){
		std::string toReturn  = "";
		if(!T)
			return toReturn; //空树
		//获取树根的值
		std::string root = to_string(T->val);
		//遍历左子树
		std::string left = PreOrder(T->left);
		//遍历右子树
		std::string right = PreOrder(T->right);
		//添加根节点的值
		toReturn += root;
		//添加左右子树到返回结果
		if(left.length())
			toReturn += string(" ") + left;
		if(right.length())
			toReturn += string(" ") + right;
		return toReturn;
	}


	/*
		二叉树的中序遍历,递归实现
	@param BinaryTree T 要遍历的二叉树
	@return const std::string & 遍历之后得到的结果字符串
	*/
	std::string InOrder(BinaryTree T){
		std::string toReturn = "";
		if(!T)
			return toReturn; //空树
		//遍历左子树
		std::string left = InOrder(T->left);
		//获取树根的值
		std::string root = to_string(T->val);
		//遍历右子树
		std::string right = InOrder(T->right);
		//添加左子树到返回结果
		toReturn = left;
		//添加根节点的值到返回结果
		if(toReturn.length())
			toReturn += " " + root;
		else
			toReturn += root;
		//添加右子树到返回结果
		if(right.length())
			toReturn += " " + right;
		return toReturn;
	}


	/*
		二叉树的后序遍历,递归实现
	@param BinaryTree T 要遍历的二叉树
	@return const std::string & 遍历之后得到的结果字符串
	*/
	std::string PostOrder(BinaryTree T){
		std::string toReturn = "";
		if(!T)
			return toReturn; //空树
		//获取树根的值
		std::string root = to_string(T->val);
		//遍历左子树
		std::string left = PostOrder(T->left);
		//遍历右子树
		std::string right = PostOrder(T->right);
		//添加左右子树到返回结果
		if(left.length()){
			if(toReturn.length())
				toReturn += " " + left;
			else
				toReturn += left;
		}
		if(right.length()){
			if(toReturn.length())
				toReturn += " " + right;
			else
				toReturn += right;
		}
		//添加树根
		if(toReturn.length())
				toReturn += " " + root;
			else
				toReturn += root;
		return toReturn;
	}


16，有读和写的两个线程和一个队列，读线程从队列中读数据，写线程往队列中写数据。
答案：
可以多个同时读，但是读的时候不能写，写的时候不能读。

17，stack  heap  memory-pool


18，TCP流量控制和拥塞控制机制



19，写一个函数，返回一个字符串中只出现一次的第一个字符串。


20，求数组中第k大的数的位置


21，面向对象多态的实现机制。


22，内联函数什么时候不展开

23，成员初始化列表有什么用，什么时候必须使用成员初始化列表进行初始化


24，指针和引用的区别


25，创建空类，默认有哪些函数


26，有10万个ip段，这些ip之间不重合，随便给出一个ip，求属于哪一个ip段。


27，网络编程范式，非阻塞connect


28，linux中互斥的方法，多线程编程，进程间通信


29，一个数一维数轴上有不同的线段，求重复最长的两个线段


30，有向带权图的最短路径


31，内存溢出与内存泄露的区别


32，利用互斥量和条件变量设计一个消息队列，具有一下功能：①创建消息队列（消息中所含的元素） ②消息队列中插入消息 ③取出一条消息（阻塞方式）  ④取出第一消息（非阻塞方式）。 注意：互斥量、条件变量和队列由系统给出。


33，非递归实现二叉树遍历

34，设计一个内存管理策略，要求可以保证多线程时安全、防止内容越界等，效率不能低于malloc/free


35，有一个虚拟存储系统，若进程在内存中占3页（开始时内存为空），采用先进先出(FIFO)页面淘汰算法，当执行 1,2,3,4,5,1,2,5,1,2,3,4,5访问序列后，会发生多少缺页。


36，某页式存储管理系统中，地址寄存器长度24，其中号位14，则主存的分块大小是多少字节


37，重载运算符


38，struct和class的区别与联系

39，函数指针与指针函数
答案:
指针函数指的是返回值类型是指针类型的的函数。函数指针是指向一个函数类型的指针。


40，大端小端


41，如何判断单链表是否有环


42，一个进程中多线程可以共享栈吗
答案：
不可以。线程是调度单位，进程是内存管理单位。每一个线程有自己独立的栈，并且不能共享。但是对于堆，所有线程是共享的。


43，同一个进程，多个线程可以共享register set(寄存器组)吗
答案：
由于线程是一个独立的调度单位，所以不能共享寄存器组。但是多个线程可以共享data section(数据段)和 file fd(文件描述符)


44，如何区分ABCDE类ip
答案：
首先每一个ip由4个字节组成，这里仅讨论ip4情况。
A类：
A类ip中第一个字节指明网络，后三个字节指明网络上的主机。
第一个字节是 0~127。也就是说第一个字节的高位必须是0. 但是0和127这种全0和全1的被保留。但是由于第一个字节的全0和127开头的被用作特殊用途，所以实际可以分配的1~126（1.0.0.1~126.255.255.254）。127.0.0.1是回环测试用的固定ip。A类中的10.0.0.0到10.255.255.255是私有地址。每一个A类网络可以提供主机地址个数是2^24-2(其中主机地址全0用于标识网络，全1用于广播网络)。A类占ip总数的50%，默认的A类地址子网掩码是255.0.0.0
B类：
B类地址前两个字节是网络地址，后两个字节是主机地址。B类的第一个字节的前两位必须是10，所以B类的网段个数是 2^14。每一个B类网络可以提供的主机地址个数是2^16-2.
B类的范围是128.0.0.0~191.255.255.254。其中172.16.0.0~172.31.255.255是私有地址。169.254.0.0~169.254.255.255是保留地址，如果ip设置自动获取，而网络上没有找到dhcp服务器就从169.254.0.0~169.254.255.255中临时获取一个ip。默认子网掩码255.255.0.0
C类：
前三个字节是网路地址，后一个字节是主机地址。最高位必须是110。C类的网段个数是2^13。每一个C类网路可以提供2^8-2个主机地址。C类表示的范围是192.0.0.0~223.255.255.255。C类地址分配给小型网路，一般的局域网和校园网，它可连接的主机数量是最少的，采用把所属的用户分为若干的网段进行管理。其中192.168.0.0~192.168.255.255是私有地址。
D类：
D类地址，第一个字节以1110开头，它是一个专门保留的地址。D类并不指向特定的网络，目前多被用在多点广播中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。地址范围是224.0.0.0~239.255.255.255。
E类：
以1111开头，也是保留地址。第一个字节的范围是240~255,主要用于Internet实验和开发。


45，什么是私有网路地址
答案：
私有网路地址就是在互联网上不适用，而被用在局域网中的地址。A类是10.0.0.0~10.255.255.255  B类是172.16.0.0~172.31.255.255 C类是192.168.0.0~192.168.255.255


46，虚函数可以是static的吗，为什么
答案：
不可以。
虚函数是一种特殊的成员函数，用来实现运行时的多态。static函数中没有this指针而virtual方法内部隐藏了this指针。static函数是在编译时绑定的，而virtual函数是在运行是绑定的。


47，指针与引用的区别
答案：
指针是一个变量，指向内存储的一个存储单元，而引用跟原来的变量其实是同一个东西，只不过是原来的变量的一个别名。
具体的区别包括： 
①，指针可以是多级，但是引用只能是一级，不存在 int &&a; 
②，指针可以是空，但是引用不能为NULL，并且指针在定义的时候必须初始化。
③，指针的值在初始化之后可以进行修改，但是引用初始化之后不能改变。
④，sizeof引用得到的是所指向变量的大小，而sizeof指针得到的是指针的大小。
⑤，对指针和引用进行自加的操作意义是不一样的，引用是对原来的变量进行自加，但是指针是在当前保存的地址上加上sizeof原来的变量类型。

48，下列定义数组的方式在C++中是合法的有那些：
	1）deifine N 100
	int x[N];  //这个合法，是正确的，进行宏替换，编译器可以识别到正确的数组长度
	2) const int N = 10;
	int x[N];  //C++中可以使用const变量进行数组长度的定义。但是在C语言中这样书写是不正确的，二者的const关键字有所区别.
	3）int length = 10;
	int x[lenght]; //这种写法不对，尽管在gcc中，编译器进行了优化，可以通过编译。


49, 考虑这么一个问题，一个数组int arr[] = {2,3,4,5}，定义一种运算，f[i]为数组上除了arr[i]其他所有的其他数据元素的乘积。要求复杂度尽可能的低
答案：
1）显而易见的思路：分别计算每一个f[i] = arr[0] * .... * arr[i-1] * arr[i+1] * .... * arrp[n-1]。这个实现算法的时间复杂度是 O(n*n)。空间复杂度可以达到O(0),因为直接将要计算的结果保存在要返回的数组中。
2）稍微有点经验的判断，就会发现上面的乘法进行了重复的计算，而且这个重复的量是很大的。一个利用空间换取时间的策略是：用O(n)从左到右扫描数组将前0~i-1项的乘积的结果保存为一个数组left[i]，同样用O(n)从右往左进行扫描，可以构建一个后i+1~n-1的乘积的结果数组right[i](两个结果数组中的边界情况的乘积设置为1)。最后利用这两个中间存储的状态数组计算result[i] = left[i] * right[i]。整个算法的复杂度大致为O(3n)，空间复杂度是两个中间状态的保存数组为O(2n)
3）对于上面第二种算法，可进一步的优化其空间复杂度，利用经验可以知道这样的相邻的状态的值可简单递推的一般都存在空间复杂度的可能优化。可以这样考虑，先将left数组的值直接保存到result数组中，然后用一个中间变量存储i+1~n-1之间的元素的乘积，每一次向这个中间值上追加上新的因子的同时也就可以将这个乘积直接乘到原来的对应的result[i]上。这个改良后的算法时间复杂度依然是O(3n)(指的注意的是从右往左进行遍历的时候出列计算右边的乘积，还将左右两部分的乘积相乘计算出result[i]这一动作至于其中),这个算法的空间复杂度为O(1)，只用到了一个中间变量.
对于算法3）这种最有的代码大致如下：
	int * cal(int * input,int n){
		int * result = new int[n];
		if(!result){
			std::cout << "new memory fail" << std::endl;
			return nullptr;
		}
		int right = 1;
		//计算左边的0~i-1的乘积
		result[0] = 1;
		for(int i = 1; i < n-1; ++i){
			result[i] = result[i-1] * input[i-1];
		}
		//从右往左进行遍历 计算right 计算result
		for(int i = n - 2; i >= 0; --i){
			right *= input[i+1];
			result[i] *= right;
		}
		return result;
	}


50，在n个整数的序列中，要计算出最大值和最小值，至少需要多少次比较：A.2n-2 B.3n/2 C.n-1 D.4n/3
答案与分析：
结果是 B.3n/2
1）按照一般性写法，用两个变量分别保存最大和最小值，初始的时候将这两个值都设置为arr[0]，然后遍历这个数组，通过对每一个元素与最大最小值的比较和互换最终确定这个序列的最大和最小值。这个比较的次数是 2(n-1)
2）因为要计算的是最大和最小值，可以先进行没两个两个的比较，将这个比较中间较大的放到一个数组，将较小的放到一个数组。然后利用上面1）的描述分别在两个子序列中找出最大和最小值（这个算法如果要追求不用空间上的优化，可以直接将奇数位设置为较小，偶数位设置为较大，不过这样导致了输入数组的更改）。这个算法的复杂度是 n/2 + (n/2 - 1) + (n/2 - 1)近似为3n/2
----下界分析：能够优化上面思路1）的部分，应该是在尽可能的不让每一个数据都和最大最小值进行比较，而如果对于任意一个数只要知道它不能是最大值就不用和最大值比较，同样的分析适用于最小值。那么这个优化方案也就是在内部两两配对进行分组。这样与最大值最小值的比较次数缩减了一半，从2n-2次缩减为n-1次（这个分析并不是最糟糕的情况，糟糕的情况下，内部比较的两个值是一样的，那么这个数据要同时进入两个组），但是内部产生了n/2次比较。所以要同时计算出最大最小值需要的比较次数应该不少于3n/2。
利用额外的数组空间进行算法2）的实现代码大致如下：
	void cal2(int input[], int length, int &max, int &min){
		if(!input || length <= 0){
			std::cerr << "the input array is null or empty" << std::endl;
			return;
		}
		int * low = new int[length];
		if(!low){
			std::cerr << "new memory fail" << std::endl;
			return;
		}
		int * high = new int[length];
		if(!high){
			std::cerr << "new memory fail" << std::endl;
			delete [] low;
			return;
		}
		//对输入的input进行分组
		int lowLen = 0, highLen = 0;
		//如果是奇数，那么将最后一个元素先加入到两个数组中
		if(length / 2)
			low[lowLen++] = high[highLen++] = input[length -1];
		for(int i = 0; i < length - 1; i += 2){
			if(input[i] <= input[i+1]){
				//一个小细节，如果相邻的这两项相等，那么两个相同的项进入到两个数组，这种处理没有向任何一遍倾斜，不会造成一头大一头小的两个数组.
				low[lowLen++] = input[i];
				high[highLen++] = input[i+1];
			}else{
				low[lowLen++] = input[i+1];
				high[highLen++] = input[i];			
			}
		}
		//在high中寻找最大值  在low中寻找最小值  由于lowLen和highLen其实是一样的，所以下面的代码（其实上面的分组代码中的变量二者也可使用一个）中两个for是可合并的，这里暂不给出合并的代码
		max = high[0];
		min = low[0];
		for(int i = 1; i < lowLen; ++i){
			if(min > low[i])
				min = low[i];
		}
		for(int i = 1; i < highLen; ++i){
			if(max < high[i])
				max = high[i];
		}
		//资源释放
		delete [] low;
		delete [] high;
	}


51，在32位系统和64位系统中 int * p; sizeof(p)的结果分别是多少
答案：
一个指针对应存储的是地址，至于占用多少个字节，一般所用的地址总线的条数有关。32位和64位说的便是地址总线的条数，这个也就是一个地址的位数。所以在32为系统上一个指针占用32位，也就是4个字节，在64位系统上一个指针占用64位也就是8个字节。上面的结果分别是4和8


52，在一个数组中，存在一个元素出现的次数超过了数组长度的1/2，找出这个元素。
--问题延伸： 如果是在一个数组中，已知一个元素出现的次数超过了1/3，又如何找出这个元素
答案与分析：
一个一般性的想法：将数组进行排序，那么arr[n/2]就是目标元素，原因很简单这个元素个数超过数组长度一半的元素无论是从数组左边开始都是较小值还是从数组最后面往前排都是较大值，由于其个数超过了总长度的一般，所以中间位置一定是这个元素。如果用快排之类的排序这个直观算法的复杂度是O(nlog(n))
如果一个元素已知出现的次数超过了1/2，那么也就是这个元素的个数超过了其他所有元素的总和。假设使用一个计数，初始为0，这个计数在出现的元素的要找的出现次数超过1/2的元素的时候就进行计数加一，在出现的元素不是要找的出现次数超过1/2的元素的时候就进行减一，那么遍历这个数组之后的结果这个计数一定是大于0的。因为只是进行了一次遍历，这个算法的复杂度是O(n)
上面的思路，仅仅是根据条件是如果已知有这么一个元素的个数超过了1/2，是通过这个已经的性质进行求解输出的。但是如果前提并不知道是否存在次数超过1/2的元素的时候，这个求解就可能是失效的。也即是这种思路只能在确定存在这个元素的前提下找到它而没有办法证明超过1/2的元素一定存在。给定一个简单的例子，一个数组中每个元素都不一样，并且数组长度为奇数(>=3)，通过上面的思想会找到最后一个元素，然后这种情况下是不存在某一个元素的个数超过总的元素个数的一半的。对于可能并不存在次数超过1/2的情况，可以再次遍历一次这个数组进行出现次数的验证。通过反证法可以很容易的得到如果确实存在次数超过了数组长度的一半的元素那么最后的标记元素一定是这个目标元素，那么上面的一次遍历验证也就是有效的。
上述的代码逻辑大致如下：


53, -1 >> 1这个表达式的值是多少，为什么
答案：
移位操作，是进行二进制的内存结构进行左移一个比特位或者右移一个比特位。如果是左移那么低位会补充0，如果右移，那么高位会补充符号位。这里的-1高位的符号位是1，由于原来的内存二进制表示形式为 1...1..1如果进行右移一位并且在高位进行补1，那么结果还是1...1...1(全1)，结果还是-1

54，如果表示最大的整型数字
答案：
如果是进行10进制表示，由于数字规律性不强，不容易记忆。可以进行16进制的表示： 0x7fffffff 或者使用 -1 - 0x80000000


55，找出一个数组中所有满足下面条件的元素：这个元素的所有的左边的元素小于等于它，右边的所有的元素都大于等于它。
答案：
1）一个显而易见的常规分析是：对于每一个元素，遍历它的前后所有元素进行判断。这个算法的复杂度是O(n*n)
2）上面的O(n*n)算法，很明显做了很多次的重复比较，存在优化的空间。假设我们构建两个数组leftMax和rightMin分别表示一个元素左边包括其自身的最大值和一个元素右边包括其自身的最小值，那么只要对应的leftMax[i] <= rightMin[i]，这个i就是符合要求的。实际考虑到内存的开销，可以只使用一个数组leftMax或者是rightMin，记录下来单边的的最值情况，然后从另一边进行遍历，在遍历计算另一边的最值的时候同时判断i是不是符合要求。
只是用rightMin数组的代码大致如下：
	std::vector<int> cal2(int input[], int length){
		std::vector<int> result;
		if(!input || length <= 0){
			std::cerr << "the input array is null or its length is no more than 0" << std::endl;
			return result;
		}
		int *rightMin = new int[length];
		if(!rightMin){
			std::cerr << "new memory fail" << std::endl;
			return result;
		}
		//构建righMin数组
		rightMin[length -1] = input[length -1];
		for(int i = length -2; i >= 0; --i){
			if(input[i] < rightMin[i+1])
				rightMin[i] = input[i];
			else
				rightMin[i] = rightMin[i+1];
		}

		//从左向右计算leftMax
		int leftMax = 0x8fffffff; 
		for(int i = 0; i < length; ++i){
			//获取前面0~i的最大值
			if(input[i] > leftMax)
				leftMax = input[i];
			if(leftMax <= rightMin[i])
				result.push_back(i);
		}
		//释放资源
		delete [] rightMin;
		return result;
	}
	

56，如何在字符串s1中查询是否包含另一个字符串s2
答案：
在一个字符串中查找另一个字符串，一般存在BF算法和KMP算法，其中BF算法的复杂度是O((M-N)*N)，而KMP算法的复杂度是O(M+N)。
BF算法：
从s1[0]~s1[M-N]为其实字符的长度为N的子字符串一次与s2进行比对，如果找到就返回这个子字符串的起始位置，否则最后返回-1.
KMP算法：
BF算法的一个最大的问题是，每一次如果没有找到就将s1中的比较的起始位置向前移动1.而KMP算法是在每一次如果不出现了不匹配，s2中的位置指针并不会进行回溯，而是通过调整s2中的要比较的下一个位置进行新的比较，这个位置的确定依赖于一个next数组，next[i]表示s2[i]与s1中的字符不匹配的时候的时候下一个s2中的直接用来与s1中现在的位置上的字符进行比对的位置。KMP算法中的next数组的构建分析如下：对于s2="aaacXbbb"如果在X字符处不匹配，那么由于前面的aaac已经匹配了，就分析这个aaac的前缀aaa与后缀aac他们重合的部分是aa，那么由于前面已经有两个重合的了next数组应该执行2也就是从第三个元素进行匹配。上面对next[i]只是从理论上给出一个描述，实际操作计算的时候这个复杂度还是太高，可以进行进一步的优化。这个优化基于以下事实：为了计算next[i+1],首先考虑next[i]，如果数组中s2[i] = s2[next[i]]那么就可直接设置next[i+1] = next[i] + 1;如果数组s2[i] != s2[next[i]]，那么问题转换为将s2[next[i]]"替换"（并不是真实的内存替换，可以想象为替换效果）为s2[i]之后重新计算next[next[i]]，这个值就是最后的要求的next[i+1]。上面的问题为一个递归问题，现在只需要找到这个问题的base。可以观察到当i=0的时候，如果出现了不匹配，那么s1中的指针应该向前一定一位，从s2的开头重新进行匹配，所以这里形象的理解为next[0]=-1,也就是使用s2中一个越界的位置与当期不符合的s1的位置进行重新匹配（并且认为是匹配成功的）。
BF算法的代码大致如下：
	int BF(const char * s1, const char * s2){
		assert(s1 && s1);  //assert宏用于在debug的模式下进行检测，如果是release的模式会自动删除这个宏
		int M = strlen(s1), N = strlen(s2);
		if(M < N)
			return -1;
		for(int i = 0; i <= M - N; ++i){
			int j = i,k = 0; //j为s1中位置的移动脚标  k为s2中位置的移动脚标
			for(; k < N; ++j,++k){
				if(s1[j] != s2[k])
					break;
			}
			if(k == N)
				//找到了
				return i;
		}
		return -1;
	}
	
KMP算法的代码大致如下：
	int KMP(const char *s1, const char * s2){
		assert(s1 && s2);
		int M = strlen(s1), N = strlen(s2);
		if(M < N)
			return -1;
		//构建next数组
		int *next = new int[N];
		if(!next){
			std::cerr << "new memory fail" << std::endl;
			return -1; //异常处理，这里本来应该是抛出异常的，这里暂时写作返回-1
		}
		next[0] = -1; //base
		for(int i = 1; i < N; ++i){
			int j = next[i-1];
			while(j != -1 && s2[j] != s2[i-1]){
				//回溯
				j = next[j];
			}
			//注意：当next[i-1]为-1的时候。需要直接将s1中的指针向前移动，也就是“s2[-1]与s1中的目前的位置相对齐进行比较并且认为是符合要求的(符合要求也就是next[i] = next[i-1] + 1)”
			next[i] = next[i-1] + 1;
		}

		/*上面我个人书写的寻找next[i]的代码，网络上其他的寻找next数组的代码如下	---START*/
		/*写法1：严格迭代，使用next[i]与之前的其他已知的next，迭代出next[i+1]*/
		int j = next[0] = -1; //记录上一个的next[i]
		//递推next[i+1]
		for(int i = 0; i < N -1;){
			if(j == -1 || s2[i] == s2[j]){
				//s2[i]与上一个next位置的元素匹配（包括next 为 -1的时候的默认与当前元素的匹配）
				next[++i] = ++j;
			}else{
				//调整j  接着寻找next[i+1]
				j = next[j];
			}
		}
		/*上面我个人书写的寻找next[i]的代码，网络上其他的寻找next数组的代码如下	---END*/

		//查找子字符串的位置
		int i = 0; j = 0;
		while(i < M && j < N){
			if(j == -1 || s1[i] == s2[j]){
				//这里包含了next[i] = -1这一特殊情况
				i++;
				j++;
			}else
				j = next[j];  //不匹配，下一次s1中的指针不动，s2中的下一个比对位置移动到next[j]
		}
		
		//释放资源
		delete[] next;
		return j < N ? -1 : i - N;
	}


57，在C++中如下写法是否存在问题 char * s = "hello world"
答案：
编译通不过，因为这是C++，不是C. 在C++中字符串常量(存在常量区)是不能直接赋值给char*的(包括形参为char*，没有办法直接通过字符串常量进行传递)，因为常量区的字符串是不能进行更改的，而通过char*传递违反了这个规则。与C语言一样，C++中允许使用常量字符串对char数组进行初始化，也即是 char s[] = "hello world" 是合法的写法。在C++中常量区的字符串可以直接传递给一个string类型，这里不是简单的指针传递，这里是进行了内容的复制. 还有一点 const char* s = "hello"是合法的，因为是const类型的指针，所以不会涉及到内容的更改，保证了安全性。


58,在C++中如下写法是否正确： const char * s = "hello world"
答案：
正确  因为const char * 指向常量区，并不会对常量区的内容进行潜在的修改，所以编译是通的过的。但是char * s = "hello"是编译通不过的，原因是设计到常量区的内容不能更改，而如果使用char * 指针进行引用可能进行潜在更改。（C语言中是可以使用 char * s = "hello"的，但是常量区也是不能更改的，这里虽然是可以赋值的，但是不能利用这个指针进行常量区的内容的更改，否则程序会崩溃）


59，给定两个字符串s1和s2，判断是否s2可以通过s1做循环移位得到。
分析与答案：
给定字符串s[] = "abcd"，其循环移位之后的字符串可以有一下四个（也就是每一个元素都可能是起始的第一个字符）：
abcd
bcda
cdab
dabc
按照一般性的分析，将在这些字符串中（利用KMP）寻找是否存在s2就可得到最终的结果。
现在要分析的一点就是，如果一个字符串的长度比较大，如果采用事先存储所有循环移位得到的字符串那么需要使用 N*(N-1)的额外空间，在很多程序中这是不可接受的，如果保存上一个循环移位字符串的起始字符的位置，那么，可以对每一个循环移位后的字符串进行判断之后用同一个空间保存下一个移位之后的字符串，这个需要额外的空间为O(N)（可以使用O(1)直接在原来的字符串上面进行修改，不过这设计到原来输入字符串的完整性问题）。实际上,这种相邻的字符串之间的规律很统一，明显可以进行空间复杂度的优化。可以这么考虑用一个变量保存其实的位置索引，这个位置索引的范围应该是[0,length-1]，然后对于每一个其实的位置i，用另一个变量j进行保存i，再对s[j++%length]在j < (length  + i)的情况下进行分析就取得了一个完整的循环移位后的数组。
如果使用一个额外的数组进行每一次的移位得到的字符串进行保存，那么常用的KMP算法直接对这个字符串进行处理即可。如果是通过s[j++%length]进行在原字符串上的访问，那么对于KMP算法的传入参数和内部的处理需要一些改良。值得注意的是如果使用一个额外的数组进行每一次移位字符串的保存，那么每一次移动会设计到O(n)的数据移动，这个相对于使用O(n*(n-1))的额外空间的处理在时间复杂度上没有改良。如果使用s[j++%length]进行访问呢？这个虽然不涉及到每一的元素的移动，但是又多了一个"%length"的运算。从上面的分析，可以看出，目前的思路对于时间的复杂度为O(N*N + N*(N+M))(其中N为s1长度,M为s2的长度)是没有改良的。
改良时间复杂度：
上面描述的算法的时间复杂度O(M*(M+N) + M*M)(M为s1的长度，N为s2的长度)明显太高，影响了算法的实用性。考虑到以下事实：我们要寻找的是s2，由于s2是固定了，如果我们对每一个移位字符串都进行KMP，那么里面进行next数组的计算就是重复的。另外，由于对于每一个移位之后的字符串，使用KMP都会进行从前向后移动的匹配，而多个KMP之间这种尝试性匹配也是存在高度的重复的。
改良复杂度的方案如下：对于abcd我们可以通过在这个字符串后面加上abc构成一个abcdabc字符串。在保证要查找的s2的长度小于容器字符串s1的长度的前提下，如果找到了s2,那么s2一定是重新构建的abcdabc的子串。通过这种转化，可以使用一个KMP算法，复杂度O(2*M - 1 + N)查找s2是否存在在s1的移位字符串中。
同样，由于改良之后的算法的空间复杂度为O(2*M)，如果要进行空间复杂度的优化，可以考虑在原来的字符串上面使用s1[j++%length]这种访问方式，将空间复杂度降低到O(1)
改良了时间复杂度(O(2*M -1 + N))和空间复杂度(O(1))(这里的空间分析没有加入next数组的构建空间，如果加上这一部分，最终的结果应该是O(N))的最佳算法如下：
	int cal3(const char * s1, const char * s2){
		assert(s1 && s2);
		int M = strlen(s1), N = strlen(s2);
		if(M < N)
			return -1;
		//构建next数组
		int *next = new int[N];
		if(!next){
			std::cerr << "new memory fail" << std::endl;
			return -1;
		}
		next[0] = -1;
		//利用迭代计算next[i+1]
		int j = -1; //上一个合适的next
		for(int i = 0; i < N - 1;){
			if(-1 == j || s2[i] == s2[j]){
				//得到next[i+1]
				next[++i] = ++j; 
			}else
				j = next[j];  //回溯，继续计算next[i+1]
		}

		j = -1; //s2中的指针
		int i = 0; //s1中指针
		//说明一下这里的i<(2*M -1)的原因，这里的i的边界是cal2算法中的边界，也就是假设将s1后面添加上s1[0~M-2]构成一个长度为2*M -1的字符串数组
		for(; i < (2 * M -1) && j < N;){
			while(-1 != j && s1[i%M] != s2[j]){
				j = next[j];
			}
			i++;
			j++;
		}
		//释放next数组
		delete [] next;
		return j == N ? i - N : -1;
	}	


60，C/C++中函数的默认返回值类型是什么，如果这个返回值在函数中没有提供又会返回一个什么
分析与答案：
在C/C++中，函数的默认返回值类型是int，也就是说如果没有提供返回值类型，那么这个返回值类型就是int。所以如果要定义一个返回值的类型为void的，一定要明确的指出。
一个函数的返回值没有提供，对于不同的编译器，这个行为是未定义的，返回的是垃圾值。


61，将一个字符串转化为一个int数据，要求考虑各种异常情况。
分析与答案：
这是一本书上的题目，这里给出书上面其本身的主要分析点。
	1）拿一个int保存返回的结果，初始化为0.字符串本身从前往后进行遍历，每次对返回的结果 * 10 + 当前的字符 - '0'.这是正常的运行逻辑。但是这里存在一个符号位的问题，也就是第一位要判断一下是否是符号位，如果是 - ，那么最终的结果需要 * -1。
	2）存在一下可能异常的情况：
		字符串表示的数字，用int存储不下，导致了溢出
		输入的字符串中存在非法的字符，例如第一个字符不是0~9也不是符号位
	这里对于溢出的情况，直接返回0，对于非法字符，会返回非法字符之前的运算结果，但是可以提供一个参数用于接受运行结果是否为非法，这个参数如果不提供那么对于结果调用者不考虑进行验证。如果提供了这个参数，在出现发非法的字符的时候，可以将这个参数设置为非法的状态提供给调用者进行检查
后续补充：
	1）编码的过程中，发现一个小的细节点，由于负数的符号位后面可表示的正数会比正数可以表示的返回大1。那么如果单独的剔除符号位进行统一的后面的纯数字的分析，对于这个最大的负数，计算结果会是溢出。查看书上的代码，其代码的判定为 "num > std::numeric_limits<int>::max()"的时候判定为溢出，也就是其本身的代码也没有注意到这个特殊的情况.
	2）要修复这个小bug，可以对每次要加上的部分都先与符号(1或者-1)相乘，然后在追加到最终的结果中。而不是在正数结果出来之后再添加上符号.
	3）如果叠加的结果是最终的结果，那么可能出现负数。就需要修改原来的溢出判断机制。判断的方案是：如果符号位为负并且叠加的结果为整数或者符号位为正并且叠加的结果为负，那么最后的结果就溢出了。注意，上面的溢出判断不可以统一为用符号(1或者-1)与叠加的结果相乘，如果是负就溢出如果为正就每溢出，原因还是那个边界情况，最大的负数与-1相乘得到的正数是int保存不下的，最终还是个负数。
实际编码：
	/*
		将一个字符串转换为int
	@param const char* str 要转换的字符串
	@param bool * validate=nullptr 用于计算结果合法性检查，这个参数可以不传入。如果这个参数进行了传入，那么在计算结果合法的时候会将值设置为true，否则会设置为false
	@return int 转换之后的int，如果出现了溢出会直接返回0
	@version 1.0 基本实现功能，存在第一个小的bug，就是这里的
	*/
	int StringToInt(const char * str, bool *validate=nullptr){
		if(!str)
			return 0; 
		int length = strlen(str);
		if(!length)
			return 0;
		int minus = 1, i = 0;
		if(str[0] == '+'){
			i++;
		}else if(str[0] == '-'){
			i++;
			minus = -1;
		}
		
		if(validate)
			*validate = true;

		int result = 0; //返回值
		for(; i < length; ++i){
			if(str[i] < '0' || str[i] > '9'){
				//遇到非法字符
				if(validate)
					*validate = false;
				break;
			}
			result *= 10;
			result += (str[i] - '0') * minus; //version2.0 每次追加的结果都与符号相乘
			if(!(-1 == minus && result <= 0 || 1 == minus && result >= 0)){
				//溢出了
				result = 0;
				break;
			}
		}
		//其实这里并不用判断是否overflow 因为前面如果溢出了会将result置为0. 但是个人认为这里这么写可以进行更好的语意表达
		/*version 2.0 符号的处理放到了叠加上 不在这里进行最后的处理
		if(!overflow){
			result *= minus;
		}
		*/
		return result;
	}

62, 如何判断一个字符串s1中的字符是否在s2中全部存在。
答案与分析：
这里的全部存在应该包括存在的次数，也就是说在s1中一个字符出现了n次那么在s2中出现的次数不能少于n。一般性的思路是构建一个256长度的hash数组，这个数组中的值保存的是每个assic字符出现的次数，先扫描s2，一个字符出现了一次就将对应的值加一，然后扫描s1，每一个字符如果出现就将对应的hash数组中的字符计数减一。最后扫描这个hash数组，如果存在某一个字符出现的次数是负数，那么就说明s1存在某个字符出现的次数比s2中多，结果返回false。如果这个hash数组中的所有的值都是非负，那么返回true。
其他的思路：
	可以给每一个字符分配一个素数，一共有256个素数，然后遍历s2，将每一个出现的字符对一个的素数进行相乘，得到一个很大的数。然后在扫描s1，用每一个出现的字符对应的素数去除这个“很大的数”，如果不能整除，那么结果就是false，如果能够整除，那么就将这个“很大的数”重置为除法的结果，然后接着遍历s2进行上述的操作一直到s2的末尾返回true。
	另一种思路是将s1，s2都进行排序，然后遍历s1，s2，如果s2中的字符没有匹配到s1中的就直接后移，如果s2中和s1中字符匹配了，就将s1和s2都进行后移。最后判断s1中的位置是否已经移动到末尾就可以得到最终的结果。对于这一种思路，我曾经分析过是否可以在s1和s2遍历都没有到最后的时候就可以判断到不匹配的情况返回false。实际上可以考虑这么个情况s1="ac" s2="abbbbbbbc"可以看到在遍历到 c > b的时候，只能按照上面的描述一直移动s2的位置指针，一直到最后才能匹配到c字符。目前没有分析到可以在遍历结束前判断出最终的结果的方案。另一方面，排序操作会修改输入的数据，这种行为在很多场合是不合适的（而进行原来的数据拷贝然后进行操作又会有额外的空间开销）.
利用hash表进行判定的代码大致如下：
	bool AllCharsInString(const char * src, const char * dest){
		assert(src && dest);
		int nums[256] = {0}; //保存每一个字符出现的次数
		int M = strlen(src), N = strlen(dest);
		//遍历src 增加相应字符出现次数的计数
		for(int i = 0; i < M; ++i){
			nums[src[i]]++;
		}
		//遍历dest 减少相应字符出现的次数计数
		for(int i = 0; i < N; ++i){
			nums[dest[i]]--;
		}
		//遍历nums数组  如果出现了一个字符的次数小于0那么直接返回false  表示这个字符在src中出现的次数少于dest中的
		for(int i = 0; i < 256; ++i){
			if(nums[i] < 0)
				return false;
		}
		return true;
	}

63，如果进行一个字符串中的按照单词进行逆转，例如"Today is Friday!"进过逆转之后成为"Friday! is Today"
分析：
一种思路是先将整个字符串进行按字符翻转，例如上面的"Today is Friday!"翻转之后就成为"!yadirF si yadoT"，然后在对这个翻转之后的字符串中的每一个单词进行翻转。这种翻转思路是直接在原来的字符串上面进行操作。
另一种思路是从后向前，获取到最后一个单词（如果是多个连续的空格，我个人采取将多个空格保留也认为是一个单词）然后在递归的翻转前面的部分，并且将结果追加到最后的那个单词的后面。这一种思路不会对原来的字符串进行修改（不过也可以将最终的结果再拷贝回原来的字符串中）,如果使用char*类型的返回那么返回的新的字符串的空间需要调用者进行释放，在这里为了编码方便可以使用C++中string类型进行操作(编码方便，内存也更好管理)。
使用翻转的思路代码如下：
	/*
		按照字符翻转一个字符串
	@param char * str 要翻转的字符串
	@param int num 要翻转的字符个数，默认为-1表翻转整个字符串
	*/
	void Reverse(char * str, int num = -1){
		assert(nullptr != str);
		if(num < 0)
			num = strlen(str);
		for(char * p = str, *q = str + num - 1, tmp; p < q;p++,q--){
			tmp = *p;
			*p = *q;
			*q = tmp;
		}
	}


	/*
		按单词进行一个字符串的翻转，这里直接在原字符串上面进行操作	
	*/
	void ReverseByWord(char * str){
		assert(nullptr != str);
		//先翻转整个字符串
		Reverse(str);
		//遍历翻转之后的字符串，对于非空格的单词进行翻转
		int length = strlen(str);
		for(int i = 0, j = 0; i < length; i = j){
			//将i移动到第一个不是空格的字符上
			while(str[i] == ' '){i++;}
			//将j移动到i后面的第一个空格
			for(j = i; j < length && str[j] != ' '; j++){}
			if(i < j){
				//翻转单词
				Reverse(str + i, j - i);
			}
		}
	}
使用递归的思路的代码如下：
	/*
		使用递归的思想，进行字符串按单词的翻转
	@param std::string str 要操作的字符串
	@param int num 要翻转的字符数量, 如果提供的是负数表示翻转整个字符串
	@param 翻转之后得到的字符串
	@note： 这里提供一个num参数，是因为考虑到递归中如果全部使用string.substr来获取前面的子串,那么对于单词很短，整个字符串很长的情况会造成很大的额外内存开销。所以保存一个变量表示当前要翻转的范围
	*/
	std::string ReverseByWord(std::string & str, int num = -1){
		if(num < 0)
			num = str.length();
		if(!num){
			//递归的base
			return "";
		}
		std::string toReturn = "";
		int i = num - 1, j = i;
		while(i >= 0 && str[i] == ' '){
			//空格直接追加到结果集中，因为空格即使进行翻转，结果也是一样的。
			toReturn += ' ';
			i--;
		}
		for(j = i; j >= 0 && str[j] != ' '; --j){};
		if(j < i){
			//将单词追加到结果中
			toReturn += str.substr(j + 1, i - j);
		}
		return toReturn + ReverseByWord(str, j + 1); 
	}


64，删除一个字符串中出现的指定的模式串的字符。例如"abccdd" 删除指定的模式"cd"之后就成为了"ab"
分析：
正常思路，是遍历查询的s1，然后用其中的每一个字符与模式串s2中的字符一一比对。设s1、s2的长度是M、N，那么这个算法的复杂度是O(M*N)。更一般的算法是，利用一个hash表（一般这个hash表的长度是256，但是特定情况下可能会更小，例如如果假设都是小写字母，那么只需要26就行了，不过这个对于空间复杂度的优化很不明显而且要进行char - 'a'这样的计算，增加了计算指令），先遍历s2，将s2中存在的字符对应的hash表中的值设置为true，然后遍历s1，对于每一个字符去查询hash表，如果存在就删除（如果重新构建一个新的字符串，这里的删除是一次忽略）.
另一个依赖于高级数据结构的算法是，将所有的字符分配一个不同的素数，然后遍历s2，将s2中这些对应的素数相乘，得到一个很大的数，然后遍历s1，用每一字符对应的素数去除得到的那个“很大的数”，如果可以整除，就将这个字符删除.
使用hash算法复杂度为 O(M + N + 256)的算法如下:
	/*
		删除一个字符串中的可能出现的一系列字符
	@param char * str 要处理的字符串
	@param char * mode 包含要被删除的字符的模式字符串
	@return char * 删除之后的字符串 如果内部运行异常会返回null
	@note: 这个函数内部申请的资源需要调用者释放
	*/
	char * DeleteCharsInMode(const char * str, const char * mode){
		assert(str && mode);
		bool hash[256] = {0};
		int M = strlen(str), N = strlen(mode);
		char * toReturn = (char*)malloc((M + 1) * sizeof(char));
		if(!toReturn)
			return nullptr;
		//遍历mode 设置hash
		for(int i = 0; i < N; ++i){
			hash[mode[i]] = true;
		}
		//遍历str 构建返回值
		int lenReturn = 0;
		for(int i = 0; i < M; ++i){
			if(!hash[str[i]])
				toReturn[lenReturn++] = str[i];
		}
		toReturn[lenReturn++] = '\0';
		//重新开辟空间
		toReturn = (char*)realloc(toReturn, lenReturn);
		if(!toReturn)
			return nullptr;
		return toReturn;
	}


65,设计一个trim函数，去掉一个字符串前后的空格，将中间的空格多个连续的空格转换为一个
分析：
常见api中的trim有trim_left trim_right trim，但是他们一般的不会合并中间的空格.这里的实现策略是从左往右进行扫描，首先跳过最前面的空格，然后添加第一个单词(到下一个空格部分之前)。接下来的处理就很统一，如果一直是空格就往后移动，如果遇到非空格就记录下紧邻上一个连续空格的非空格的位置，然后一直向后移动到空格，在这个单词添加到最终的结果之前向结果中添加一个空格，循环上面的过程一直到遍历结束，就得到最终的trim之后的字符串。
大致代码如下：
	char * trim(const char * s){
		assert(s);
		int length = strlen(s);
		char * toReturn = (char*)malloc((length + 1) * sizeof(char));
		if(!toReturn)
			return nullptr;
		int i = 0, j = 0, k = 0;
		//处理最前面的空格
		while(i < length && s[i] == ' '){ i++;}
		//处理第一个单词
		for(j = i; j < length && s[j] != ' '; ++j){
			toReturn[k++] = s[j];
		}
		//处理中间和最后的空格和单词
		while(i < length){
			//略过空格
			for(i = j; i < length && s[i] == ' '; ++i){}
			//获取单词结束位置
			for(j = i; j < length && s[j] != ' '; ++j){}
			//如果i < j也就是存在单词 那么将一个空格和单词添加到结果中
			if(i < j){
				toReturn[k++] = ' ';
				for(int x = i; x < j; ++x)
					toReturn[k++] = s[x];
			}
		}
		toReturn[k++] = '\0';
		//重新分配合适空间
		toReturn = (char*)realloc(toReturn, k * sizeof(char));
		if(!toReturn)
			return nullptr; //注意，这里完全可以不去判断是否为null，因为toReturn为null的时候直接返回toReturn对于最终的结果是一样的，但是这里这么写可以让逻辑更清晰
		return toReturn;
	}

66，找出一个字符串中第一个只出现一次的字符。例如abaccdeff，会输出b。假设所有的字符都是assic的。
分析：
利用一个hash结构存储每一个字符出现的次数，遍历输入的字符串，填充这个hash。由于要找到“第一个”，那么再遍历一次输入的字符串，如果找到某一个字符刚好出现次数是1的就返回。
	/*
		获取一个字符串中第一个只出现一次的字符
	@param const char * str 要查找的字符串
	@return 如果找到了就返回这个字符串中第一个只出现一次的字符。如果没有这样的字符存在就返回 '\0'
	*/
	char GetOnlyOnce(const char * str){
		assert(nullptr != str);
		int hash[256] = {0}; //保存每一个assic字符出现的次数
		//遍历字符串  填充hash
		const char * p = str;
		for(;*p;p++)
			hash[*p]++;
		//遍历字符串，判断字符出现的次数
		for(p = str; *p; p++){
			if(1 == hash[*p])
				break;
		}
		return *p;
	}


67，如何判断一个字符串中是否所有的字符都是不同的。
分析：
利用hash结构存储是否一个字符在字符串中存在，然后遍历这个输入字符串，对于当前字符对应在hash结构中不存在，就将状态设置为已经存。如果hash中给出的结果是已存在，那么这个字符就出现了2次，直接可以返回false。这如果要降低空间的要求，可以考虑使用bit-map，因为一个位已经够用来表示一个字符的是否已经出现的状态了。
大致的代码如下：
	bool AllDifferentInString(const char * str){
		assert(nullptr != str);
		bool hash[256] = {0}; //保存每一个assic字符是否已经出现 
		for(const char * p = str; *p; p++){
			if(hash[*p])
				return false;
			hash[*p] = true;
		}
		return true;
	}


68，memcpy和strcpy的区别
答案：
memcpy和strcpy都是C标准库的函数。strcpy只能用于复制字符串，而memcpy可以用于任何连续结构(例如数组、结构体、类)的内存空间的拷贝。strcpy不仅会复制字符串的内容，还会复制字符串的结束符。strcpy由于是用'\0'判断复制结束的，所以不用长度，而memcpy是通过第三个参数指定要复制的长度的。两个函数的签名为 char * strcpy(char * dest, const char * src) 和  void* memcpy(void * dest, void * src, size_t n)

69,一个字符串中只有a~z的字符，如何使用最小的空间来计算这个字符串中到底有哪些字符。
答案：
由于只有26个字符，那么一个int就可以搞定。用一个int的每一位存一个字符对应的状态，为1表示存在，为0表示不存在。设置一个int result = 0 遍历这个字符串，如果一个字符存在就，就将result | (1 << (*str++ - 'a'))重置这个result。遍历完成之后，再遍历这个int，初始计数器i=0,使用 result & (1 << i++) ，判断这个结果为1还是0，如果是1表示相应的字符存在。


70，设计一个strcpy函数
答案：
主要的细节点有：对于字符串为null的断言  源字符串需要用const修饰，这样更严谨  返回原来的目标字符串，方便链式操作
代码如下：
	char * strcpy(char * dest, const char * src){
		assert(dest && src);
		char * toReturn = dest;
		while(*dest++ = *src++){}
		return toReturn;
	}

71，将字符串中所有的空格替换成"%20"。函数的签名形式为 void ReplaceFunc(char str[], int length)
分析：
通过函数的签名，可发现对于空间的保证是由调用者去实现的。对于空格的替换，如果是从前往后进行，那么由于替换之后的字符串比空格更长，会导致对后面还没有替换和拷贝的原来的内容进行了覆盖。所以这个函数的逻辑应该是从后往前进行覆盖。
代码如下：
	/*
		将一个字符串中的所有空格替换为"%20"
	@param char str[] 要处理的字符串
	@param int length 要处理的字符串的长度
	*/
	void ReplaceFunc(char str[], int length){
		int newLen = length; //新的替换后的字符串的长度
		for(int i = 0; i < length; ++i){
			if(str[i] == ' ')
				newLen += 2;
		}
		str[newLen] = '\0';  //添加新的结束符
		//从后往前遍历str 保存替换结果
		for(int i = length - 1, j = newLen -1; i >= 0; --i){
			if(str[i] == ' '){
				str[j--] = '0';
				str[j--] = '2';
				str[j--] = '%';
			}else
				str[j--] = str[i];
		}
	}
问题延伸：
	1）这个函数的经过简单的修改，可以实现对于任意的字符用某一个字符串进行替换
	2）更一般的，对一个字符串中的某一个子串进行匹配替换，可以考虑使用KMP（为了避免重复的运算，需要适应的改良）从前往后查找，用一个新的空间保存替换之后的结果返回。这个就有些像正则里面的repacleAll了，当然也可以设定一种只替换第一个匹配的子串。这里对于KMP的运用更多的是一种思想，对于不同的子串，由于匹配模式一样，所以next属猪只需要构建一次；还有要计算需要存储的结果字符串的空间开销的时候遍历了一次字符串，这个时候，可以把KMP查询到的一系列的子串的位置保存下来，这样接下来的替换就不用再进行查找了。
	3）和2）相似的问题是提供一个模式字符串，要求对输入字符串与模式串中的所有匹配的字符替换某一个字符串
这里对于延伸问题3）的代码：
	/*
		延伸： 将一个字符串中的所有与模式串中字符匹配的元素都替换为某一个字符串
	@note: 这里不在原来的字符串上面进行操作，而是将结果返回一个新的字符串，资源需要调用者进行释放
	*/
	char * ReplaceByMode(const char * str, const char * mode, const char * replace){
		assert(str && mode && replace);
		int length = strlen(str), newLen = length, replaceLen = strlen(replace);
		//利用模式串 构造hash
		bool hash[256] = {0};
		while(*mode){
			hash[*mode] = true;
			mode++;
		}
		//计算新的数据空间
		for(int i = 0; i < length; ++i){
			if(hash[str[i]])
				newLen += replaceLen - 1;
		}
		char * result = new char[newLen + 1];
		if(!result){
			std::cerr << "new memory fail" << std::endl;
			return nullptr;
		}
		result[newLen] = '\0';
		//遍历原字符串  填充结果字符串
		for(int i = 0, j = 0; i < length; ++i){
			if(hash[str[i]]){
				//进行替换
				for(int k = 0; k < replaceLen; ++k)
					result[j++] = replace[k];
			}else{
				//直接复制原来的字符
				result[j++] = str[i];
			}
		}
		return result;
	}
对于问题2）进行子串的替换的线性代码如下:
	/*
		延伸： 将一个字符串中的所有某个子字符串替换为另一个字符串
	@note: 这里不在原来的字符串上面进行操作，而是将结果返回一个新的字符串，资源需要调用者进行释放
	*/
	char * ReplaceSubStr(const char * str, const char * substr, const char * replace){
		assert(str && substr && replace);
		int length = strlen(str), newLen = length, subLen = strlen(substr), replaceLen = strlen(replace);
		if(!subLen){
			std:: cerr << "the substring is null" << std::endl;
			return nullptr;
		}
		//构建next数组
		int *next = new int[subLen];
		if(!next){
			std::cerr << "new memory fail" << std::endl;
			return nullptr;
		}
		next[0] = -1;
		//迭代计算next[i+1]
		for(int i = 0, j = -1; i < subLen -1;){
			if(j == -1 || substr[i] == substr[j]){
				next[++i] = ++j;
			}else{
				j = next[j]; //回溯
			}
		}

		//在原字符串中查询目标子字符串出现的位置
		std::vector<int> pos; //保存查找到的子串的位置
		int sub = replaceLen -  subLen; //用于替换的字符串与原子字符串的长度差

		for(int i = 0, j = 0; i < length;){
			if(j == -1 || str[i] == substr[j]){
				i++;
				j++;
				//如果匹配完成  就将位置添加到容器
				if(j == subLen){
					pos.push_back(i - subLen);
					//修正返回结果字符串的长度
					newLen += sub;
					//重置j 表示开始下一个位置的查询
					j = 0;
				}
			}else
				j = next[j];
		}
		//开辟返回结果的字符串空间
		char * result = new char[newLen + 1];
		if(!result){
			std::cerr << "new memory fail" << std::endl;
			return nullptr;
		}
		result[newLen] = '\0';
		//遍历原字符串到最后一个找到的子串  填充结果字符串
		int size = pos.size();
		int i = 0, j = 0;
		for(int k = 0; k < size; ++k){
			//复制查询到子串之前的部分
			for(; i < pos[k]; ++i)
				result[j++] = str[i];
			//将查询到的子串替换为目标字符串
			for(int t = 0; t < replaceLen; ++t)
				result[j++] = replace[t];
			i = pos[k] + subLen;
		}
		//复制最后查询到的子串之后的其他部分
		for(; i < length; ++i)
			result[j++] = str[i];
		//释放资源
		delete [] next;
		return result;
	}

72，C++中struct可以有无参数的构造方法吗，有继承与多态吗，与class的区别是什么
答案：
C++中的struct与class都可以有各种构造方法，都有继承与多态。二者最大的区别是struct中的默认权限是public的而class中的默认权限是private的。

73，C/C++中的位域是什么，有什么用
答案：
在有些信息进行存储的时候，不需要一个完整的字节，而只需要一个或者几个二进制位，为了节省存储空间，C语言提供了以一种可以指定数据所占位数的数据结构，称为位域。在使用位域的时候字段的类型应该为整型(包括无符号整型和其他的数字类型例如bool char short)或者枚举，在类型名与变量名后面可跟上冒号加上变量占用的位数。格式如下：
	unsigned int SN:4; //占用4个位
	unsigned u:1; //1个二进制位
	int :2; //占用2个二进制位  并且为匿名
在结构体中可以使用匿名的位域字段来提供间距：
	struct reg{
		unsigned int s:4;
		unsigned int :4;
		bool good:4;
	}
	对于上面的结构体的变量的初始化，直接略忽略占位的部分就可：
		reg r = {14,true};
-----note: 和其他的类型一样，如果提供的初始化或者赋值的值超过了位域的范围，会将低位的内容赋给变量。

74，C++由哪两部分组成。
答案：
C++语言由核心语言和标准库两个部分组成。核心语言主要是一系列的关键词组成，提供了一些数据类型和结构控制。如果仅仅使用核心语言，不能执行一些输入输出或者更复杂的操作，这个时候就需要使用标准库函数了。使用标准库的函数需要使用using namespace std 或者使用std::cout 这种形式进行引用，而使用核心语言没有这些限制。


75，结构体和共用体的内存占用与所有成员所占的空间之和是什么关系，与其中的最大的元素的所占空间的大小又是什么关系
答案：
结构体的占用空间的大小是大于等于所有成员的空间之和的，原因是可能由于对齐的问题，会需要额外的空间。共用体和结构体一样都是从低地址开始存放元素，也会先出现对齐的情况。共用体的空间为各个成员中占用最大的那个的内存（有的成员可能由于需要对齐出现扩充内存）


76,关于printf函数，参数的入栈是从左往右还是从右往左，对于每一种数据类型入栈的空间大小是多少
答案：
printf函数的入栈顺序是从右往左的，这样依次出栈打印的结果就是从左往右的。对于数据类型，如果是char short 等小于4个字节的元素入栈，入栈的时候会占用4个字节，这样printf("%d",'a'）这样的输出结果的正确性得到了保证，如果数据的类型不满4个字节进行填充到4个字节，当数据的类型是无符号的时候高位统一填充1，如果是有符号的时候高位填充符号位。如果数据的类型大于4个字节的时候，参数以实际的所占字节数入栈。对于字符串的类型，入栈的是一个指向字符串的指针。

77，long long x = 0x0102030405060708 在小端的机器上，printf("%x",x)输出的结构是多少
答案：
小端的机器是高位存放在高字节，低位存在在低字节。这里x入栈之后低字节存放的是0x05060708。然后%x是以16进制的形式打印一个int，所以这里输出的结果是栈顶的0x05060708

78,枚举类型占用多少个字节
答案：
枚举是一系列的枚举常量的集合，其本身类型占用4个字节，相当于一个unsigned int

79,小端机器上，下面的程序执行的结果是多少
	struct S{
		unsigned short a:5;
		unsigned short b:5;
		unsigned short c:6;
	} s = {16,4,0};
	prinft("%d",*(short*)&s);
结果与分析：
上面的s的内存结构为 0000000010010000 将其转换为short然后输出结果为144. 其实这里的结果就是4 * 2^5 + 16 = 4 * 32 + 16

80，sizeof是函数吗？sizeof int 这样的写法是否正确。int i = 1; cout << sizeof(i++); 之后i的结果是多少。那些情况下使用sizeof会被编译器判定为非法
分析与答案：
sizeof本身是一个运算符，不是函数，如果计算传入是一个变量，那么后面用不用括号括起来都是可以的，如果是传入了一个类型例如int，那么这个传入的类型必须使用括号包起来。所以上面的 sizeof int是不合法的。
另一个注意的点是，sizeof的结算结果是在编译阶段，所以一般不会对其中的表达式进行实际的计算，如果是传入一个函数的执行表达式，那么这个函数的执行表达式不会执行，sizeof只会去查看这个函数的返回值类型。所以sizeof(i++)，运算符只会去查看i的变量类型而不会实际执行i++，另一方面这是一个表达式而不是函数传参，所以i++不会执行，也就是说sizeof(i++)之后i的结果是不会发生变化的。类型的 int func(){printf("hello"); return 0;} sizeof(func())这个func里面的打印语句也是不会执行的。
sizeof操作符不能对函数、不确定的类型(void)和表达式 和位域成员进行直接的计算。例如下面的写法是错误
	int func(){}; sizeof(func);
	void func(){}; sizeof(func());
	struct S{unsigned u1:1; unsigned u2: 2;}s; sizeof(s.u1);
-----note: 另一点要说明的是sizeof的结果与具体的平台有关，例如int的结构在32位系统上一般可以认为是4，而在16位机上为16

81，void func(char s[100]){ cout << sizeof s; } 输出的结果是多少
答案：
当数组用作形参的时候，会弱化为指针，这个时候进行sizeof获取到的是一个指针的大小，这里的结果是4.
-----note: 这里常常用来和引用传参相比较，引用传递的参数如果使用sizeof取得的就是原来的引用的变量的空间大小. 例如void fun(char (&s)[100]){cout << sizeof(s);} 由于s引用了一个100长度的数组，所以结果为100

82，没有任何成员的struct和class，它们的sizeof的结果是多少
答案：
结果是1. 对于没有任何成员的结构体或者是类，他们创建的对象空间都是1.这一字节是用来标识不同的对象的。这样对于不同的对象进行取地址之类的操作才有意义。空的class和struct也得存储，所以编译器为他们分配了一个字节的空间用于占位。

83，关于struct和union空间的计算问题原则
答案：
struct和union都是从低地址向高地址进行元素的存放的。所以计算的时候也是从申明的顺序进行分析。按照这个顺序主要考虑的原则有以下两点：
1）整个struct或者union的空间必须是其中的最大的元素的所占空间的整数倍。这里值得注意的对于数组元素，进行考虑的是其基础数据类型大小而不考虑整个数组的长度，数组从本质上来说也是一系列的类型相同的元素的连续存储。如果最大的元素所占的空间超过了4，例如是8，在windows下面一般可以认为这个struct或者union的空间必须是8的整数倍。但是在linux+gcc的环境下，如果最大的成员空间超过了4，那么就规定整个数据空间只需要为4的倍数就行。
另一方，可以使用伪指令 "#pragma pack"指定需要按照多少个字节进行对齐。#pragma pack(n)指定用n个字节进行对齐，但是如果在struct或者union中最大的元素的空间比n小，那么还是会以那个最大元素空间进行对齐。也就是说最终按照多少个字节进行对齐取决与这里设置的n与实际结构中的最大元素的空间的较小者。可以使用#paragma pack()取消用户自定义的对齐方式。这种使用伪指令通知编译器对齐方式的地方一定要在struct和union的定义之前。
2）从低地址向高地址存放元素的时候，在判断一个元素的时候，其前面的元素的所占空间的总和必须是当前这个元素的空间的整数倍，如果不是就在前面元素的后面进行填充实现对齐。如果是linux+gcc的环境下，一个元素的大小如果超过4，那么前面的元素的空间的总和只要为4的整数倍就行。当然对齐的方式是可以按照上面说的使用#paragma pack(n)进行设置的。如果设置一个n=2那么只需要是是2的整数倍就行。
----note:对于union的空间的分析，一个小技巧就是先把union当做struct进行分析，然后取得其中元素所占空间的最大值（考虑到对齐，可能这个空间需要填充）


84，对于结构体中存在位域的情况，如果计算结果体的大小
答案：
从前往后进行扫描，如果相邻的位域的类型是相同的，那么会进行压缩，多个相同的类型的位域进行压缩共同占用一个位域的类型的空间大小。如果相邻的位域相加的结果是大小小于一个sizeof他们的类型，那么后一个位域会紧邻着放。如果相邻的位域的空间大小之和大于一个sizeof相应的类型，那么后面的位域需要放置到下一个相应的类型的空间。多个相同类型的位域的压缩之后的空间是其基本类型的整数倍。但是对于Linux+gcc环境或者是Dev-C++环境，不论位域是何种数据类型，每个位域都是占用实际的空间大小（无论后面是不是位域，无论相邻的位域类型是否相同），也就是一个字节一个字节的空间向后延伸。
如果相邻的位域的类型不相同，在vs中是不是采用压缩的，而在Dev-C++和Linux+gcc中无论相邻的字段类型是否相同，都以实际占用的字节进行压缩。
如果一个位域后面不是位域，那么不会进行压缩，这个位域还是占用原来的类型的空间的大小，但是在Dev-C++和Linux+gcc的环境中，即使后面不是（相同类型的）位域，这个字段所占的空间也还是压缩之后的实际字节数。
整个结构体的大小是最宽基础数据类型的整数倍。这里的基础数据类型包括位域的数据类型。
例子：
	struct{
		int i1:4;
		int x;  
	}
	分析：i1后面不是位域，如果在vs中整个i1就要占用4个字节，整个struct占用8个字节。如果是在Linux+gcc环境中，i1占用1个字节，然后紧邻着放x，最后由于基础数据类型的最大空间是4，整个空间在1+5的基础上进行扩展为8.


85，下面的struct占用多少字节
	#paragma pack(8)
	struct S{
		union A{
			char a[13];
			int b;
		} a;
		void func(){};
		typedef void (*p)(int i);
		int i1:4;
		short s:2;
	}
	#paragma pack()
分析与解答：
首先union A占用13 + 3（与int对齐）= 16个空间。然后函数与typedef的部分不占用空间，因为这里只是定义了类型而没有定义相应类型变量。后面两个位域由于类型不同，在VS中不进行压缩分别占用4和2，然后short后面为了对齐int扩展2个字节。最终的结果是16 + 4 + 2 +2 = 24。如果在linux+gcc环境下，后面两个位域一共占用1个字节。16 + 1 不是int空间的整数倍，扩充3个字节之后的结果为20。由于这个结构体中的所有的基础数据类型都比设置的对齐空间8个字节要下，所以这里设置的8个字节的对齐没有产生作用。


86，下面的union的空间大小是多少
	#paragam pack(2)
	union U{
		char buff[13];
		int i;
	}
	#param pack()
分析与解答：
buff占用13，然后存放i，i占用4，并且这里设置了2个字节的对齐方式，所以 buff的空间需要为2的整数倍，所以最终的结果是 13 + 1 = 14


87，比较下面几个运算的优先级: 前置++  后置++  负号运算符  按位取反运算符~  移位运算符 赋值运算符  逻辑运算符   算数运算符
答案；
后置自增自减的优先级最高  结合的方向是从左往右
其次是负号运算符、前置自增自减、按位取反~和非运算！ 他们位于同一个优先级，谁先进行计算取决与结合方向上的顺序   他们的结合方向都是从右往左
紧邻的是算数运算符中的 / %  * 他们的结合方向是从左往右 
然后是算数运算符  + -  结合反向也是从左往右 
然后是移位运算符  结合的反向是从左往右 
然后是逻辑运算符中的  > >= < <=  结合方向是从左往右
然后是逻辑中的 == !=   结合方向是从左往右
然后是位运算中的 & ^ | 这三个运算符的优先级依次降低(& > ^ > |)  结合方向是从左往右
然后是逻辑中的 &&  结合方向从左往右
然后是逻辑中的  || 结合方向是从左往右
然后是是三目运算符?:  结合的方向是从右往左
然后是赋值运算符(= &= -= +=等等) 结合的方向是从右往左
最后是逗号运算符  结合的方向是从左往右

-----note: 上面的整体规律符合: 后置自增 > (前置自增、~、！、符号运算符) > 算数运算符(内部又是乘除 > 加减) > 移位运算符  >  逻辑比较（其中== != 要比 < <= > >=要低） > 位运算符(内部 & > ^ > |) > 逻辑连接(&& > ||)  > 三目?: >  赋值 > 逗号
---note：对于结合的方向，从右往左的有前置自增 赋值 逗号  三目运算符

88，表达式与语句区别
答案：
语句通常是以分号结尾的（语句可以分为说明性语句和可执行性语句），语句没有值而表达式有。


89，什么是左值，什么是右值
答案：
一个赋值表达式，左右两边的变量分别有着不同的角色，对于左边的元素这个变量代表的是它所在的存储单元的地址，而对于右边的元素我们需要的是它的值。这样一个变量名有了两种特性，我们把一个变量名代表的单元地址成为该变量名的左值，而把一个名字的值成为该变量名的右值。

90，下列的转换是否合法：int n = 0; int i = &n; 
答案：
不合法，在C++中不允许int和指针的直接转换(包括int到指针和指针到int)，如果没有进行自己的转换就直接进行赋值会编译通不过。但是指的注意的是这个问题在C语言中只是一个警告，也就是编译是ok的。

91,关于自增自减，下面的输出结果是什么
	void main(){
		int a, b, c, d;
		a = 5;
		b = 5;
		c = (a++) + (a++) + (a++);
		d = (++b) + (++b) + (++b);
		printf("a=%d, b=%d, c=%d, d=%d\n", a, b, c, d);
	}
分析与结果：
在这道题的书的说明上，说在VS2010中的结果是8,8,15,24，而在vc6.0 Dev-C++ gcc中的结果是8,8,15,22。也就是说这样写代码的结果可能是不同的编译器可能处理的可能不同。
在上面的说明的基础上，进行下面的分析：相加
前置的++是在表达式参与计算之后再对变量++，所以c中是5 +５+5 然后进行三次a的自加。而d中是先进行三次b的自增然后计算d的值 8 + 8 + 8。
关于gcc和dev中的结果是22的分析如为：由于汇编（将汇编代码转为二进制）的时候只能进行两个数的相加，所以(++b) + (++b) + (++b)被解释为(++b) + (++b)的结果(b两次自增变成7然后7 + 7)然后与 ++b进行相加，所以最终的结果为 14 + 8。这个解释虽然通了，但是同样的解释如果使用到c的计算那么就是10 + 7。而实际的结果又不是这样的。再次说明了这种书写的方式是不可预见的（对于不同的编译器结果可能不同），应该规避这种写法。例如d的计算可以修改为下面的形式：	
	++b;
	++b;
	++b;
	d = b + b + b;  //这样语意就是清晰而明了的

92，前置自增与后置自增的区别
答案：
前置自增表达式的值是变量自增之后的结果，实际操作的过程是取变量的地址将变量自增然后将自增之后的值送去寄存器。后置自增是取变量的地址，将值送入寄存器，然后增加内存中变量的值。由于++i是将i自增然后送去寄存器，所以++i是可以用作左值的，这个地址还是i。而i++首先将i的值送入了寄存器，然后将内存中的i的值进行自增，所以i++这个表达式的是一个临时变量，所以只能用作右值。


93，临时变量是否可以用作左值
答案：
不可以.C语言和C++中规定临时变量只能当初纯右值，不能当做左值使用。

94，下面的表达式是否合法： ++i+++j  i+++j++
分析与答案：
首先后置++比前置的++的优先级更高，然后它们比加法运算的优先级高。
++i+++j运算可以解释为 （++(i++)）+j。对于 ++(i++)，由于i++保存在一个临时变量中，是一个纯右值，所以不能进行前置++。这个语句是错误的。
i+++j++这个语句可以解释为 (i++)+(j++)，这个语句是正确的。

95，下面的if判断是否成立:
	if(2 < 3 < 2){}
答案：
逻辑运算中的比较和&& || 都是从左往右进行结合的。另一个要点是逻辑运算的结果是一个bool类型的临时变量。所以 2 < 3 < 2这个表达是可以解释为(2 < 3) < 2 结果是 1(bool类型的true) < 2 结果返回true。
注意，正因为上面的分析，所以如果要判断一个变量是否存在在两个变量之间，一般不能使用这样的连续比较而是应该使用 if(little < j && j < large)

96,一个文件中存在一系列的成对出现的数据，数据类型为int，由于某一次错误的操作，导致错误删除了一个数据。如果判断是删除了哪一个数。
答案：
可以使用一个hash映射，遍历这个文件中所有的记录，hash的值是存的是一个记录的是否存在的状态。遍历的过程中，如果一个记录已经存在就设置为不存在，如果不存在就设置为已存在。这样最后遍历这个hash，获取状态为存在的数据。这个算法是线性的，问题在于如果数据量和数据范围很大，hash不好构建，另一方面，数据量很大的时候空间开销可能也是一个问题。不过这个实现方案有一个好处，就是可以找到所有的没有配对的单个数据（如果被误删的不止一个呢）。
另一个思路是通过异或运算。因为任何的元素与其自身进行的异或都是0，任何元素与0的异或都是其自身。基于这一点，可以遍历所有记录，然后进行异或运算，最终留下的值就是单个的没有配对的记录。这个算法的空间开销都是O(1)而且也是线性的。可能出现的问题是如果被误删的记录不止一个，那么这里的最终的结果就是多个没有配对的结果的异或的结果，而这个结果不是最终想要的（所以这种思路，在实际使用中可能会比较窄，因为要基于一定的前提，否则会误判）。

97,一个数组的长度为n-1，保存的数据是1~n之间的n-1个数，每个数据各不相同。现在要求判断出，哪一个1~n之间的数据没有被保存。
答案：
可以先计算所有的1~n之间的数据的异或的结果，然后遍历给定的数据，将其中的数据与这个结果进行异或运算，最终留下来的那个数就是没有被保存的数字。

98，使用逻辑运算实现加法器
答案：
逻辑运算实现加法器的思路为：如果两个相加的数相与的结果是0，那么也就是说两个数没有同一位都是1的情况，也就是说不存在进行的问题。这个时候两个数相加的结果就是两个数的异或（因为对于任何一位只有可能存在一个数字是1或者是全0）。如果这两个数相与的结果不是0，那么说明存在进位，这个与的结果是1的位表示这个两个数的这一位都是1，那么把两个数与的结果左移一位就应该是产生的进位。将进位 +　没有考虑进位也就是两个数的异或　＝　最终的两个数的和，这里进入了一种递归表述，这个递归的base是两个相加的数其中有一个为0（这个数也就是充当了进位）.
实际编码改进：
	1）实际编码的过程中，发现一个问题，就是关于api的设计思路。如果直接写一个递归充当这个加法器函数，那么哪一个是与的结果哪一个是异或的结果，就会是确定的。而对于一般的加法运算，这个两个运算数的顺序应该是无关的。一个最直观的结果，如果直接这么设计加法那么 0 + 100 和 100 + 0内部的执行效率是不一样的。例如如果把与结果放到第二个参数，那么100 + 0直接就可以结束计算，而0 + 100需要多进行一次递归（尽管在这里计算量并不是很大，但是这里指出这种设计可能存在一些调用不均衡的问题）。所以这里改进的算法将递归放到加法器的内部调用。
	2）更一般的算法，可能需要进行无限个数字的相加（不考虑溢出），这里也给出相应的实现
个人改进之后的计算两个数相加的代码如下：
	/*
		递归计算两个数的异或与两个数的与的和
	@param int _xor 两个数异或的结果
	@param int _and 两个数与的结果
	@return int  返回两个数相加的结果
	*/
	int AddXorWithAnd(int _xor, int _and){
		if(!_and)
			return _xor;
		return AddXorWithAnd(_xor ^ _and, (_xor & _and) << 1);
	}


	/*
		改良后的算法实现：用逻辑运算实现加法器
	@param int a 被加数
	@param int b 加数
	@return int  返回两个数相加的结果
	*/
	int PlusImplementedWithLogicImproved(int a, int b){
		if(!a)
			return b;
		if(!b)
			return a;
		return AddXorWithAnd(a ^ b, (a & b) << 1); //移位运算符优先级 > 逻辑运算符 > 位运算符。所以这里需要将(a & b)括起来
	}
计算多个数相加的代码：
	/*
		利用逻辑运算实现多个数相加
	@param int a 第一个加数
	@param int b 第二个加数
	@param int ... 后续更多的加数，如果有的话
	@return int 多个加数相加的结果
	@note: 从第三个参数开始如果传入了一个参数为0就表示停止计算。所以这里会有两个影响，一个是如果传递了多余两个参数，那么最后一个参数一定要设置为0(额外的终结标志)，否则可能会计算到了垃圾值；另一个问题是这个函数需要对传递的要计算的参数进行过滤，保证在最后一个元素之前不能出现0，否则会漏掉元素.
	*/
	int MultiPlusImplementedWithLogic(int a, int b, ...){
		int result = PlusImplementedWithLogicImproved(a,b);
		va_list va;
		va_start(va,b);
		int next;
		while(next = va_arg(va,int)){
			result = PlusImplementedWithLogicImproved(result,next);
		}
		va_end(va);
		return result;
	}

99，说明利用...实现可变参数传值的使用。
答案：
C/C++中都是通过...表示参数的个数是可变的。C语言的默认调用方式是cdel，会对形参从右往左进行入栈，C++中默认的调用范式stdcall，会进行参数的逐个(从左往右)传递。所以在C语言中会将...和前面的参数都压入一个栈，而在C++中会将前面you名字的参数逐个传递，然后将后面的...从右往左压栈，也就是fastcall的调用。
在C/C++中使用va_start va_arg va_end 这三个（宏）函数进行可变参数的取值。具体的大致代码如下:
	va_list args;
	va_start(args,x); //其中x是...前面的一个参数的名称，由于va_start是宏，所以直接获取到x的地址，然后在这个基础上进行
	利用参数的个数或者使用特定的哨兵元素进行控制循环进行 va_arg(args, int)一次取出每一个的int元素
	va_end(); //取完元素之后应该调用，否则可能出现栈不能正常恢复

100，关于移位运算，对于有符号的数和无符号的数有什么区别
答案：
无论是有符号还是无符号，如果左移，那么低位都是补0.
对于有符号的数进行右移位，会在高位补充符号位。而对于无符号的数进行右移高位统一补0.例如，对于下面的循环，如果变量i是无符号的循环可正常终止，如果i是有符号的，由于符号位是1，那么向右移的过程中会不断的在高位补1，最终导致程序陷入了死循环。
	while(i >> 1){ dosomething;}
	

101，两个整数，如果要把A转换成B，只要需要修改的二进制位数怎么计算
答案：
只有两个数的某一位不相同的时候才需要进行修改，两个数的不同的位的个数恰好就是这两个数异或的结果中1的个数。所以方法就是将这两个数进行异或，去其中的1的个数。关于如何取得一个整数中的1的个数，可以从下面的思路进行思考：


102，设计一个函数，实现以下功能：两个整数M、N，要求将M的第i~j位替换为N，其中N的长度为j-i+1.
分析：
(1 << (i-1)) - 1 可以获取到第1~i-1位的全0。同样的，(1 << j) - 1 可以获取到的j为的全0，使用~0可以获取到所有位都是全0，然后用这个结果减去(1 << j) - 1 可以获取到第j+1到最高位的全0。利用上面的分析可以将M的被替换位的前后的数据取出来。然后与m << (i-1)与前后的数据进行或运算就可得到最终的结果。
具体的代码：
	/*
		将一个数据的第i~第j为替换为另一个数
	@param int m 要被替换的数据
	@param int n 用来替换原来数据的数
	@param int i 要被替换的低位
	@param int j 要被替换的高位
	@return int 替换之后的结果
	*/
	int updateBits(int m, int n, int i, int j){
		int high = ~0 - ((1 << j) - 1);
		int low = (1 << i - 1) - 1;
		int mask = low | high;
		return m & mask | n << (i-1);  //注意算术运算符优先级 > 移位 > 位运算的& > 位运算的|
	}

103，设计一个函数，将一个整数的奇数位与偶数位进行替换
分析与答案：
奇数位左移就偶数位，偶数位右移就是奇数位。当然这个分析的前提是这里的“整数”的位数是偶数，而这个在计算机中是成立的。使用与0x55555555相与可以取出一个整数的奇数位，使用与0xaaaaaaaa相与可以取出一个数的所有的偶数位.
大致代码：
	/*
		将一个int的奇数位与偶数位进行替换
	@param int n 要被处理的int
	@return int 替换之后的数据
	*/
	int ExchangeOddEvenBits(int n){
		int odd = sizeof(int) < 4 ? 0x5555 : 0x55555555; //这里的必要性并不强，因为只要保证提供的数据的长度不小于int的长度就行，因为如果溢出会进行低位截断。（那么，在现有通用的环境下，直接写成0x55555555也就是ok的）
		int even = odd << 1;
		return (n & odd) << 1 | (n & even) >> 1;
	}


104,C++中类型转换有哪些
答案：
包括赋值转化 表达式转换 和显示转换 其他类型转换(例如逻辑运算的 && || !等的操作数只能够是bool，所以存在隐式的转换)
赋值转换：
将一个不同类型的值赋给另一个变量，在编译器允许的情况下会出现一个隐式的转换。在赋值转换中，如果是所占字节少的数据赋值给占用字节多的数据，会出现高位补充符号位的扩展，如果是右值是无符号的高位会补充0。如果是所占字节数多的转换给占用字节数少的变量，会截取低位的字节数据进行赋值。例如 short int x = 0xffff0fff;那么x的数据为0x0fff（这个结果是在小端机器上的分析，如果是大端就是0xffff）。
表达式转换：
在一个表示中计算数类型不同，在计算之前一般会将表达能力的小的数据提升位表达能力更强的类型（达到一致）。在所有的表达式计算中，凡是没有超过int的表达能力的都会转换为int。如果出现与int的长度一样但是是unsigned的(例如在有的机器上short与int一样长)，那么会转换为unsigned int。对于int和超过int的表达能力的类型他们的表达能力顺序为: int  < unsigned int < long < unsigned long < float < double < long double


105,32位的机器上下面的赋值之后 a、b、c三者之间是否相等
	signed char  a = 0xe0;
	unsigned int b = a;
	unsigned char c = a;
结果:
	a != c  a==b  b != c
分析：
a是0xe0, 对于表达式unsigned int b = a;所有的小于int的表达能力的先转换为int也就是表达式右边的a首先转换为0xffffffe0，然后转换为unsigned int，内存中的数据不发生改变。unsigned char c = a; c与a的内存结构相同，只是解释不一样，c的最高位也是数据而不是符号位。 
先判断 a==c,因为二者的内存结构一样，但是进行除了像&& || 的逻辑运算之外的其他运算的时候都会提升为int，这个时候由于a是有符号的会被提升为0xffffffe0 而c是无符号的会在高位填充0也即是0x000000e0，可以发现二者的内存结构并不相同，也即是a != c
判断a==b，a在计算的时候会提升为int，内存结构和b完全一样，所以二者是相等。
判断b==c, 通过上面的分析，其实已经知道了b与c不等。具体的c是unsigned char会先提升为int，高位进行补0.然后与b进行比较，可以发现二者的内存结构是不一样的。


106，double float的类型存不存在 unsigned
答案：
不存在，float和double的内存表示是： 最高位的符号位  +　８位/11位阶码 +　其余的为尾数.

107，比较优先级： [] () . -> 前置++  后置++ *(取值) &(取址) sizeof
答案：
[] () . -> 的优先级一样，是所有的运算符的中优先级最高的，结合的方向是从左到右
后置++ 比前置++的优先级高
前置++  取值 取址运算符 sizeof属于同一个优先级，结合的反向是从右往左.


108，在gbk表示的字符串中，中文字符用两个字节表示，其中第一个字节的高位是1。下面的代码是把一个可能存在中文字符的字符串中的大写字母转换为小写字母。请检查其中的bug。
	for(char * p = szWord; *p != 0; p++){
		if(*p & 0x80 != 0)
			p++;
		else if(*P >= 'A' && *p <= 'Z')
			p += 32;
	}
分析与答案：
第一个问题是 *p & 0x80 != 0 这个if中的判断，这个语句中由于逻辑!=的优先级要比位操作的优先级高，所以这个表达式的解释为 (*p) & (0x80 != 0)，&后面的表达式的结果是true也就是1，然后进一步的计算会扩展为int的1与前面的扩展为int的*p进行按位与。上面的分析可以发现这里的逻辑由于优先级的问题导致了明显的不对。所以正确的写法应该是 if((*p & 0x80) != 0)。
另一个问题是显而易见的，下面的  p+= 32，应该改为 *p+= 32
----note： 一般优先级分析： () > 后置++ > 前置++ > 算术运算符 > 移位 > (逻辑<) > （逻辑==） > 位运算 > 逻辑与和逻辑或  > 三元 > 赋值  > 逗号

109,下列语句执行之后，x的值是多少
	int x = 4;
	x += x- = x - x--;
分析：
对于后置++和后置--都是在整个表达式计算完成之后才进行。这里的先计算 x-- 然后计算 x - x-- = 0,然后从右往左结合进行赋值x - = 0表达式的值还是x, x+=x之后x为2*x = 8。最后整个表达式计算完毕，进行一次x--，可得到x=7。
实测修正：
上面的分析在VS中测试是有效的，但是在GCC环境下进行测试的结果是8。个人的分析是GCC中对于表达式x += x-= x - x-- 不是一次考虑整个表达式的，是先考虑的子表达式x-= x - x--，而且这子表达式先执行了x--，之后x成了(x-1)，x - x--成了-1，所以这个子表达式的效果是x-=-1，结合前面的x--，所以x又成了原始的x。然后分析表达式x+=x得到结果8.

111,下面的运算是原子操作吗： x=y  x++ ++x  x=1
答案：
除了x=1是原子操作，其他的都不是原子操作。在VS中查看到的相应的汇编指令为
对于x=y这个赋值的操作对应两条汇编指令：
	mov eax, dword ptr [y]  //将y载入寄存器
	mov dword ptr [x], eax  //将寄存器中的值送入x对应的内存
对于x++和++x的操作，对应的汇编指令都为：
	mov eax, dword ptr [x] //将x载入寄存器
	add eax, 1 //对寄存加1
	mov dword ptr [x], eax  //将寄存器中的值写入x对应的内存
对于x=1对应的汇编指令:
	mov dword ptr [x], 1  //直接把一个立即数送入x对应的内存。这里对1是立即寻址

112，下面的四个语句中a和b最终的结果是相等的有哪些
	int a = x + y -z, b = x -z + y;
	int a = x*y/z, b = x/z*y;
	int a = x<<y>>z, b = x>>z<<y;
	int a = x & y | z, b = x|z&y;
分析：
只有第一个表达式中a与b相等，其他的都可能不相同。
1）对于一个加一个减，虽然可能存在中间结果溢出，但是最终的运算结果是一样的，加减的运算符优先级相同，结合方向都是从左到右。
2）对于乘除运算，这里如果是浮点型或者double型计算，那么结果应该也是相同的的，但是这里是int型的计算，如果是先除法那么会由于向下取整转成整型可能最终的结果与向计算乘法的结果相比小一些。
3）对于移位运算符结合的方向是从左到右。如果是先进行左移，那么可能将下面的某一位移到了符号位，然后进行右移会进行符号位的填充，这个结果与先进行右移可能不一样。另一方面，如果先进行右移，抹除了原来的有效位然后再进行左移由补充上0（例如对于1先右移3位然后再左移3位结果为0，如果是先左移3位然后再右移3位得到的还是1）.
4）对于位运算符 & 的优先级比 | 的优先级更高，二者都是从左到右进行结合的，所以x & y | z 可以解释为（x & y） | z 而x | z & y可以解释为 x | (z & y)。从语意上其实已经不同了。


113,有一种计算机，其中只存在以下的原子操作：
	1）赋值a=b
	2）+1操作,++a和a+1
	3)指定循环次数的循环for(变量){//循环中对于变量的修改不会在改变for里面的循环的次数了。}
	4) 只能处理0和正整数
	5）函数调用func(参数列表)
问题：使用伪代码在以上的给定环境下实现加法、减法和乘法。
分析：
由于只要+1的操作和赋值，可以从控制循环的次数入手思考问题.把一个变量0先自加a次然后再自加b次就是a+b(或者直接将一个变量直接赋值为a然后让a自增b次)。写一个嵌套的循环外层循环a次内层循环b次，那么一个初始化为0的变量在这个循环中的经历了a*b次的自加最后得到乘法器。对于减法器我们可以考虑首先实现自减1运算，for(a){b=i;++i;}这样就可以记录下i最后一次自加之前的值，而经过最后的一次自加i成了a，那么之前的那个值就是a-1。实现了自减的操作的基础上，接下来无非就是将一个变量赋值给a，然后让a自减b次就得到了a-b。


114，一个整型，如何判断这个整数的二进制位中存在多少个1
分析与答案：
可以通过对1 << n，然后将这个结果与要判断的数字进行与运算取出整数的第n+1位数，然后判断是否是1。当然也可以每次都和1与运算而是把这个整数进行右移，只是这个时候要注意一定要将这个整数转换为unsigned的类型，否则如果是一个负数，那么右移高位补充的是符号位，会导致结果不正确。
通过1左移的算法如下：
	/*
		使用1不断进行左移法：获取一个整型的二进制位中的1的个数
	@param int n 要获取的整数n
	@return int 整数n的二进制数据中1的个数
	*/
	int Get1InBits1(int n){
		unsigned int x = 1; //因为是左移，这里的x是否有符号其实不重要
		int result = 0;
		//下面的循环中条件是x不为0，也就是当x移位过程中将唯一的1移出去了，循环结束
		while(x){
			if(n & x)
				//当前位是1，计数器加一
				result++;
			x <<= 1;
		}
		return result;
	}
通过将整数右移的算法如下(可以直接将形参的类型设置为unsigned)：
	/*
		使用输入的整数不断右移法：获取一个整型的二进制位中的1的个数
	@param int n 要获取的整数n
	@return int 整数n的二进制数据中1的个数
	@note: 这里的参数类型是unsigned int，因为如果是signed在移位的过程中会补充符号位。如果这里的形参不是unsigned一方面可以在内存再转换为unsigned，另一方面如果知道机器上的int的长度可以直接用这个长度控制移位的次数，但是这样书写不便于在不同的机器上进行移植
	*/
	int Get1InBits2(unsigned int n){
		int result = 0;
		while(n){
			if(n & 1)
				//最低位是1，计数器加一
				result++;
			n >>= 1;
		}
		return result;
	}
另一个有技巧的实现方式是将n &= (n-1)一直到n为0，n不为0的循环执行次数就是整数n中的1的个数。上面的算法之所以正确的，原因是每一次n &= (n-1)都会消掉从低位到高位的第一个1（n-1的结果是这个1的左边位不变，右边位都变成1(注意一点原来其右边的位都是0)，而其本身变成了0，所以n & (n-1)的结果就是消掉从低位到高位的第一个1）算法的实现代码如下：
	/*
		使用n & (n-1)法：获取一个整型的二进制位中的1的个数
	@param int n 要获取的整数n
	@return int 整数n的二进制数据中1的个数
	@note: 解析： 考虑n中从低位到高位的第一个1，n -1获取到的结果中这个1的左边的位都不变，右边的位都由0变成了1，而这一位其本身由1变成了0，所以每次的 n & (n-1)都是消掉n的从低位到高位的第一个1
	*/
	int Get1InBits3(int n){
		int result = 0;
		while(n){
			result++; //每次循环消掉了一个1
			n &= n-1;
		}
		return result;
	}

115, 结构体S定义如下
	struct S{
		int a;
	};
	S s;
	S *p = &s;
	判断 *p.a = 1 是否合法，为何
分析与答案：
不合法，原因是运算符 . 的优先级比取值运算符*的优先级要高，所以这个表达会*p.a会先计算p.a，由于p是一个指针，所以这里. 运算符的使用不合法。正确的写法应该是 (*p).a 或者直接写p->a


116,如何将float与0进行比较
答案：
float和double一个有6位有效的小数，另一个有10位有效小数。由于这个表示的精度的问题，所以如果进行float的直接比较一般会不准确。如果要判断 float与0的关系正确的写法是 if(f > -1e-6 && f < 1e-6)，要比较double与0的关系正确的写法是 if(d > -1e-10 && f < 1e-10)。注意，不能书写成 if(f == 0)或者是if(!f)，因为这个判断是不准确的。

117,一个整数的序列中，除了两个数字只出现1次之外，其他的数字都成对的出现。要求在时间复杂度为O(n)空间复杂度O(1)的条件下找出这两个数字.
分析与答案：
将整个的序列进行异或的运算，最后留存下来的结果某一位为1表示这两个数字只有一个在这一位是1（由于这两个数字并不完全相同，所以最后的结果一定不会完全抵消）。可以将最后留下来的这个结果的最低位的1当做区分这两个元素的标志。利用这一位可以将原来的整个序列分为两个部分，并且要寻找的两个数字各属于不同的部分。由于其他的元素都是成对的出现的，所以在分成的这两个部分中，它们依然是成对出现的，然后再在这两个子序列中执行前面说的异或运算就可以分别得到这两个数字了.
找到这两个数字的代码:
	/*
		找出一个整型序列中只有两个没有成对出现的元素
	@param int arr[] 输入的整型序列
	@param int length 序列的长度
	@param int &res1 用于接受要返回的结果数字1
	@param int &res2 用于接受要返回的结果数字2
	*/
	void Get2NoMatchInArray(int arr[], int length, int &res1, int &res2){
		assert(arr && length >= 2); //length如果为1下面的结果会出现一个是为这个元素本身，另一个是0
		int result = 0;
		//获取整个序列中所有的数字进行异或运算的结果
		for(int i = 0; i < length; ++i)
			result ^= arr[i];
		int unique = 1;
		//获取可区分最终两个数字的从低位到高位的第一个1
		while(unique && !(unique & result)){
			unique <<= 1;
		}
		if(!unique){
			//没有找到可区分两个数字的某一位1，说明整个序列进行异或运算的结果result是0。判断为给定序列错误.这里考虑打印错误日志，但是对于api调用来说这里合理的做法应该给出一个调用异常(C++异常个人使用不习惯)
			std::cerr << "the sequence given does not contains two different numbers that do not equal to others" << std::endl;
			return;
		}
		//找出区分位为1的结果和区分位为0的结果
		res1 = 0;
		res2 = 0;
		for(int i = 0; i < length; ++i){
			if(unique & arr[i])
				res1 ^= arr[i];
			else
				res2 ^= arr[i];
		}
	}

118，C/C++中的复合语句指的是什么
答案：
复合语句就是指的被{}包裹起来的语句，在复合语句中定义的变量只能在复合语句中可见，这一点和很多其他的语言有所不同。

119,data段与bss段有和不同
答案：
data段是存放初始化了的全局和静态变量。而bss（Block Started by Symbol）段是存放没有初始化的全局和静态变量。bss中的数据会在程序执行之前清空为全0。

120，C预处理器包括哪些部分，都有什么作用
答案：
包括宏定义与宏替换、文件包含、条件编译三个部分。
宏定义包括常量的宏定义和带参数的宏定义。由于预处理是在编译之前进行的，所以宏替换是不会进行语法的检查的。并且宏定义不会分配内存，因为是文本的替换不会涉及变量的定义。在C++中应该使用const、enum对define常量的宏定义进行代替，而带参数的宏替换可以使用模板内联函数代替。
文件包含的使用形式是#include <> 或者是#include "" 其中前者会被认为是标准头文件，会到预定义的位置集合中查找该文件，后者会被认为是非系统文件，其查找是开始于源文件所在的路径。
条件编译可以根据不同的编译条件产生不同的目标代码，其作用是便于调试和移植。主要的格式为  #if/ifdef/ifndef #elif #else #endif

121，宏替换的函数与普通的函数有什么区别
答案：
宏替换本质上文本的替换。宏替换是在预编译阶段不会进行语法的检查，宏替换不会分配内存，而普通的函数是在编译之后程序运行时分配内存。宏替换会使源程序变长，而函数不会，宏替换占用的是编译时间而函数调用(分配内存、保留现场、值传递、返回值)占用的是运行时间.
----在c++中应该尽量避免使用#define的形式定义常量，常量的定义可使用const或者enum代替，待参数的宏定义可使用内联函数代替.

122，使用头文件包含的方式和使用extern包含的方式使用主要的区别在哪里
答案：
使用头文件包含的方式，如果头文件中没有找到变量的定义会在编译阶段报错，而使用extern引入，如果程序中没有这个变量的定义，在编译的阶段不会报错，而是在链接的阶段报错。


123, 下面的代码会输出什么内容
	int tt = 1;
	int main(){
		cout << tt << endl; //打印的结果是1 运行到这局部的变量还没有对全局的tt进行屏蔽
		int tt = 2;
		cout << tt << endl; //2，新定义的tt对全局的tt进行了屏蔽
		return 0;
	}
分析：
第一个输出的时候，局部变量还没有定义，没有对全局的变量进行屏蔽，所以输出的是全局变量.

124，在局部变量已经屏蔽了全局变量的前提下，如何使用全局变量
答案：
可以使用::或者是extern再次申明一下这个全局变量，那么接下来使用的就是这个全局变量了。

125，static关键字有什么作用
答案：
1）对于全局变量和函数，使用static修饰，可以修改他们的可见性，由全局可见变成了对其他的源文件隐藏而只在当前文件可见，利用这一特性可以在不同的源文件中定义同名的全局变量和函数。
2）对于变量，static会进行默认的初始化为0（没有初始化的全局变量和static变量存在bss中，在程序运行之间bss会进行清零）
3)static可以保持局部变量内容的持久性，static的局部变量只进行一次初始化，生存周期是整个源程序，下一次调用的初始值是上一次的状态值。
4) 在类的成员变量与方法上加static，表示他们不属于单独某一个特定的对象，而是属于这个类，被所有的对象共享。静态的数据成员也是存放在全局与静态变量区。static的数据成员必须在类的外部进行一次定义，因为在类的定义体中不能直接初始化赋值，而static的变量又不属于某一个特定的对象，又不能使用构造函数初始化。不过这里有一个特例，就是基本整型(bool char short int long)的const static变量是可以在类的定义体中进行初始化，这样定义了给属于类的常量，但是即使这样，还是需要在类的定义体的外面进行定义，但是不需要在定义的时候初始化。

126，全局与静态变量区分为哪两个部分
答案；
分为data段和bss(blocks started by sysmbol)段，其中data段是存放初始化的全局与静态变量，而相邻的bss段是存放未初始化的全局与静态变量，bss在程序运行之前会进行清零，所以未定义的全局与静态变量会默认初始化为0.

127，下面的语句是否正确
	class base{
		1)virtual static void func1();
		2)static void func2() const;
		3)static void func3() volatile;
	}
分析：
三个语句都是错误的。
static关键字使用在类中，表示一个属性或者方法属于类，被所有的对象所共享。而const和volatile使用在方法上，是修饰这个成员方法是否可以修改调用它的对象的属性，默认是volatile的。通过这个分析，由于const和volatile的都是修饰成员方法的，所以不能用在static修饰的表示类的方法上。virtual表示一个方法是虚方法，是用来支持多态的，而多态是基于对象的转换分析，所以virtual也不能和static同时修饰一个类的方法。


128,C语言中的const与C++中的const有什么区别
答案：
C语言中const是修饰一个变量，只是这个变量不能更改，因为是变量，所以在编译期间没有分配内存，不能当做常量使用。而C++中的const是用来定义常量的，这个常量可以在编译器期间直接使用（例如用作数组的长度等）。C语言中const变量默认是外部连接的，也就是说C中const修饰的全局变量是整个程序可见的，而C++中的const修饰的常量默认是内部连接的，也就是默认const修饰的全局变量是本源文件可见的。C++中如果要将const修饰的全局变量定义为全程序可见，可以使用exern修饰。

129,C++中使用const定义的常量和#define定义的常量有何区别
答案：
宏定义的常量本质上是文本替换，所以不会进行内存的分配，而C++中使用const定义常量在编译期间会分配内存。
宏定义的常量没有类型，所以没有类型的安全性检查。
宏定义的常量由于是进行文本替换，可能会导致目标代码变长，而const定义的常量没有这个问题，并且有的编译器会进行常量折叠，将常量表达式求值放入常量表。


130,下面的语句是否正确
	char * const a[2] = {"hello","world"};
	a[0] = "test";
分析：
第一个语句定义了两个指针，由于const放到了*的后面所以是修饰这两个指针的，也就是说这两个指针不可修改，所以第二个语句是错误的。


131,执行下面的test函数会输出的是什么
	char * GetMemory(){
		char p[] = "hello world";
		return p;
	}
	void Test(){
		char * str = nullptr;
		str = GetMemory();
		printf("%s",str);
	}
分析：
p是一个局部的数组，进行返回之后会被销毁，所以返回之后的打印的结果不可知，可能是乱码。

132，下面的调用是否正确
	void f(int &);
	f(1);
分析：
不正确，f(1)调用的时候，编译器会为1分配一个临时存储单元，然后将它赋给一个int&。由于临时存储单元是const的，所以不能赋给非const的const&引用。所以这里会报编译错误。如果函数的形参是const int &那么这种调用是正确的。同样的错误还有f(string &) f(string("hello"))，形参传递的也是一个临时对象.

133，const在类里面如果修饰了成员变量应该如何初始化。下面的两个方法是否构成了重载
	class Base{
		void print();
		void print() const;
	}
分析：
1）对于const修饰的成员变量，必须在构造函数的初始化列表中进行初始化，如果是基础数据类型（bool char short int long double float）可以在类的定义体中进行初始化。如果整型（bool char short int long，实际测试浮点型也是可以的）的const同时被static修饰，也可以使用外部初始化
2）上面的两个函数构成了重载，成员函数的内部隐式传递this指针，这个const是修饰在this指针上的，表示不能通过this进行相应的对象的属性的修改。如果一个对象定义的时候是const的，那么这个对象调用print将会调用第二个const类型的函数。

134,malloc与new、free与delete的区别
答案：
1）malloc和free是c/c++的标准库函数，使用的时候需要标准库的支持。new和delete是c++的运算符。
2）new是自动计算分配的空间，而malloc是手动的计算字节数。
3）new是类型安全的，而malloc不是。例如int *p = new float;在编译的阶段就会指出错误。而int *p = (int *)malloc(2*sizeof(double));在编译阶段不会检查出错误(分配错误了空间大小)。
4) new对于类类型会自动调用构造函数，而malloc没有这个功能(不仅如此，对于普通的类型，new的时候也可以指定初始化，例如int *i = new int(1)和 int *arr = new int[10](100)。但是如果是new一个对象数组，那么只能使用无参数的构造函数, Test *test = new Test[10](11)这个写法是错误的)。delete对于类类型会自动的调用析构函数，而free没有这个功能。


134，对于普通类型和对象类型，进行new的时候，如何指定默认初始化
答案：
对于普通类型，可以使用例如 int *p = new int(2);(如果参数没有指定，默认是0)进行初始化为2. 或者使用 int *arr = new int[2](). 对一个数组进行初始化。注意如果是对一个数组进行初始化，那么初始化提供的参数只能为空（如果是对象也就是调用默认的构造函数，对于普通的类型是初始化为0）。
对于类类型，可以指定调用的构造函数，例如 Test * p = new Test(); 或者 Test *p = new Test(11);但是如果是new一个对象数组，那么只能指定为无参的构造函数，例如Test *p = new Test[10]()


135，下面的代码有什么问题
	int *p = malloc(sizeof(int));
	free(p);
	free(p);
分析：
对于一个指针，如果是NULL的，那么无论进行多少次的free都不会出错。但是如果一个指针不是null的，如果进行第二次的free程序会出现运行错误。原因是在第一次的free之后这片空间已经不属于本程序了，如果再进行第二次的free就是释放一部分不属于自己的空间。

136，下面两个语句有什么区别
	int *p = new int;
	int *p = new int();
答案：
int *p = new int; 语句执行之后p指向的int存放的是一个垃圾值。而int *p = new int()使用了初始化，p指向的int被初始化为0

137，写一个宏，用于求解结构体内部元素的偏移地址
分析：
这里的思路是将结构体的首地址放到0，然后在这个基础上只需要得到相应的字段的地址就可
note:
1) & (((type*)0)->field) 并没有涉及到取值运算，所以这里不会出现崩溃的现象
2) 这一种思路，巧妙的在不创建任何的实际对象的前提下，计算出来了一个类型中各地段的偏移
具体代码：
	#define OFFSET(type,field) ((int)&(((type*)0)->field))

137,如何减少内存碎片。
答案：
内存碎片的产生是源于程序中频繁的申请内存，当存在大量的碎片的时候就会影响内存分配的效率。为了减少内存碎片，一般可以考虑使用一个内存池，也就是在真正使用内存之前，先申请分配一定数量大小相等的内存块进行备用。当有新的内存需求的时候，先查看内存池中的内存是否够用，如果够用，就先使用内存池中的内存。

138,什么是缓冲区溢出
答案：
缓冲区溢出指的是向缓冲区中填充的数据的长度超过了缓冲区的容量限制，导致溢出的数据覆盖在合法的数据之上。
 

139，下面的代码输出多少
	#define VAL1(a,b) a*b
	#define VAL2(a,b) a/b--
	#define VAL3(a,b) ++a%b

	int main(int argc, char* argv[]){
		int a = 1;
		int b = 2;
		int c = 3;
		int d = 3;
		int e = 5;
		/*
			下面的表达式解释为：
				a/b-- / e*b + ++c%d （C预处理器会在运算符的左右填充空格，而宏替换也是在预处理的阶段）
			带入各个值为：
				1/2-- / 5*2 + ++3%3 (注意这里的++3如果直接写是不合法的，3如果是一个立即数的话。这里只是为了表示清晰)
			= 1/10 + 4%3
			= 1
		*/
		int result = VAL2(a,b)/VAL1(e,b)+VAL3(c,d);
		cout << result << endl;
		return 0;
	}
分析易错点：
	C/C++的预处理器会在双目三目等多目运算符的左右填充上一个空格（如果程序员没有进行自己的填充）.

140，下面的函数定义是否有问题：
	int f() const{}
分析：
这种写法的const是用来修饰隐式传递的this指针的，所以只能用于成员方法上面。一般的方法中没有this，所以上面的函数会编译出错.


141，下面两个函数有什么不同
	const int f1(){}
	int f2() const{}
分析：
这个语句会报错：non-member function cannot have cv-qualifier，cv限定符指的是const和volatile.
f2的const的位置已经超出了参数列表的右括号，所以不可能修饰返回值或者是参数。这里的const是C++中对于成员函数的一种修饰规则，这个const是修饰在隐式传递的this指针上的，限定调用这个成员函数的对象不可以被修改。一般的函数（非类中定义的成员函数）是不能这么书写的，因为一般的函数里面没有this指针。f1中的const是用来修饰返回值的，表示返回了一个相应类型的常量。


142，强制转换的优先级与那些优先级一样
答案：
与负号 前置++ 取值 取址运算符等优先级一样。


143，不用va_list实现一个n个数的加法运算函数
分析：
va_list va_arg那一套底层其实就是在上一个参数的地址上进行设定的偏移，然后一次取出多少的字节的数据。所以程序中在控制好取数据的次数的前提下，可以自己操作指针。
具体代码大致为：
	/*
		实现n个数的加法
	@param int num 要进行相加运算的数字的个数，最小为1
	@param ... 多个要进行相加的数
	@return int 多个数相加的结果
	*/
	int Add(int num, ...){
		assert(num >= 1);
		//获取第一个数字的其实地址
		int *p = (int*)&num + 1; //其实就是下一个int
		int sum = 0;
		for(int i = 0; i < num; ++i){
			sum += *p++;
		}
		return sum;
	}

144,内联函数与宏定义函数的区别
答案：
宏定义是在预处理阶段进行代码的替换，而内联函数是在编译阶段插入代码。宏定义没有类型检查，而内联函数有类型检查。


145,下面的函数调用是否正确
	template <typename T> T add(T x, T y){
		return x + y;
	}
	add<float>(5.1,2);
	add(5.1,2);
分析：
第一个调用add<float>说明模板里面传入的类型形参是float，那么里面的两个函数形参会当做float进行处理。
第二个调用因为没有提供类型形参，所以编译器会根据传入的函数实参的类型进行相应的推断。第一个5.0会推断为double，而第二个2会推断为int，二者的类型并不一致，出现调用矛盾。

146，类模板和函数模板使用上最主要的区别是什么
答案：
函数模板在调用的时候，可以不用显式的提供类型参数，编译器可以进行相应的类型推断，进而生成一个特定的函数实例。而使用类模板的时候，在实例化对象的时候必须要显式的提供类型参数，编译器根据用户提供的特定类型编写特定的类，然后进行对象的实例化。

147，用递归的思路实现单向链表的反序打印
分析与解答：
先打印头节点后面的节点，然后打印头节点. 也可以使用一个stack，先遍历把值存起来，然后依次出栈打印
具体代码：
	template<class T> struct S
	{
		T value;
		S * next;
	};


	template<class T> void PostOrderPrintLinkedList(S<T> * s){
		assert(nullptr != s);
		//打印头节点的后面部分
		if(s->next)
			PostOrderPrintLinkedList(s->next);
		//打印头结点
		std::cout << s->value << std::endl;
	}


148，下面的两种写法有什么问题
	class Base{
		Base b(); //其中Base是另一个类
		Base b(11);
	}
分析：
上面的两种写法都是不正确的，第一个Base b()如果是要定义一个返回值为Base无参数的函数那么是可行的，但是往往大家这里是要定义一个名称为b的属性。第二个写法不正确是因为在类的定义体中除了一些基本的数据类型可以直接初始化外，对于这种对象类型的属性，只能放申明，而初始化应该放到构造函数里面，所以这里是申明，没有办法传递那个参数11，会出现编译错误


149，引用与指针使用的区别
答案：
引用在内存中的存储内容其实也是绑定对象的地址。但是与指针的使用略有不同
1）引用不能为空，在定义引用的时候需要进行初始化绑定到一个指定的对象。指针可以为空，在后面在进行赋值。
2）引用初始化为NULL，而指针可以。
3）引用一旦绑定到特定对象，进行了初始化，之后就不能修改为新的指向，而指针可以通过重新的赋值指向新的元素。
4）对引用进行操作不需要进行取值，而是直接使用，引用相当于绑定对象的一个别名。而指针如果要获取指向的对象需要取值操作。
5）对指针的++操作是作用在指针变量上的，而对引用变量的++操作是作用在绑定的对象上的。
6）如果对指针进行取址&，那么获取到的是存储这个指针变量的地址。对引用进行取址获取到的绑定对象的地址。
7）如果是返回动态分配的内存对象，只能使用指针，不能使用引用，因为不存在对引用的释放操作，如果使用引用传递，那么可能引起内存泄露。
8) 对引用进行sizeof的操作返回是绑定对象的大小，而对指针的sizeof返回的是这个指针变量的大小（一般为4）
9) 引用一旦初始化了，那么再对其进行赋值就是对其绑定的对象进行赋值。而对于指针如果进行赋值就是修改指针存储的地址，也就是让指针指向新的对象。


150，引用类型的数据成员在哪里进行初始化
答案：
如果是static的数据成员，那么应该在类的定义体外面，一般是在相应的源文件中进行初始化。如果是非static的成员属性，那么只能值在构造函数的初始化列表中进行初始化（对于所有的构造函数都应该添加相应的初始化代码，这是由引用类型的属性决定的)。这个初始化不能在构造函数体中进行，因为那里是赋值操作，而不是初始化操作，而对引用类型的赋值是作用在其绑定对象身上的。

151，下面的写法是否正确
	int ((*p)(double))(int);
答案：
不正确，这里定义了一个函数指针p，这个函数指针指向的函数的返回值是一个函数int ()(int)。在定义函数指针的时候，只有在形参中可以直接书写函数代替函数指针的书写格式，返回值不能写成函数类型，这么写不合法.正确的写法应该是int(*(*p)(double))(int)。注意 int (*p(double))(int)是定义了一个参数为double返回值为int (*)(int)的函数。解读这样的定义应该从里往外读。


152,下面的代码最后打印的结果是多少
	struct Base
	{
		int i;
		char c;
	};

	struct S
	{
		Base & b; //如果存的是引用，那么在实例化对象的时候必须要进行相应的初始化
		short si;
	};

	int main(){
		Base b = {110, 'c'};
		S s = {b, 2}; 
		cout << (int)&s.si - (int)&s.b << endl;
		return 0;
	}
分析：
	1）C++中引用数据类型的内容存储的是所绑定对象的地址，也就是说和指针类型存放的内容是一样的，所以引用类型的实际占用的内存空间的大小一般可以认为也是4。
	2）对引用变量进行取址操作，返回的是所绑定对象的地址，而不是引用变量的存储单元的地址
	3）一个函数中调用的时候，先是形参从右到左依次入栈，然后是内部定义的变量依次入栈。上面的代码中由于b先入栈，然后是s入栈，所以s的地址比b的地址小sizeof(s)=8。由于&s.b获取的是main中中变量b的地址，所以最终的打印结果是 (4 - 8) = -4

153，解释下面的构造函数中的两个m代表的是什么
	class Test{
		int m;
		Test(int m): m(m){}
	}
分析：
构造函数的初始化列表中所有的括号外面的变量都对应着一个成员属性。而括号里面的变量可能存在局部变量的屏蔽现象。所以这里的 m(m)外面是代表成员属性m，而里面的m由于存在传入的形参m对成员属性的屏蔽，所以这里代表的是传入的形参m


154,野指针是什么，造成野指针的原因有哪些
答案：
野指针就是指指向了不可用的内存的指针。造成野指针的原因主要包括：
1) 在定义指针的时候没有进行初始化或者赋值，
2) 在释放指针所指的空间之后没有将指针设置为NULL，
3）指针操作超越了变量的作用范围与生存期(例如使用一个指针指向一个局部变量然后返回)


155,下面的代码执行结果是什么
	class B
	{
	public:
		int i;
		B(int i){
			std::cout << "init B" << std::endl;
			this->i = i;
		}
	};

	class A
	{
	public:
		string s;
		int i;
		B b; //由于B没有定义默认构造函数，所以必须要在初始化列表中初始化
		A():b(5){
			std::cout << "init A" << std::endl;
		}
	};

	//全局对象在bss段中，对于没有初始化的部分会置零
	A g;

	int main(){
		cout << "enter main..." << endl;
		cout << g.i << "..." << g.s << "-----" << g.b.i << endl; //由于在全局的bss中没有被初始化的部分是0，所以g.i是0，g.s使用默认的构造函数是空字符串
		A a; 
		cout << a.i << "..." << a.s << "-----" << a.b.i << endl; //i是垃圾值  s是空 b.i是5
		return  0;
	}
分析：
	1)初始化列表是真正的初始化，而构造函数体是初始化之后对各个成员变量的赋值。
	2)初始化列表的执行顺序与初始化列表的书写的顺序没有关系，只与各个成员在类的定义体中的定义顺序有关。
	3)对于全局的对象，如果一个属性没有在构造中初始化或者赋值，那么会被默认初始化为0，这是bss段的属性导致的。

156，有哪些情况必须在初始化列表中初始化成员
答案：
1）引用类型成员
2）没有默认构造函数的类类型成员
3）const成员


157，下面的语句构造函数调用了几次
	string s1 = "hello";
	vector<string> arr(5);
分析：
1）s1的定义中，首先是使用const char* “hello”构造了一个临时对象，然后利用调用拷贝构造函数利用这个临时对象初始化s1
2）arr定义了一个有五个string元素的容器（注意，在申明对象的容器时，只能使用默认的构造函数，因为这的括号里面提供的是容器的初始化大小，没有办法再指定构造函数了）。在内部的实现是先调用默认的构造函数初始化一个临时对象，然后利用这个临时对象进行拷贝，初始5个元素。所以这里的构造函数一共使用了6次。


158，下面的语句有什么问题
	class A{
		int i;
		A(const A a){
			this->i = a.i;	
		}
	}
分析与答案：
这里定义了一个拷贝构造函数，但是参数不能是类类型而应该是类类型的引用，因为如果是类类型，那么在这个拷贝构造被调用的时候实参向形参进行赋值初始化的时候又会调用拷贝构造函数，这样就形成了死循环（无限递归）


159，用大括号括起来的表达式能否用来给class定义的对象初始化
答案：
class和struct基本一样，分析也是一样的。测试中发现的主要的问题是以下三个：
1）通过测试，如果构造函数存在初始化列表不能使用{}对对象进行初始化
2）如果不存在初始化列表，那么即使构造函数是有参数的情况，也可以直接使用{}进行对象的初始化
3）这里还发现一个问题，就是存在引用类型的成员，不提供任何的构造函数(如果用户提供了，即使是无参的，那么也得在初始化列表中对引用类型的成员进行初始化)，也可以使用{}进行初始化（但是如果直接构造，那么就是没有初始化，因为调用了默认的构造函数，而默认的构造函数中没有进行引用变量的初始化）。对于这种存在引用类型的成员却不提供任何的构造函数的编译合法性（尽管实例化的时候不能直接构造）是不是优化的结果尚不清楚


160，为何一个类存在子类，这个时候要把其析构函数定义成虚方法
答案：
因为可能存在用基类对象的引用接受子类对象new的空间，这个时候如果父类的析构函数不是虚函数的，那么在析构的时候只会执行父类的析构函数，这样导致子类单独申请的空间没有被释放掉.

160，什么是合成析构函数，有何作用
答案：
在对象的析构的时候，先执行用户定义的析构函数，然后运行合成析构函数，合成析构函数的作用是按照创建对象时候的逆序去撤销每一个成员的空间，对于类类型成员，会自动调用成员的析构函数进行资源的释放（也即是如果一个类中存在对象成员，那么先执行这个类的析构，然后按照定义的逆序执行成员的析构）.


161，如何禁止创建栈对象，如果禁止创建堆对象
答案：
对于堆对象，可以通过重载operator new 和 operator delete 将他们设置为私有，这样就不能使用new和delete运算符去创建和释放对象了。
对于栈对象，可以通过将构造函数私有化的形式禁止创建对象。

162,new 与 operator new有何区别和联系
答案：
new 是C++中的操作符，其作用是调用operator new分配足够的空间，然后调用构造函数初始化。operator new是一个全局的函数，这个函数会被new操作符调用，进行空间的分配。new的作用流程是没有办法被更改的，也就是不能重载new操作符，但是operator new作为一个全局的函数可以被全局函数重载（返回值必须是void*，第一个参数必须是size_t表示要分配的空间大小），也可以在类中申明static void* operator new(size_t size)进行屏蔽和重载。用户在重载operator new的时候应该显式的调用::operator new(size)来进行默认的空间分配行为。
同样的分析适合delete与operator delete。这个函数的签名是 void operator delete(void* pointee);如果要在类中进行重载应该使用static方法.


163，有哪些运算符不能被重载
答案：
不能被重载的运算符有四个：
:: 取作用域下的属性或者对象
. 对象取属性
?: 三元运算
.* 这个是固定的写法，表示取


164，构造函数、析构函数、赋值运算符、拷贝构造函数，那些可以被继承
答案；
都不能被继承。构造函数与拷贝构造函数不能被继承，因为如果可以被继承就会可以被覆盖，这样就不能对父类进行初始化（像java和php中可以继承，但是子类需要显式的调用父类的构造函数）。赋值运算符不能被继承原因类似，因为如果继承之后被覆盖，那么在进行子类元素的赋值的时候可能失去了父类的元素的赋值效果（也需要显式调用）。而析构函数，也不能被继承（java中没有析构，php中可以继承，所以也需要显示调用父类的析构），一旦出现覆盖，可能导致父类资源没有得到有效释放。综上分析，C++中之所以这四个函数都不能别继承，最主要的原因是C++的中的构造函数和析构函数不是用户自己调用的。而在java和php中出现可以继承的情况是需要程序员自己进行父类的相应方法的显式调用的


165,写一个string类，并且实现内部的6个默认函数。
分析：
	1）对于每一个类都存在6个默认的函数：默认构造函数  拷贝构造函数  赋值运算符  取值运算符  const取值运算符
	2) 对于string类的这6个默认的函数给出函数体
编码要点：
	1）构造函数中需要对string里面的char*构建所指向的空间，析构中需要释放内部的char*所执行的空间
	2) 拷贝构造函数的形参应该是引用而不是对象类型，因为如果是对象类型会在实参到形参的初始化过程中再用拷贝构造函数本身
	3) 拷贝构造函数，应该处理一个特殊情况，就是如果传入的参数是调用对象本身，那么应该直接返回，否则可能对同一片的空间出现先释放后引用的问题
	4）对于const的取址函数的返回值应该是const指向的，因为取址返回的是调用对象的本身地址（也就是this），而const的约束指明当前的this指向是const的。所以返回值应该是const指向的。
实际编码:
	class MyString
	{
	private:
			char * m_data;
	public:
		/*默认构造函数*/
		MyString(const char* pData = nullptr){
			if(!pData){
				//构建空的字符串
				this->m_data = new char[1]();
				return;
			}
			//分配内存 拷贝数据
			strcpy(this->m_data = new char[strlen(pData) + 1](), pData);
		}
		/*拷贝构造函数*/
		MyString(const MyString & other){
			this->m_data = new char[strlen(other.m_data) + 1]();
			strcpy(this->m_data, other.m_data);
		}
		MyString * operator &(){
			return this;
		}
		const MyString* operator &() const{
			return this;  //同样是this，但是这里传入的this是指向的const对象的	
		}
		/*赋值运算符  这里返回当前对象，是为了可能的链式操作*/
		MyString& operator =(const MyString & other){
			//判断是否是同一个对象
			if(this == &other)
				return *this; //返回当前对象
			//先释放当前对象的资源
			delete [] this->m_data;
			//复制另一个对象的内容  这里要进行深拷贝
			this->m_data = new char[strlen(other.m_data) + 1]();
			strcpy(this->m_data, other.m_data);
		}
		/*析构*/
		~MyString(){
			//释放内部资源
			delete[] this->m_data;
		}

		/*为了方便测试，这里重载 << 运算符*/
		//使用成员函数重载的形式 不过只能使用成员函数调用 
		std::ostream& operator <<(std::ostream& stream){
			return (stream << this->m_data);  
		}
		//使用友元函数定义，这样可以使用二元运算符 << 的形式在代码中直接使用
		friend std::ostream& operator <<(std::ostream& stream, const MyString & obj){
			return (stream << obj.m_data);  
		} 
	};
	

166，下面三个语句执行的是什么函数
	Test t1;
	Test t2 = t1;
	t1 = t2;
分析：
Test t1执行的是默认构造函数
Test t2 = t1 是使用t1初始化一个t2，所以这里调用的是拷贝构造函数。
t1 = t2 由于t1已经初始化了，是已经存在的对象，所以这里是进行一次赋值，调用的是赋值运算符函数


167，构造函数中是否可以使用return
答案：
C++中，构造函数不返回任何类型的值，连void的都没有。所以在构造函数中不能使用return返回任何的值，否则会出现编译错误，但是单独使用return可以控制提前退出函数调用，这个是可行的。


168，说明构造函数与析构函数的执行顺序
答案：
1）在不考虑复杂的虚继承的前提下，先执行的父类的构造，如果存在多个父类执行的顺序与继承书写的顺序一致（对于父类适用于递归分析）。然后执行当前类中的类类型成员的构造，类类型的成员对象的构造顺序和在类的定义体中的定义顺序一致。最后执行当前类的构造函数。
2）析构函数的执行顺序与构造函数的分析完全相反。先执行当前类的析构函数，然后按照类中定义顺序的逆序执行当前类中的对象成员的析构，最后按照继承书写的逆序执行父类的析构。
3）在考虑顺序执行顺序的时候，初始化列表中的申明顺序（例如多个父类指定构造函数）不起任何影响。就如同对于所有的成员属性，初始化的顺序只与在类中定义的顺序有关，而与出现在初始化列表中的顺序无关一样.


169,什么是UB
答案：
undefined behaviour的意思。是未定义的行为，具体的实现依赖于编译器，不同的编译器中的结果可能会有不同。


170，下面的代码是否有问题
	class Base{
	public:
		void func(){}
		void func(int){}
	}
	class Sub: public Base{
	public:
		void func(int){}
	}
	Sub s;
	s.func();
分析：
子类中只要出现了一个与父类中同名的方法，都会对父类中所有的同名方法构成屏蔽（如果父类中存在同名同参数的virtual方法，进一步构成重写）。所以，这里子类中的void func(int)同时对Base中的两个函数构成了屏蔽，所以上面的调用错误。因为父类中的同名同参数的方法上没有virtual，所以没有构成重写。

171，下面的执行结果是什么
	switch(1){
		case 1:
			cout << 1 << endl;
		case 2:
			cout << 2 << endl;
		case 3:
			cout << 3 << endl;
			break;
		case 4:
			cout << 4 << endl;
		default:
			cout << "default" <<endl;
			break;
	}
分析：
1)如果一个case下面没有break或者continue或者return这样的控制结构跳转的语句，那么switch中的执行体会接着执行下一个case下面的语句，一直到遇到控制结构跳转的break等构成语句。在这个过程中，执行当前case后面的其他的case下面的语句不会再进行case的判断（默认条件成立）。
2）这里传入1，会一直执行到case3，然后遇到了break终止。所以结果是 1 2 3。
3）对于其他的语言，例如js php java等。同样的分析也是适用的。


172，C++中指针是否有隐式转换
答案：
1）对于基本数据类型：除了void* 和const的某些用法(例如指向非const的内容的指针可以赋给执行const的指针，而二者的类型并不完全相同(在C++中是可以进行指向const的引用参数重载的，因为这是两种不同的指针))，其他的指针之间不存在隐式转换。
2）对于类类型：派生类对象或者对象的指针或者引用可以传递给基类的对象或者指针或者引用，这里发生隐式转换。如果是基类对象对到派生类对象的指针或者引用的转换必须使用显示的转换(C++中允许将基类对象的引用或者指针强制转换为父类的类型，但是不允许直接进行对象的转换)。


173，下面的代码输出什么
	class A{
	public:
		virtual void func(int num = 10){
			cout << "A, num : " << num << endl;
		}
	};
	class B{
	public:
		virtual void func(int num = 211){
			cout << "B, num : " << num << endl;
		}
	}
	B b;
	A & a = b;
	a.func();
分析：
1）虽然函数在父类和子类之间存在多态性，如果是父类的指针或者引用指向子类对象，那么如果存在多态就会调用子类中的方法。
2）但是对于调用代码中的实参的却是在编译阶段进行的（在执行的时候进行动态绑定，然后利用这里的实参对相应的绑定到的函数的形参进行赋值）。
测试代码（上面的两个类的定义省去）：
	int main(int argc, char* argv[]){
		B b;
		A & a = b;
		//func函数由于存在多态的原因，所以使用父类的引用进行调用实际动态绑定的是子类中的函数。但是对于调用的函数的参数（这里是默认参数）的绑定则是在编译阶段就已经绑定好了的。所以这里的参数传入的是10。因为在编译的阶段a.func()的参数已经确定了。
		a.func(); //打印结果是B, num : 10

		//指针调用，和引用调用一样
		A *p = &b;
		p->func(); //指针调用和引用调用一样，这输出B, num:10
		return 0;
	}


174，实现对象类型之间的转换，主要有哪些方式
答案：
1）如果是子类与父类之间，子类对象可以对父类的引用或者指针进行初始化，子类对象也可以直接对一个父类对象进行赋值，这是那种转换都是隐式的转换。而父类对象的引用或者指针到子类对象的引用或者指针的转换是需要进行显式的转换的。父类的对象不能直接转换为子类的对象，即使是强制转换也不可以。
2）如果两个对象不存在继承的关系，那么可以使用转换构造函数转换，也可以使用类型转换函数进行转换。具体的，类型构造函数指的是这个构造函数存在唯一参数（后面如果还有其他的参数，应该有默认值），这个参数的类型是要转换的源类型。而类型转换函数的定义是一个成员函数，这个函数没有参数，不指定返回值类型，但是在这个函数的名称是(operator + 要转换到的另一个类型的类型名)（这个类型也可以是基本数据类型）而且函数体内部需要返回一个目标类型的变量(用来对接受的目标类型的对象进行赋值).
3）可以使用explicit修饰转换构造函数，那么这个构造函数只能显式调用，而不能用作隐式的转换表达式，也即是说（B  b = a）如果相应的构造函数被explicit修饰，那么这个表达式会编译通不过。
测试过程代码如下：
	class A
	{
	public:
		int x = 111;
		virtual void func(){
			cout << "A... " << x << endl;
		}
	};

	class B : public A
	{
	public:
		virtual void func(){
			cout << "B... " << x << endl;
		}
	};


	class C
	{
	public:
		int x = 222;
		virtual void func(){
			cout << "C... " << x << endl;
		}
		C(){}
		//转换构造函数
		C(const B& b){
			x = b.x;
		}
		//类型转换函数，没有返回值，但是需要返回一个要转换到的目标类型的对象
		operator B(){
			B temp;
			temp.x = x;
			return temp;
		}
		//到基本类型的转换
		operator int(){
			return  x;
		}
	};
	class D
	{
	public:
		int x = 6666;
		virtual void func(){
			cout << "D... " << x << endl;
		}
		D(){}
		//使用explicit修饰转换构造函数，这样就先定了这个构造函数不能用于隐式转换（也就是不能直接 D d = b;）
		explicit D(const B& b){
			x = b.x;
		}
	};

	int main(){
		/*在子类与父类之间转换*/
		B b;
		A & a = b; //子类对象初始化父类引用，可以隐式转换
		a.func(); //B...111
		B & d = (B&)a; //子类引用到父类引用需要进行强制转换
		d.func();

		/*没有继承关系类型之间的转化*/
		C c = b; //使用构造函数转换
		c.func();
		B b2 = c; //使用C类中的类型转换函数，将其中的临时对象赋给这里的B对象
		b2.func();

		//到基本类型的转换
		cout << (int)c << endl;

		//使用explicit修饰转换构造函数，禁止隐式转换
		D d1(b); //直接显示调用构造函数，可行
		d1.func();
		D d2 = b; //隐式转换，由于使用了explicit修饰相应的转换构造函数，所以这里会出现编译错误：conversion from B to non-scalar type D
		return 0;
	}


175，如何定义抽象类
答案：
一般把自己不能实例化对象，但是子类可以实例化对象的类成为抽象类。实现抽象类主要的额方式有两种：
1）使用纯虚函数，也就是没有函数体的virtual成员函数（virtual int func() = 0）。子类可以实例化对象的前提是实现了父类中的纯虚函数。
2）使用protected的构造函数，这样这个构造函数在子类中的初始化列表中可以访问的到但是其本身却不能实例化对象。


176，对象类型、指针、引用的三种形式的向上转换
分析：
对象的向上转换，是直接将一个对象中的子对象取出来进行赋值。这样获取到的是一个全新的父类对象（其中不包含任何的子类的成员，还有虚表是绑定到类的，拷贝的时候会自动进行虚表指针的拷贝）, 所以这个获取到的对象调用跟直接new一个对象没有任何的区别。
对象的引用或者指针的向上转换，涉及到可能存在的虚表问题，如果父类中存虚函数，那么转换之后，函数的调用由于会查询虚表而存在多态效应。


177,友元函数能否有权限修饰符和static
分析：
1）友元函数除了不是是成员函数，不是通过this指针调用，友元函数必须在类中定义。由于友元函数不是成员函数，默认是外连接的，所以不受权限限定符public protected private等的控制，即使手动加上了也没有作用（实际上，在类中定义的函数，即使没有认为的书写权限限定符，也是会有默认的权限区间的）
2）但是注意，友元函数默认是外连接的，C++标准中注明不能使用存储类限定符(static和extern)进行修饰（尽管在有些编译器中是通过编译的）
3) 友元函数的参数一般至少会有一个本类型的引用，这样才能确定是调用哪一个类中的友元函数。如果没有提供任何的参数信息（例如参数为空），在编译阶段会判断为调用的地方找不到函数的定义。
测试代码：
	class Test
	{
	private:
		friend void func1(Test & t){
			cout << "hello func1" << endl;
		}
	public:
		friend void func2(Test & t){
			cout << "hello func3" << endl;
		}
		friend void func5(){
			cout << "hello func5" << endl;
		}
		friend void func6(int x){
			cout << "hello func6" << endl;
		}
		friend void func6(int x, Test & t){
			cout << "hello func6" << endl;
		}
		/*
		//下面的两种写法是一样的，都是一个编译错误：storage class specifiers invalid in friend function declaration（存储类型的限定符不能出现在friend函数的申明中）
		static friend void func3(){
			cout << "hello func3" << endl;
		}
		friend static void func4(){
			cout << "hello func4" << endl;
		}
		*/
	};

	int main(){
		Test t;
		func1(t);
		func2(t);

		//func5(); //编译错误：找不到定义，因为可以用来找这个函数的信息不足。
		
		//func6(1); //编译错误：找不到定义，不能确定是哪一个类的友元

		func6(11,t);//func6
		return 0;
	}

178，指针之间的隐式转换有哪些
答案：
其他指针到void*，非const指向的指针到const指向的指针。子类指针到父类指针。


179，下面的三个指针是否相等
	class A{
	public:
		virtual ~A(){}
	}
	class B{
	public:
		virtual ~B(){}
	}
	class C: public A, public B{

	}
	C c;
	C *pc = &c;
	A *pa = &c;
	B *pb = &c;
分析：
C的空间存储是先存放A的空间，然后存放B的空间，然后存放C自己的空间。这里注意到A和B类中存在虚的析构函数，析构函数虽然不能继承，但是析构函数是可以为虚的，存在多态效应（准确的说是会存放到虚函数表中）。A和B的对象空间是存放一个vptr，C中A在B之前存放。所以pa和pc指向同一个地址空间，而pb指向的空间与它们偏移了一个vptr。故pc == pa，对于pc与pb的分析，pc == pb，因为pc与pb不是一个类型的指针，所以存在pc到pb类型的隐式转换，这样pc转换之后与pb就是同一个指向了。要分析pb == pa，首先二者不是同一个类型的指针，而且由于两者不存在继承的关系，所以没有办法进行隐式的转换，也就是说二者不能直接比较。直观上看二者指向的地址是不一样的，pb可以通过 static_cast<B*>(static_cast<C*>pa)得到（或者直接使用动态转换danymic_cast<B*>pa，因为静态转换是强转，不涉及到类型检查，而动态转换的时候如果传入的指针不能成功转换返回的是nullptr）


180，构造函数和虚构函数能否是虚函数，在构造函数和析构函数中能否调用虚函数。
答案：
父类的构造函数先于子类的执行，虚函数的调用是通过虚表实现的。那么在父类构造的时候，子类由于还有没有构造，所以也就没有指向子类的虚表的vptr，所以构造函数设置为virtual的没有任何的意义，构造函数在标准中是明确禁止为virtual的。而析构函数很多时候会设置为virtual的，原因是如果用父类对象的引用或者和指针对子类的对象进行保存或者传递，这中间的资源的释放在父类的析构为virtual的情况下会调用子类的保证子类中的资源可以得到有效释放，防止内存泄露。由于虚函数的调用会查询虚表，而父类构造的时候，子类中的vptr还没有初始化，所以在父类中调用虚函数也只是调用其本类中的，而在析构函数中由于子类独有的资源已经释放了，剩下的是父类类型的一个子对象，这个时候调用虚函数，也只是执行本类的方法，同样调用虚函数没有多态的效果。所以在构造和析构函数中应该避免调用虚函数.

181，什么是RTTI，存放在哪里
答案：
RTTI是runtime type identification，是数据的运行时类型。这个一般的用在父类与之类在引用或者指针之间转换的时候确定真实的指向类型。RTTI存放在虚表的上面，也就是虚表的首地址向上偏移4个字节的位置（这四个字节保存实际指向的数据类型）。RTTI可以用于对象的动态转换的时候判断父类引用或者指针是否真的可以转换为子类的类型的引用或者指针。


182，下面的两个调用语句是否正确
	class A{
	public:
		void func1(){}
		virtual func2(){}
	}
	A * pa = nullptr;
	pa->func1();
	pa->func2();
分析：
pa->func1()语句执行是正确的，因为在函数func1中没有涉及到对成员属性的引用，所以尽管pa是nullptr但是调用可以正常执行(非虚函数的绑定是静态，是编译时绑定不涉及到运行时虚表查询)。
pa->func2()语句会执行失败，因为在执行虚函数func2的时候会进行虚表的查询，会读取nullpt处的虚表指针，从而导致程序崩溃。


183，下面的类sizeof得到的大小是多少
	class Test{
	public:
		static int x;
		virtual void func(){};
	}
分析：
对一个类进行sizeof与对一个类类型的对象进行sizeof的结果一样的。类中的静态变量存放在全局与静态变量区，不会对计算sizeof产生影响。所以如果这里不考虑虚函数func，sizeof(Test)的结果是1，这一个字节用于标识一个对象。而这里还有一个虚函数virtual void func，一个类中只要存在虚函数，就会对应一张虚表，在类创建的对象的起始空间会存放执行这个虚表的指针。由于已经存放了vptr，所以就不用编译器自动给出一个占位字节进行对象的标识了，所以这里的sizeof(Test) = 4。这4个字节存放的是vptr.

184，什么是bptr，什么是vptr
答案：
bptr是用于虚继承中，对于每一个虚继承会保存一个bptr，子类中的这个bptr保存相对于虚基类子对象的偏移。vptr是虚函数表指针，如果一个类中存在虚函数，就会在创建对象的时候，在实例的起始空间存放一个vptr，用来保存相应的虚函数表的地址。


185，菱形的虚继承中，对于祖父类子对象的实例化进行了多少次
答案：
1）只进行了一次，虚继承保证了祖父类的子对象的只存在一个，而在直接继承的两个父类中存在bptr，用来保存相对于这个祖父类的子对象的偏移。正因为如此，所以在两个父类的初始化列表中和当前子类的初始化列表中都应该指定祖父类的实例化使用的构造函数（保证这三个类都能正常的实例化对象）。
2）如果祖父类中没有默认的构造函数，那么在孙子类的初始化列表中必须指定祖父类中的构造函数，否则会编译失败，因为使用虚继承，对祖父类的实例化只进行一次，而初始化的指定只能出现在最终的孙子类中.
实际使用代码：
	class GrandParent
	{
	public:
			int x;
			int y;
			int z;
			GrandParent(int x){
				this->x = x;
				this->y = 222;
				this->z = 333;
				cout << "create GrandParent" << endl;
			}
			GrandParent(int x, int y){
				this->x = x;
				this->y = y;
				this->z = 333;
				cout << "create GrandParent" << endl;
			}
			GrandParent(int x, int y, int z){
				this->x = x;
				this->y = y;
				this->z = z;
				cout << "create GrandParent" << endl;
			}
	};
	class Parent1 : virtual public GrandParent
	{
	public:
		Parent1(int x) : GrandParent(x){
			cout << "create Parent1" << endl;
		}
	};
	class Parent2 : virtual public GrandParent
	{
	public:
		Parent2(int x, int y) : GrandParent(x,y){
			cout << "GrandParent2" << endl;
		}
	};
	class Child : public Parent1, public Parent2
	{
	public:
		//这里需要提供祖父类A的初始化
		Child() : GrandParent(666,777,888), Parent1(111), Parent2(222,333){
			cout << "create child" << endl;
		}

		void func(){
			cout << x << "..." << y << "..." << z << endl;
		}
		
		/*
		//这个构造函数并不指定GrandParent的构造函数，编译的时候会报错：no matching function for call to GrandPrant::GrandParent()也就是说使用了虚继承，如果祖父类中没有默认的构造函数，那么必须在孙子类中指定祖父类的构造函数，否则会应为调用默认的而出错（编译阶段）
		Child(int x) : Parent1(111), Parent2(222,333){
			cout << "create child" << endl;
		}
		*/
	};
	int main(){
		//打印的顺序是 GrandParent..Parent1...Parent2...Child。可以看到对于构造Parent1和Parent2的时候，并没有再次调用祖父类中的构造函数(尽管在初始化列表中也分别指定了相应的构造函数，但是由于child类中已经对祖父类的子对象进行了初始化，所以这里的初始化列表的中的代码并不会执行)
		Child c;
		cout << "--------------分割线-------------" << endl;
		c.func(); // 666 777 888 结合上面的构造函数的执行的顺序，可以发现在Parent1和Parent2的初始化列表中指定的GrandParent的构造函数并没有执行.

		cout << "--------------分割线-------------" << endl;
		//直接实例化Parent1，其中指定的GrandParent的构造函数又会执行到
		Parent1 p1(999);
		cout << p1.x << endl; //999
		return 0;
	}	


186，typeid获取到的是什么
答案：
typeid是一个操作符，如果操作数是带有虚函数的类类型或者是对象的时候返回的真实存储的类型。如果操作数是基本类型或者是没有虚函数的类类型或者对象，返回的是编译的时候确定的类型.


187，什么是显式转换
答案：
显式转换又称为强制类型转换，是相对于隐式转换而言的。在引入四个强制类型转换操作符的之前，强制类型转换都是通过()中存放类型的形式书写。C++中存在4个强制转换的操作符:
reinterpret_cast：这个操作符与直接使用()加上类型的转换是一个效果（reinterpret意思是重新解释）
const_cast: 对于const指向的指针或者引用进行转换。如果是const引用或者指针只能使用这个操作符进行转换，如果使用另外的三个操作符进行转换会报错，同样如果使用const_cast转换非const指向的引用或者指针也是错误的（存在一个特例，就是const_cast这个转换是可以实现const属性的移除和添加，例如实现const指向到非const指向 double * p = const_cast<double*> pc; 其中pc为const double*）。
static_cast: 对于所有的可以使用隐式转换和对象的下行转换(父类到子类，但是这里的转换是不进行类型的安全检查的)，可以使用static_cast。
dynamic_cast: 动态转换，在运行时会进行类型的RTTI的判定，适用于存在继承关系的类的对象的转换。由于RTTI存放在虚函数表中（准确的说在虚函数表的首地址的上面的一个int），如果一个类中没有虚函数，那么就会出现编译错误（提示操作数必须包含多态类类型）。如果dynamic操作符的操作数是指针，在不能进行转换的时候会返回null，在操作数是引用的时候，如果不能正常转换会抛出异常。(注意，这个操作符只能接受指针或者引用类型，不能接受对象类型)
编码补充：
	1）对于static_cast，如果是下行转换，传入的参数类型不能是对象类型（除非定义了转换构造函数或者是类型转换函数），否则编译通不过。对于上行的传入参数为对象(可隐式)转换，其实就是调用的拷贝构造函数，但是在传参的时候进行了隐式的引用转换。
	2）static_cast对于指针和引用的下行转换是不假思索的，不进行类型检查的(只要这两个类型的存在继承关系，而不考虑真实的对象的内存结构。如果这里两个类型不存在继承关系，会编译通不过)
	3) 如果两个类不存在继承关系，那么如果使用static_cast在编译阶段会直接报错，但是如果是用dynamic_cast会给出一个警告，说是转换确定不会成功（返回null）
	4）对于多继承，两个父类之间不存在继承关系，所以不能直接使用static_cast转换，否则会产生编译错误。但是如果是使用dynamic_cast由于会检查对象的真实指向类型，所以可以转换成功。
实际编码：
	class A
	{
	public:
		int x = 111;
		virtual void func(){
			cout << "A... " << x << endl;
		}
	};

	class B : public A
	{
	public:
		int x = 222;
		virtual void func(){
			cout << "B... " << x << endl;
		}
	};

	class C
	{
	};

	int main(){
		//移除const指向的属性
		const A * pa = new A;
		//pa->x = 22;  //编译报错，提示对read-only的对象的成员进行赋值操作
		A* pa2 = const_cast<A*>(pa);
		pa2->x = 222; //操作成功，因为将const指向变成了非const指向
		cout << pa2->x << endl; 
		//添加const指向
		pa = const_cast<const A*>(pa2);
		//pa->x = 111; //再次编译错误，对read-only的对象的成员进行赋值

		cout << "------测试分割线-----------" << endl;
		//使用static_cast上行转换（符合隐式转换）
		B b;
		cout << b.x << endl;
		//对象类型的转换
		A a = static_cast<A>(b); //调用拷贝构造函数
		cout << a.x << endl; //111
		//对象的引用的转换，对象的指针的转换相似
		A & ya = static_cast<A&>(b); //这里传入的其实不是引用而是一个对象，使用不规范，因为下面的下行转换就可以看到如果传入的是对象而不是引用会有问题
		cout << ya.x << endl; ///111
		//使用static_cast进行下行转换,和动态转换不同，这里不会进行类型安全检查
		//B b1 = static_cast<B>(a); //编译错误，因为上行的对象直接转换是调用的拷贝构造函数，而下行的时候没有找到可以隐式转换到构造函数（也没有定义相应的类型转换函数），所以这编译通不过

		//引用的下行转换（指针类似）
			//一种错误的示例
		B &b1 = static_cast<B&>(a); //注意，这里的参数应该是引用，如果不小心传了一个对象进去，由于引用和指针存储的数据是一样的，这里会导致指针乱指
		cout << b1.x << endl; //垃圾值，而且由于指针乱指，这里的情况不可测
			//正确传入引用为参数，得到正确结果
		B &b2 = static_cast<B&>(ya);  //正确传参
		cout << b2.x << endl; //222
		//C *pc1 = static_cast<C*>(&b); //编译通不过，因为不存在继承关系，不可能存在上行或者下行的关系

		cout << "------------测试分割线-------------" << endl;
		//动态转换,如果转换的类中没有虚函数，将导致编译错误，因为动态转换要到虚表中寻找RTTI。与static_cast相比，动态转换是运行是确定类型的，会进行类型安全性检查
		A *pa3 = dynamic_cast<A*>(&b);
		cout << pa3->x << endl; //111
		C *pc2 = dynamic_cast<C*>(&b); //与static_cast的编译error相比，这里只是给出一个警告，说是这种转换"can never succeed"。因为两个类不存在继承关系，所以这里的pc2在运行前就已经确定是nullptr
		cout << pc2 << endl; //0
		return 0;
	}


188，下面对static_cast的使用有什么问题，其中A和B是任意两个类
	void * pv = static_cast<void*>(pA);
	B * pB = static_cast<B*>(pv);
答案：
static_cast是不进行类型的安全性检查的，这里无论是pa到void*还是void*到B*，都不会出现编译错误。但是如果A和B是两个任意的类，那么指针转换之后引用数据可能出现混乱。由于不存在类型的安全性检查，所以这里使用static_cast将可能出现的问题留到运行时。

189,下面的代码有什么问题，其中A是B的父类
	B b;
	A * pa = &b;
	delete pa;
答案：
编译通过，会出现运行时错误，因为栈上空间不能通过delete释放(注意，与free类似，在变量delete之后应该置空，对于空指针（不能直接将nullptr传入，要传指针测试）的delete不会进行任何操作)。
测试代码： 结果是有时候会崩有时候不会
	class A
	{
	public:
		int x = 111;
	};

	class B : public A
	{
	public:
		int x = 222;
	};

	int main(){
		B b;
		A * pa = &b;
		cout << pa->x << endl; //这一行代码如果没有下面的delete好像并没有报错，个人的分析是编译器的一种优化方案，就是b这个对象的初始化（真正的执行）在使用其中的元素之前是有延后的。
		delete pa; //编译没有问题，按照说明栈上空间不能使用delete释放否则会出现运行是问题。但是这里测试没有问题，可能是进行了优化.(补充说明，经过多次的测试，发现有时候会崩有时候不会，具体的问题有待分析)
		cout << pa->x << endl;
		return 0;
	}


190，分别使用分治算法和动态规划算法解决下面问题：使用1*2的瓷砖覆盖2*M的地板，一共有多少种摆法。
分析：
1）因为是2*M的地板，所以第一列可以是横着放一块1*2的瓷砖，那么由于只有两行，那么这一块瓷砖一定的下面一定还有一块1*2的瓷砖，它们一起填充前两列。另一种情况是第一列竖着放一块1*2的瓷砖，那么第一列就放好了，接下来直接考虑2*(M-1)的子问题就行。由于上面分析的两种情况中，第一列的摆放的不同的，那么这两种的摆放情况是不存在重叠的，所以总的摆放的方案的数量是f(m) = f(m-2)  + f(m-1)。
2）上面的分析过程便是分治的过程，可以看到这个公式是斐波拉契的，会有很多的重复计算。如果采用自底向上的递推，然后保存中间量的形式，可以使用动态规划的思路优化计算。
扩展分析：
1）如果是1*2的瓷砖去铺N*M的地面，又该如何分析。首先从左上角开始分析还是横着摆放第一块还是竖着摆放第一块这两种情况由于首个角的摆放不同而符合分治要求。但是与2*M不同，当横着摆放第一块的时候，这一块的下面不一定必须要一块横着摆的1*2的瓷砖，进一步分析，如果对于不同的行数N可能分析不一样，还有就是没有办法说先把上面的2*M铺满这样的分析，因为铺的过程中可能会产生不整齐的情况。所以总体上看，这只用N*M的摆放方案，没有直观的简便分析方法。
实现补充：
一般的动态规划都是从下往上的，如果是要从上往下，那么可以先将中间保存的空间统一初始化为一个非法值，然后在递归的开始判断这个值是否已经计算过了，如果计算过了就直接取出。这样就可以实现自顶向下的动态算法。

实际编码：
	/*	
		使用分治的思路计算1*2的瓷砖填充2*M的地板的方案种数的问题
	@param int m 要填充的地板的列数
	@return int 所有的摆放的方案种数
	*/
	int DivideCal(int m){
		assert(m > 0);
		if(m <= 0)
			return 0;
		if(m == 1)
			return 1; //只有一列，所以只要一种摆法，竖放一块
		if(m == 2)
			return 2; //因为递归公式中使用到了f(m-2)，所以m=2的时候也因该是一个base
		return DivideCal(m - 2) + DivideCal(m - 1);
	}


	/*	
		使用动态规划的思路计算1*2的瓷砖填充2*M的地板的方案种数的问题
	@param int m 要填充的地板的列数
	@return int 所有的摆放的方案种数
	*/
	int DpCal(int m){
		assert(m > 0);
		if(m <= 0)
			return 0;
		int first = 1, second = 2, tmp = 0;
		if(1 == m)
			return first;
		for(int i = 3; i <= m; ++i){
			tmp = first + second;
			first = second;
			second = tmp;
		}
		return second;
	}


	#define MAX_COLUMN 1000
	int save[MAX_COLUMN] = {0}; //保存中间计算数据
	/*	
		自顶向下的dp
	@param int m 要填充的地板的列数
	@return int 所有的摆放的方案种数
	*/
	int DpFromTopCal(int m){
		assert(m > 0);
		if(m <= 0)
			return 0;
		if(!save[m-1]){
			//没有计算过，就计算save[m-1]
			save[m-1] = 1 == m ? 1 : ( 2 == m ? 2 : DpFromTopCal(m-2) + DpFromTopCal(m-1) );
		}
		return save[m-1];
	}


191，编写一个函数，输入两个字符串，求它们的最长公共子序列的长度。例如：输入两个字符串ABCBDAB和BDCABA,字符串DBBA和BDAB都是它们的最长公共子序列，则输出它们的长度4。（注：最长公共子序列不要求这个公共的序列中的字符是连续出现的）
分析：
	1）先使用分治思想，考虑两个字符串的最后一位，如果相同，那么最终的长度就是f(m,n) = f(m-1,n-1) + 1。其中f(m,n)表示字符串长度分别是m和n的情况下计算这两子串的最长公共子序列的长度. 如果两个字符串最后一位不相同，那么 f(m,n) = max{f(m-1,n),f(m,n-1)}，也即是其中的一个字符串的末尾进行舍弃然后与另一个字符串向比较计算，取这两个可能的计算结果中的较大者为最终的f(m,n)。可以看到最后一位无论是相同的还是不相同的都符合最优子结构的特性（也就是每一个子结构的解也是好最优的，这一点是与贪婪的不同）
	2）上述的递归表述中，如果使用自顶向下，那么公式max{f(m-1,n),f(m,n-1)}可能会产生大量的重复计算，主要的问题是如果很多的末尾不匹配在计算f(m-1,n)和f(m,n-1)的时候会出现重叠。
	3）实际上，形如f(m-1,n-1)和 f(m,n-1) f(m-1,n)这样的形式，明显就是填表中的矩形的三个角，在自底向上的两种循环中，在计算f(m,n)之前已经计算了f(m-1,*)也就是前一行的数据，而在本次列的循环中在计算 f(m,n)之前已经计算过了f(m,n-1)。这样是可以通过已经计算过的3个角来获取到要求解的 f(m,n)的。这是一种常用的模式化填表。
	4）公式的base为如果其中的一个字符串为空，也就是f(0,*) = 0 和 f(*,0) = 0
扩展分析：
	如果是要求得最长子序列的字符串的内容呢。一个思路是将每一个节点额外保留一个字符串用来保存这个节点最长子序列的内容，然后在下一个节点的计算中如果末尾相同那么直接在子序列的末尾加上这个字符进行存储。但是这里如果对每一个节点的情况进行存储会造成空间的浪费，还有就是实际上最后影响f(m,n)填表的只有三个其他节点，而每一行进行填表的时候会依赖于上一行的结果，所以额外的保存字符串数量为上一行n+1个结果和这里行的当前元素左边的节点的结果.
可以获取到最长子序列的长度和内容的代码如下：
	/*
		利用dp求解 longest common subsequence
	@param char *str1 待求解的字符串1
	@param char *str2 待求解的字符串2
	@param string *result = nullptr 用于获取求解到的最长子序列的内容，如果没有传入，默认是nullptr表示不进行内容的获取
	@return int 两个字符串的最长公共秩子序列的长度
	@version 1.0 基本实现功能，能够求解答到最长的子序列的长度。但是不能获取到子序列的内容
	@version 2.0 添加一个用于返回获取到的最长子序列的内容的形参，如果这个参数没有传入，默认是null，表示不会进行内容的获取
	*/
	int LCS(const char *str1, const char *str2, string * result = nullptr){
		assert(str1 && str2);
		if(nullptr == str1 || nullptr == str2){
			if(result)
				*result = "";
			return 0;
		}
		int m = strlen(str1), n = strlen(str2);
		if(!m || !n){
			if(result)
				*result = "";
			return 0; //其中至少有一个为空字符串
		}
		int **c = new int*[m+1];
		if(!c){
			//严格意义上这里应该抛异常
			std::cerr << "new memory fail" << endl;
			if(result)
				*result = "";
			return 0;
		}
		for(int i = 0; i <= m; ++i){
			c[i] = new int[n+1]();
			if(!c[i]){
				std::cerr << "new memory fail" << endl;
				if(result)
					*result = "";
				return 0;
			}
		}

		//计算填表
		if(!result){
			//不需要保存结果字符串 直接计算长度的数值
			for(int i = 1; i <=m; ++i){
				for(int j = 1; j <= n; ++j){
					if(str1[i-1] == str2[j-1])
						c[i][j] = c[i-1][j-1] + 1; //末尾相同
					else
						c[i][j] = max(c[i-1][j],c[i][j-1]);
				}
			}
		}else{
			string * resultInPreLine = new string[n+1](); //用来存储循环上一行结果
			if(!resultInPreLine){
				cerr << "new memory fail" << endl;
				*result = "";
				return 0;
			}
			string left; //用来存放左边的节点的结果
			string calc; //用来存放当前节点的最长子序列的结果	
			for(int i = 1; i <=m; ++i){
				for(int j = 1; j <= n; ++j){
					if(str1[i-1] == str2[j-1]){
						c[i][j] = c[i-1][j-1] + 1; //末尾相同
						calc = resultInPreLine[j-1] + str1[i-1];
					}
					else{
						if(c[i-1][j] < c[i][j-1]){
							c[i][j] = c[i][j-1];
							calc = resultInPreLine[j];
						}else{
							c[i][j] = c[i-1][j];
							calc = left;
						}
					}
					//更新本行左侧数据 更新left
					resultInPreLine[j-1] = left;
					left = calc;
				}
				//重置left，更新最后一列上的resultInPreLine
				left = "";
				resultInPreLine[n] = calc;
			}
			//释放额外空间
			delete[] resultInPreLine;
			*result = resultInPreLine[n];
		}

		//释放内存
		for(int i = 0; i <= m; ++i)
			delete[] c[i];
		delete[] c;
		return c[m][n];
	}


192，01背包问题。01背包指的是所有的物品每一个重量只有一个然后要么拿要么不拿不能拿一部分。考虑如下问题，用代码求解：背包容量为5，物品1重1价值60，物品2重2价值100，物品3重3价值120。求最大价值。如果要求背包必须装满的前提下修改代码求最大价值.
分析：
首先考虑背包可以不装满的情况，这种情况是网络上分析的最多的问题。思路是一个递推公式用v[i][j]表示用前面i个物品填充容量j的情况下可以获取到的最大价值。那么v[i][j] =  max(v[i] + v[i-1][j-m[i]], v[i-1][j])，其中v数组代表价值，m数组存储的是每个的重量。容易知道v[0][0~最大容量]=0，v[0~最多物品][0]=0。
在不要求最终一定装满的情况下的01背包的代码：
	/**
	*  获取在不保证最后一定装满的情况下01背包的最大价值
	*
	* @param int value[] 所有物品的价值数组
	* @param int weight[] 所有物品的重量数组
	* @param int number 物品的数量
	* @param int capactiy 提供的容量
	* @return int 返回获取到的最大价值
	*/
	int MaxValueWhenMayFull(int value[], int weight[], int number, int capacity){
		assert(value && weight && number >= 0 && capacity >= 0);
		int ** result = new int*[number + 1]; //用一个二维数组存储中间结果
		if(!result){
			throw "内容分配出错";
		}
		for(int i = 0; i <= number; ++i){
			result[i] = new int[capacity + 1]();
			if(!result[i]){
				for(int j = 0; j < i; ++j)
					delete[] result[j];
				delete[] result;
				throw "内容分配出错";
			}
		}
		//使用递归公式，进行“填表”
		for(int i = 1; i <= number; ++i){
			for(int j = 1; j <= capacity; ++j){
				if(weight[i-1] <= j)
					result[i][j] = value[i-1] + result[i - 1][j - weight[i-1]];
				result[i][j] = std::max(result[i][j], result[i-1][j]);
			}
		}
		int toReturn = result[number][capacity]; //使用number个物品填充capacity的容量
		//释放内部空间
		for(int j = 0; j <= number; ++j)
			delete[] result[j];
		delete[] result;
		return toReturn;
	}
接着分析，在保证最后背包一定要装满的情况。首先考虑递推公式，原来的递推公式v[i][j] =  max(value[i-1] + v[i-1][j-weight[i-1]], v[i-1][j]依然是实用的，这个时候v[i][j]表示使用i个商品填满j的容量的最大价值。由于递推公式是一样的，那么只需要修改递推的初始条件。可以知道v[1~最大物品数][0]=0这个时候是装满的。而v[0][1~最大容量]=-INFINITY, 这里的意思是将没有装满的情况的价值设置为负无穷，而负无穷加上任何非无穷的数据还是负无穷（实际意义因为value[i-1] + v[i-1][j-weight[i-1]]在v[i-1][j-weight[i-1]]=-INFINITY的时候表示的依然是没有装满的状态）。通过上面的分析，对于保证必须装满的条件分析，只需要修改初始的递推条件和增加加法的额外判断就可以在原来的不需要装满的01背包的代码基础上完成保证装满条件下的01背包的代码
在保证背包一定要装满的前提下，实现01背包的代码：
	/**
	*  获取在最后一定装满的情况下01背包的最大价值
	*
	* @param int value[] 所有物品的价值数组
	* @param int weight[] 所有物品的重量数组
	* @param int number 物品的数量
	* @param int capactiy 提供的容量
	* @return int 返回获取到的最大价值
	*/
	int MaxValueWhenMustFull(int value[], int weight[], int number, int capacity){
		assert(value && weight && number >= 0 && capacity >= 0);
		int **result = new int*[number + 1];
		const int INFINITY = std::numeric_limits<int>::min(); //最大负数，用来保存没有装满的时候的价值
		if(!result)
			throw "内存分配出错";
		for(int i = 0; i <= number; ++i){
			result[i] = new int[capacity + 1]();
			if(!result[i]){
				//释放已经分配的空间
				for(int j = 0; j < i; ++j)
					delete[] result[j];
				delete[] result;
				throw "内存分配出错";
			}
		}
		//将传入的
		//将result[0][1~最大容量设置为INFINITY
		for(int i = 1; i <= capacity; ++i){
			result[0][i] = INFINITY;
		}
		//递推填表
		for(int i = 1; i <= number; ++i){
			for(int j = 1; j <= capacity; ++j){
				if(weight[i-1] <= j)
					result[i][j] = (INFINITY == result[i-1][j-weight[i-1]] ? INFINITY : result[i-1][j-weight[i-1]] + value[i-1]);
				result[i][j] = std::max(result[i][j], result[i-1][j]);
			}
		}
		int toReturn = result[number][capacity];
		//释放内部空间
		for(int i = 0; i <= number; ++i)
			delete[] result[i];
		delete[] result;
		return toReturn;
	}
note:
在考虑这个问题的时候，一开始分析递推公式的时候认为应该将传入的物品按照重量排序。后来发现这可能是现实中的一个错觉。实际上不用排序因为递推公式进行填表的时候囊括了所有的物品和容器的排列组合


193，部分背包问题：01背包形象的将每一个物品描述成了一个完整的不可拆卸的整体，要么都拿走要么完全不拿。而部分背包是将所有物品形象描述为一袋一袋的金粉，可以拿一部分。这种情况下应该如何做到价值最大。
答案：
一直按“密度”最大拿物品，一直拿到容器填充完成。部分背包的递推是贪婪的，而01背包却只能用动态规划做决策，因为在01背包的情况下没有办法决定最开始拿的最优最后一定用的上：例如如果一开始拿一个密度最大的，那么可能由于容器容量限制导致不是最终的最优。
实际书写代码：
	/**
	*  获取部分背包问题的最大价值
	*
	* @param int value[] 所有物品的价值数组
	* @param int weight[] 所有物品的重量数组
	* @param int number 物品的数量
	* @param int capactiy 提供的容量
	* @return int 返回获取到的最大价值
	*/
	int MaxValueWhenWeightCanBeResolved(int value[], int weight[], int number, int capacity){
		assert(value && weight && number >= 0 && capacity >= 0);
		//按密度进行排序，这里在内部排序索引数组，而不是操作传入的两个数组，这也是符合一般的使用情况的。例如现实情况可能是更多组的更庞大的数据集合，一般不应该直接操作原来的数据。而且这里涉及到两个数组，而关联它们的是索引，所以进行索引标号排序是最合适的逻辑
		int *indexes = new int[number](); //用来保存所有物品的索引标号
		float *densities = new float[number](); //保存所有的物品的密度
		if(!indexes || !densities){
			delete[] indexes;
			delete[] densities;
			throw "内存分配出错";
		}
		for(int i = 0; i < number; ++i){
			indexes[i] = i;
			densities[i] = (float)value[i] / weight[i];
		}
		//进行索引数组按照“密度”从大到小的排序 这里为了保证代码的效率和代码的内联，采用了希尔排序
		for(int step = number / 2; step > 0; step *= 2){
			for(int i = step; i < number; ++i){
				int index = indexes[i], density = densities[i], j;
				for(j = i; j - step >= 0 && density > densities[j - step]; j -= step){
					//将密度较小的元素后移
					densities[j] = densities[j - step];
					indexes[j] = indexes[j - step];
				}
				densities[j] = density;
				indexes[j] = index;
			}
		}
		int result = 0;
		//按密度从大到小装入容器
		for(int i = 0; i < number && capacity > 0; ++i){
			if(capacity > weight[indexes[i]]){
				result += value[indexes[i]];
				capacity -= weight[indexes[i]];
			}else{
				result += round(capacity * densities[i]); //最终的结果进行四舍五入
				capacity = 0;
			}
		}
		//释放内部空间
		delete[] indexes;
		delete[] densities;
		return result;
	}


194，完全背包问题：在每种物品的数量是无穷的情况下问题背包问题的最大价值
分析：


195，过桥问题：a、b、c、d四个人过桥的时间分别为1、2、5、10，现在只要一个手电筒，如果两个人同时过桥那么过桥时间是较慢的那个。应该如何安排过桥使得整体的过河时间为最短。
分析：
在经典的过桥问题中，是只有两个人可以同时过河。因为只有一个手电筒，那么必须有一个过了河的人回来送手电筒。考虑到松手电筒的一定是过了河的速度较快的，那么问题可以转变为先将最慢的两个人送过河，然后将余下的人送过河(同样的子问题)，之所以是送两个人过河为一个步骤，因为两个最慢的如果和集体中其他的人时间相差很大，那么这两个人同时过河可以明显的缩短整体的时间，可是如果他们和其他的成员的过河时间相差不是很大，那么有可能一直用最快的送两者过河的时间会出现更优(因为缩减了两次的返回时间，两次返回的都是第一快)。例如设最快的时间依次为x,y，而最慢的依次为m,n，其中x < y < m < n。那么上面的描述的两种的用时在最慢的两个同时过桥的时候是y + x + n + y，在一直用最快的送二者过桥的时候是 m + x + n + x。两个时间相减为2y - x -m。上面的的描述是一个贪婪的过程，也就是每一次都送最慢的两个人过河。
贪婪决策之过桥问题：
	/**
	* 获取过桥问题的最小时间。这里的过桥每次最多两人，只有一个手电筒。
	*
	* @parem int times[] 所有人的过桥时间数组
	* @param int number 人数
	* @param bool sorted = false 是否传入的时间数组已经排好序，默认是false
	* @exception string 内部分配空间出错
	* @return int 返回过桥的最短时间
	*/
	int MinTimeCrossTheBridge(int times[], int number, bool sorted = false){
		assert(times && number > 0);
		int *_times = times; 
		//如果传入需要进行排序，那么在内部进行数组拷贝，不去直接操作原数组
		if(!sorted){
			_times = new int[number];
			if(!times)
				throw "内部空间分配出错";
			memcpy(_times, times, number * sizeof(int)); //是C函数，C中没有命名空间，所有函数都在全局空间中
			//排序_times
			std::sort(_times, _times + number);
		}
		if(number < 3)
			//只需要一趟就过完了，所以返回最慢的时间就行
			return _times[number - 1];
		if(number == 3){
			//只要三个人，那么只要一种情况就是使用最快的松另外两个过桥
			return _times[2] + _times[0] + _times[1];
		}
		int result = std::min(_times[1] + _times[0] + _times[number - 1] + _times[1],
								_times[number - 1] + _times[0] + _times[number - 2] + _times[0]
							) +
							MinTimeCrossTheBridge(_times, number - 2, true);
		//内部空间释放
		if(!sorted)
			delete[] _times;
		return result;
	}


196，子序列和最大值问题：一个数组的各个子数组中所有的元素的和构成各个子序列的和，求所有子序列和的最大值。
分析：
这个问题是非常常见的题目。网络上有多种版本的算法，在数据结构和算法的书籍上也可以见到这个问题的分析。主要的有n * n * n的暴力求解、n * n的简单优化(优化的部分是每一个起点往后依次求和，每次求和可以用上前面已经有的求和结果)、n * log(n)的分治(取出一个中间元素，不包括这个元素的左边求出最大右边求出最大，包括这个元素的时候依次往左累加计算最大，依次往右累加加上最大然后将变量的值加上这个中间值构成中间最大)、最简洁的却没有简单数学证明的一次遍历O(n)算法。
下面是O(n)的求解最大子序列和的算法：
	/**
	* 求解最大子序列和，算法复杂度O(n)
	*
	* @param int input[] 输入的待求解的数组
	* @param int length 输入数组的长度
	* @return int 返回最大子序列和
	*/
	int MaxSubsequencePlus(int input[], int length){
		assert(input && length >= 0);
		int result = 0, sum = 0;
		for(int i = 0; i < length; ++i){
			sum += input[i];
			if(sum < 0)
				sum = 0;
			if(sum > result)
				result = sum;
		}
		return result;
	}
	

197，不使用递归，实现单向链表的反序
分析：
单向链表的反序，如果使用递归，是先将head->next反序，然后将head追加到这个反序结果的最后面。如果不使用递归，那么可以保留一个prev记录下一次操作节点要重置的next属性，然后遍历整个链表，依次重置整个链表所有节点的next属性即可。
递归算法：
	typedef int ElementType;
	typedef struct Node{
		ElementType value;
		Node* next;
	} *PNode;

	/**
	* 使用递归进行单向链表的反序
	*
	* @param PNode head 要反序的链表的头
	* @return PNode 返回反序之后的新链表的头
	*/
	PNode ReverseUseRecursion(PNode head){
		if(!head || !head->next)
			return head;
		PNode next = head->next, subLink = nullptr;
		subLink = ReverseUseRecursion(next); //获取除了头节点的后续子链表的反序
		//将头结点添加到最终的结果上
		next->next = head;
		head->next = nullptr;
		return subLink;
	}
非递归反序算法：
	/**
	* 不使用递归进行单向链表的反序
	*
	* @param PNode head 要反序的链表的头
	* @return PNode 返回反序之后的新链表的头
	*/
	PNode ReverseNoRecursion(PNode head){
		PNode prev = nullptr, next = head, tmp = nullptr;
		while(next){
			tmp = next->next;
			next->next = prev;
			prev = next;
			next = tmp;
		}
		return prev;
	}


198，如果只知道一个单向链表中的非头非尾的中间结点，写一个算法，从链表中删除这个节点。
分析：
因为是中间节点，可以巧妙的将这个节点和其后续节点的内容进行互换(又因为后序节点要删除，所以这种互换只需要将后序节点的内容赋给当前节点)，然后再删除后续的那个节点，这样将当前的节点的next重置就完成了删除。考虑这个算法可以发现如果传入的节点是尾节点或者是null，那么这个算法是没有办法正常工作的。题目中已经说了传入的非头非尾，保证了算法的可行性。
代码：
	struct Node
	{
		int data;
		Node * next;
	};

	/**
	* 在只知道一个非头非尾的中间节点的情况下，删除这个节点
	*
	* @param Node * item  要删除的节点
	* @return bool  成功删除一个元素返回true 否则返回false
	*/
	bool DeleteMiddle(Node * item){
		if(!item || !item->next)
			return false;
		Node * next = item->next;
		item->data = next->data;
		item->next = next->next;
		delete next; //删除后续节点
		return true;
	}
	

199，快慢指针与单向链表有环判定：一个单向链表，里面可能存在环，如果进行判定。如果存在环如果找到环的入口
分析：
下面给出网络上和各种书籍上关于使用快慢指针的一般性分析：
	使用一个快指针，每一次走两步，使用一个慢指针，每一次走一步。如果快指针达到了NULL那么说明没有环，否则如果快指针与慢指针在随后的移动过程中相遇那么说明这个链表有环。如果存在环，就将其中一个指针移到链表头，然后将两个指针都设置为步长为1，当两个指针再次相遇的时候就是入口。
其次是个人关于快慢指针的补充说明分析：
	1）一个链表如果有环，而且又是单向的，那么从环的入口开始，后续的所有节点都在环内。可以很容易得知，最大的环就是一个循环链表。如果有环，那么快指针先进入环内进行循环。从慢指针第一次进入环内进行分析，此时快指针无论位于环内的任何位置，可以考虑为接下来形成了快指针在环内对慢指针的一次追赶。又因为快指针每一次两步，而慢指针每一次一步，那么每一次移动实际上是快指针向着慢指针的方向多行进了1。由于当慢指针再次回到环的入口的时候刚好走了一圈，而快指针会刚好走了两圈。结合上面的追赶分析，每次追赶一步，那么在这一圈的过程中，快指针(走了两圈)一定会追上并与慢指针(走了一圈)重合过（由于每一次只是追赶一步，在第一次相遇之后，下一次相遇时慢指针刚好又走了一圈，所以这里可以得到在慢指针走的第一圈中有且仅有一次与快指针的相遇）
	2）关于快指针，为何步长为2，是不是可以为其他的步长。假设如果慢指针为1，快指针为3，那么每次追赶会是2步，这就有了一个问题，也就是快指针与慢指针不一定相遇，可能会出现跨过慢指针而跑到慢指针前面去。一个简单的例子，环长度为2，慢指针进来的时候，快指针在入口之外的另一个点，那么如果设置的步长为1和3，会出现快指针和慢指针永远不可能相遇的情况(因为快指针每次移动3，模上2实际上可以认为和慢指针一样每次只走了1)。进一步的分析，可以发现只要设置步长之差为1就可以满足快慢指针的使用要求(因为步长相差为1的两个数模上圈长只有在圈长为1的时候才是相同的结果，而圈长为1表示快慢指针始终重合)。所以说实际使用中为了方便设计了最简单的步长为1的组合：慢指针为1，快指针为2.
	3）关于环入口判定证明：假设在快慢指针第一次相遇的时候慢指针在环外走了x步在环内走了y步，环的长度为l，快指针已经在环内走了n圈，那么慢指针一共走了x + y步，快指针已经走了2 * (x + y)步。可以得到 2 * （x + y） = x + nl + y。nl = x + y。这个公式指出如果将一个指针返回链表起始点，另一个指针在这个相遇点，二者都设置为步长为1，当圈内的指针走了n圈之后，那么圈外面的指针恰好运动到这个相遇点，也就是说二者又会在这个相遇点重新相遇。结合前面步长都设置为1，那么这两个指针由于在这个相遇点重新相遇，很容易分析出，这个相遇点向后退y，又是环的入口处，二者也是相遇的。所以如果在有环的前提下，可以将其中一个指针移动到链表的起点然后将两个指针的步长都设置为1，当二者第一次相遇的时候就是环的入口。
实操代码：
	/**
	* 判定一个单向链表是否存在环，如果存在环就返回环入口指针
	*
	* @param PNode head 要判断的链表
	* @return PNode 返回环的入口，如果不存在环就返回nullptr
	*/
	PNode IsLoop(PNode head){
		if(!head)
			return nullptr;
		PNode slow = head, fast = head; //慢指针、快指针
		while(fast && fast->next){
			slow = slow->next;
			fast = fast->next->next;
			if(slow == fast){
				//快慢指针相遇代表有环,寻找环入口
				slow = head;
				while(slow != fast){
					slow = slow->next;
					fast = fast->next;
				}
				return slow;
			}
		}
		//快指针退出了循环，走到了链表的末尾，说明没有环，返回nullptr
		return nullptr;
	}


200，给出一个单向链表，如果通过快慢指针操作寻找其中的中位数或者是寻找倒数第K个元素。
分析：
对于寻找中位数，可以用一个快指针设置为步长为2，一个慢指针设置为步长为1，这样当快指针为null或者是快指针的next为null的时候慢指针就指向了中位数。这个结果分析如下：假设快指针停止的时候慢指针走了x步，如果快指针停止的时候快指针本身是null，那么一共存在节点1+2x-1，这个时候慢指针停在了1+x的位置，可以得到这种情况下总的节点数的是偶数，这个时候慢指针的前一位是中位数。另一种情况，如果快指针停止的时候快指针的next为null，那么总的节点数1+2x,而慢指针停在了1+x的位置，所以慢指针这个时候返回的就是中位数。对于总的节点数是偶数的情况，上面指出多移动了一次慢指针，而单向链表中指针回倒是麻烦的，一个简单的方法是在循环的时候记录下慢指针的前一个节点。
寻找中位数的代码：
	typedef struct Node
	{
		int data;
		Node * next;
	} *PNode;

	/**
	* 获取一个单向链表的中位数

	* @param PNode head 要获取中位数的链表
	* @return PNode 返回中位数的指针，如果链表是空的就返回nullptr
	*/
	PNode GetMedian(PNode head){
		PNode slow = head, fast = head, pre = head; 
		while(fast && fast->next){
			pre = slow; //记录下慢指着的前一个元素
			fast = fast->next->next;
			slow = slow->next;
		}
		if(!fast)
			return pre; //快指针最后到了null，说明链表节点数为偶数，这个时候返回的是慢指针最终位置的前一个节点
		return slow;
	}
	
对于寻找倒数第K的元素，我们可以用两个步长为1的指针看，第一个指针先走K步，如果在这之前这个指针到达了null说明一共存在的元素不到K个。当第一个指针走了k步之后，然另一个指针从链表的起始位置开始走，然后在第一个指针到达null的时候另一个指针停在的位置就是倒数第K个元素（两个指针一直相差K，而其中一个停在了null，可以从null假设为0往回数K）。
寻找倒数第K个元素的代码：
	/**
	* 获取一个单向链表中的倒数第K个 元素
	*
	* @param PNode head 要获取中位数的链表
	* @param int k 要获取的位置k
	* @return 返回倒数第K个元素，如果整个链表的长度不足K那么会返回nullptr
	*/
	PNode GetLastKElement(PNode head, int k){
		PNode slow = head, fast = head;
		int i = 0;
		while(i < k && fast){
			i++;
			fast = fast->next;
		}
		if(i < k){
			//整个链表的长度是小于K的
			return nullptr;
		}
		while(fast){
			slow = slow->next;
			fast = fast->next;
		}
		return slow;
	}


201，两个单向链表，如何判定这两个链表是否存在相交。如何寻找它们的交点。
分析：
由于是单向链表，那么一旦在一个点相交了，那么后续这两个链表也就是完全一样的了。这里如果不考虑链表中存在环的情况，那么可以先获取到两个链表的长度，然后让较长的链表的指针从头走到与短链表一样长的地方，然后两个链表同时向后遍历，如果某一个节点相同了，那么这个节点就是两个链表的交点，如果这两个链表不相交那么他们的交点会是最后的NULL。
下面分析链表如果出存在环的情况。首先，如果一个链表存在环，另一个链表不存在环，可以很容易通过反证法得到这两个链表一定是不相交的（因为一个链表是到不了null的而另一个会到达末尾的null）。那么两个链表如果相交并且有环，那么它们必定都是有环的。因为是单向链表，一旦进入环就出不来，所以两个链表只能共用一个环。判断两个有环的链表是否相交可以在一个链表中查找另一个链表的环入口节点，如果相交由于共用一个环所以必然找得到该节点，如果找不到那么就两个有环链表就不相交。紧接着分析，这两个链表进入环的入口节点是否一样又可以进行两个分析，如果两个链表入环点是一样的，那么可以从这个入环点向回倒退一直找到二者第一个相同的节点为两个链表的交点。如果两个链表的入口节点不一样，那么很容易得到在入环之前二者是没有重合的节点的。这个时候二者所有的交点都在环内，根据实际情况可以返回其中一个入环点为二者的交点。
补充：
如果发现两个链表都是有环的并且环的入口是一样的，那么这种情况返回的交点可能在环的外面，这种情况可以以环的入口为尾部，然后从两个头部到这个尾部可以看做是两个无环的链表相交交点分析。
代码：
	struct Node
	{
		int data;
		Node * next;
	};

	/*这个结构体用于保存一个链表的环的入口和入口到链表起始点的距离。如果一个链表无环，入口点应该保存为null，距离应该为链表的长度*/
	struct PointAndLen
	{
		Node * point;
		int length;
	};

	/**
	* 获取一个链表的环的入口和入口到链表头的距离，如果链表无环，那么入口返回的是null，而距离返回的是链表的长度
	* @param Node* head  参与计算的链表
	* @return PointAndLen 获取到的环入口和入口到头节点的距离.
	*/
	PointAndLen GetPointAndLen(Node * head){
		PointAndLen toReturn = {nullptr, 0};
		Node * slow = head, *fast = head;
		//寻找环的入口
		while(fast && fast->next){
			fast = fast->next->next;
			slow = slow->next;
			if(slow == fast){
				//有环
				slow = head;
				while(slow != fast){
					slow = slow->next;
					fast = fast->next;
				}
				break;
			}
		}
		if(fast && fast->next){
			toReturn.point = slow; //交点
		}else{
			toReturn.point = nullptr;
		}

		//计算交点到链表起始点的距离
		while(head != toReturn.point){
			head = head->next;
			toReturn.length++;
		}
		return toReturn;
	}

	/**
	* 获取两个单向链表的交点
	* @param Node* link1 单向链表1
	* @param Node* link2 单向链表2
	* @return Node* 返回两个链表的交点
	* @note 如果不相交，会返回null
	*/
	Node* GetIntersectionOfLinks(Node* link1, Node* link2){
		PointAndLen pl1 = GetPointAndLen(link1),
					pl2 = GetPointAndLen(link2);
		Node * toReturn = nullptr;
		if(!pl1.point && !pl2.point){
			//两个都无环情况
			Node * ptr1 = link1, * ptr2 = link2;
			int sub;
			if(pl1.length > pl2.length){
				//链表1更长一些，让链表1先移动一段距离
				sub = pl1.length - pl2.length;
				for(int i = 0; i < sub; ++i)
					ptr1 = ptr1->next;
				
			}else{
				//链表2更长一些
				sub = pl2.length - pl1.length;
				for(int i = 0; i < sub; ++i)
					ptr2 = ptr2->next;
			}
			//两个链表视为等长的时候同时向后移动两个指针
			for(; ptr2 != ptr1; ptr2 = ptr2->next, ptr1 = ptr1->next){}
			toReturn = ptr2;
		}else if(pl1.point && pl2.point){
			//两个都有环情况
			if(pl1.point == pl2.point){
				//两个的环的入口是一样的，这个时候，可以将环的入口当做尾节点，对两个链表进行类似于无环相交的分析
				int sub;
				Node * ptr1 = link1, *ptr2 = link2;
				if(pl1.length > pl2.length){
					//链表1的起始点距离环的入口更远一些
					sub = pl1.length - pl2.length;
					for(int i = 0; i < sub; ++i){
						ptr1 = ptr1->next;
					}
				}else{
					//链表2的起始点距离环的入口更远一些
					sub = pl2.length - pl1.length;
					for(int i = 0; i < sub; ++i){
						ptr2 = ptr2->next;
					}
				}
				for(; ptr2 != ptr1; ptr1 = ptr1->next, ptr2 = ptr2->next){}
				toReturn = ptr1;
			}else{
				//两个环的入口不一致，通过反证法可以知道这两个链表中的环一定是同一个。那么在两个链表入环之前是不可能产生相交的。所以这个时候可以返回任意一个链表的入口作为相交点
				//在一个链表上查找另一个链表的入口点，如果找到了就表示二者相交，否则它们不相交
				bool found = false;
				for(Node * ptr = pl1.point->next; ptr != pl1.point; ptr = ptr->next){
					if(ptr == pl2.point){
						found = true;
						break;
					}
				}
				if(found)
					//返回其中一个链表的入口当做相交点
					toReturn = pl1.point;
				else
					toReturn = nullptr;
			}
		}else
			//一个有环一个无环，这种情况下两个链表不可能相交，所以结果是null
			toReturn = nullptr;
		return toReturn;
	}




202，单向链表相交判定的应用：网页爬虫的原理是从一个入口的网页开始查找这个网页中所有的url，然后紧接着查找下一个url中包含的url。这个查找的结束条件是查找某一个页面的时候发现其中所有的页面都已经被查过了或者是某一个页面中不包括任何的url了。现在简化问题为一个页面只能包含一个url，爬虫通过爬两个入口网页形成了两个链表，如何判定这两个链表中是否存在相同的url。
分析：
两次组成的链表内存结构是分开的，也就是物理上next不是有环无环的依据。链表中有一个url属性是这个页面上存放的url，这个url可能为空。所以实际分析链表的相交性主要是集中在url属性上。同一般性的链表相加分析一样，首先如果两个链表是无环的（这里的有环无环是相对于url属性的）那么爬虫在两次走到相同的url之后接下来链表节点中的url属性都是一样的，通过这个分析可以知道两个链表中的最后一个节点的url属性是一样的。上述的分析是判断无环的两个链表相交的，如果有环相交，和一般性判断一样二者要想相交一定都是有环的，而且一定是有一个相同的环(因为是单向链表，进入一个环就不能出来再进入另一个环)。可以很容易的分析得到两个链表的尾部节点一定都在环上，所以在存在环的时候可以在一个链表中查找另一个的尾节点，如果找到就表示有环相交，如果没有找到就不可能相交。
上面尽管分析了两种情况，但是仔细分析可以发现可以通过一个操作合并两种分析，那就是先找到一个链表的尾部节点，然后在另一个链表中寻找这个尾部节点，如果是在另一个链表的非尾部找到了，我们可以通过反证法知道原先的尾部节点所在的链表一定是构成了环的，二者有环相交。如果是在另一个链表的尾部找到，那么可以认为是两个无环链表相交（其实也可能是相同的环入口相交，这是一个临界情况）。
实测代码：
	struct URLNode
	{
		std::string url;
		URLNode * next;
	};

	/**
	* 判断两次爬虫构成的链表中是否存在重合的url
	*
	* @param URLNode * list1 爬虫采集到的链表1
	* @param URLNode * list2 爬虫采集到的链表2
	* @return bool 如果两个链表中存在相同的url就返回true 否则返回false
	* @note 通过内部详细的分析，只需要在一个链表中寻找另一个链表的尾节点url，如果找到了就是相交的，这包括了有环相交和无环相交
	*/
	bool IsIntersected(URLNode * list1, URLNode * list2){
		if(!list1 || !list2)
			return false;
		URLNode * tail1 = list1;
		//寻找第一个链表的尾节点
		while(tail1->next)
			tail1 = tail1->next;
		//在另一个链表中寻找尾节点的url
		for(URLNode * p = list2; p != nullptr; p = p->next){
			if(p->url == tail1->url)
				return true;
		}
		return false;
	}


203，一个单向循环链表，设计一个算法去除连续的重复元素。
分析：
首先从头到尾（这里指的是下一次回到头之前）遍历，如果后一个元素和前面的元素的内容重复就删除后一个元素，这里存在两个指针，一个保存前一个元素一个保存后一个元素。如果进行了后一个元素的删除，那么前一个元素的指针维持不变，否则两个指针都会进行后移。
其次，一直删除到最后一个元素，再次回到头节点的时候，如果最后一个元素的内容与头结点重复了，那么会删除头结点，然后整个链表返回的头结点发生了改变。这个时候如果要保留返回的头结点不变，而是删除最后一个重复元素，可以知道由于是单向链表，需要保留删除的尾节点的前一个元素，而这种保留对于之前遍历去重操作来说是不一致的，是麻烦的。所以总体来看，这里如果是尾节点和头结点重复了，最方便的做法是删除头结点。
代码：
	typedef struct Node
	{
		int data;
		Node * next;
	} *PNode;


	/**
	* 去除一个单向循环链表中的连续重复元素
	*
	* @param PNode link 要删除的链表
	* @return PNode 返回删除之后的循环链表
	*/
	PNode RemoveDuplicate(PNode link){
		if(!link)
			return link;
		PNode p = link, q = link->next, tmp = nullptr; //分别为前一个元素，后一个元素
		while(q != link){
			tmp = q->next;
			if(q->data == p->data){
				//去重，删除后续元素
				delete q;
				p->next = tmp;
			}else{
				p = q;
			}
			q = tmp;
		}
		//q为传入的头节点，p为尾部节点，处理这种特殊情况
		if(q == p){
			//特殊情况，q和p重合了，表示这个链表中原先所有的元素都是一样的
			return p;
		}
		if(q->data == p->data){
			p->next = q->next;
			delete q;
			return p;
		}
		return link; //返回传入的头结点
	}


204，一个链表中每一个节点，除了保存一个后续元素的指针，还保存一个链表中的其他的元素的指针。对于这样的结构的链表，设计一个算法进行链表的拷贝。
分析：
构建新的链表，可以依次遍历原来的链表，进行节点的拷贝和next指针的赋值，但是这里出现的一个问题是节点中存在的另一个指针可能指向了还没有构建出来的节点上，所以拷贝不能一步完成。考虑在创建完成拷贝链表的所有节点的情况下，如果依次遍历这个拷贝链表然后进行另一个指针的赋值，那么从原链表中的关系映射查找会出现一个二次复杂度的算法。如果在创建拷贝的链表的过程中，保留原节点和拷贝节点之间的映射关系为hash结构。这样可以将复杂度降为线程。
实际上，在相关的书上可以找到不使用hash进行额外的空间开销也能实现线性的拷贝。方法是这样的，我们在拷贝节点的时候直接将每一个节点插入到原来的链表中的相应的节点的后面。这样就实现了一个类似的简单映射。在创建完成所有的节点拷贝节点之后，依次使用映射关系对拷贝节点的“另一个指针”进行赋值。然后，我们可以将所有的奇数位重组为原链表，而所有的偶数位重复为拷贝的结构(这里的重组指着的是重写修改每一个节点的next)。
代码：
	typedef struct Node
	{
		int data;
		Node * next;
		Node * sibling; //另一个指针，保留链表中的任意节点的指针
	} *PNode;

	/**
	* 拷贝一个指定格式的链表，这个链表中每一个节点除了拥有后续节点的指针还有一个指向其他任意元素的指针
	*
	* @param PNode src 要拷贝的链表
	* @return PNode 拷贝得到的链表
	*/
	PNode CopyList(PNode src){
		if(!src)
			return nullptr;
		PNode p = src, q;
		//节点拷贝
		while(p){
			q = new Node;
			//将拷贝的节点插入到原节点的后面
			q->data = p->data;
			q->next = p->next;
			p->next = q;
			p = q->next;
		}
		//调整拷贝的节点的另一个指针
		for(p = src; p;){
			q = p->next; // 拷贝节点
			q->sibling = p->sibling->next;//映射关系
			p = q->next;
		}
		//调整next指针，将拷贝链表和原链表进行分离
		PNode toReturn = src->next;
		for(p = src; p; p = p->next){
			q = p->next;
			p->next = q->next;
			if(q->next)
				q->next =  q->next->next;
		}
		return toReturn;
	}


205，栈的应用之后缀表达式：如何将一个中缀表达式转换为后缀表达式。一个后缀表达式，如何计算值。
分析：
后缀表达式的好处是完全不需要使用括号。后缀表达式是波兰人提出因此也称为逆波兰式。后缀表达式的计算可以使用一个栈，扫描表达式如果遇到了操作数就压入栈，如果遇到了操作符就从栈中取出两个操作数计算结果并且将结果重新压入栈。当整个表达式扫描结束的时候最后栈中留下的就是最终的结果。
关于中缀表达式转换后缀表达式：
如果这个问题出在面试笔试中，可以使用一种加括号的方法，首先在中缀表达式上对不同优先级加上所有的括号，然后再将所有的操作符移到括号的后面，最后去掉所有的括号，就得到了所求的后缀表达式。例如 a+b*c+(d*e+f)*g，这个中缀加上括号的形式是((a + (b*c)) + (((d*e) + f)*g))，将所有操作符移动到括号的外部并且去掉括号为abc*+de*f+g*+。另一种在笔试中常见的方法是将中缀表达式对应的语法二叉树画出来，然后对这个树进行直接写出后缀。
这个问题如果是要代码求解，那么一般可以使用两个栈，一个用来存放扫描到的操作符，另一个存放最终的结果(准确的说，这个结果是倒的)。当扫描到操作数的时候直接存入到结果栈中，当扫描到操作符的时候，如果操作符是左括号，那么直接入栈，如果是右括号就将所有的读到了左括号之前的操作符都压入结果栈，左括号出栈丢弃(实际上一对括号包裹的是一个同样的子问题)。对于操作符的优先级，如果读到的操作符的优先级比操作符栈中的更低或者一样那么要先计算前面的表达式，然后才能将当前的操作符入栈。
使用两个栈进进行转换的代码如下：
	/**
	* 将一个中缀表达式的字符串转换为后缀表达式的字符串
	*
	* @param std::string str 传入的中缀表达式字符串
	* @return std::string 获取到的后缀表达式字符串
	*/
	std::string InOrder2Post(std::string str){
		std::string toReturn;
		stack<char> op, result;
		map<char,int> priorities; //存放所有的操作符对应的优先级
		priorities['(']  = 0; //优先级最低
		priorities['+'] = priorities['-'] = 1;
		priorities['*'] = priorities['/'] = priorities['%']  = 2;

		//扫描
		auto end = str.end();
		char c;
		for(auto it = str.begin(); it != end; ++it){
			c = *it;
			switch(c){
				case '(':
					//左括号，直接压入操作符栈
					op.push(c);
					break;
				case ')':
					//将一对括号中还没有出栈的符号全部弹出，最后丢弃前面的左括号
					while(op.top() != '('){
						result.push(op.top());
						op.pop();
					}
					//弹出左括号
					op.pop();
					break;
				case '-':
				case '+':
				case '*':
				case '/':
				case '%':
					//是符号，那么将栈顶比当前符号优先级更高或者一样的符号先进行运算
					while(!op.empty() && priorities[op.top()] >= priorities[c]){
						result.push(op.top());
						op.pop();
					}
					//将当前的操作符压入操作符存储栈
					op.push(c);
					break;
				default:
					//是操作数，直接入结果栈
					result.push(c);
					break;
			}
		}
		//将操作符栈中还没有出栈的所有的操作符出栈
		while(!op.empty()){
			result.push(op.top());
			op.pop();
		}
		//将结果栈中字符依次读出，构成结果字符串
		while(!(result.empty())){
			toReturn.push_back(result.top());
			result.pop();
		}
		//将结果字符串翻转，因为栈中存放的结果读取到的是反的
		reverse(toReturn.begin(),toReturn.end());
		return toReturn;
	}


206，栈和队列有何异同。
二者都是线性存储结构。但是栈只能在一端进行插入和删除，而队列规定只允许在一端插入(队尾)在另一端删除(对头)。栈是先进后出的，而队列是先进先出的。 

207，用数组实现循环队列
分析：
因为头和尾部如果一直都往后走，前面的空间就浪费了，所以队列一般是循环的。使用数组构建循环队列，使用head和tail标记队首和队尾。一开始head和tail都在数组0脚标位置，如果插入tail就会加1，如果删除head就会加1，在到达数组的末尾的时候可以将他们重新调整为0。可以通过head==tail判断队列为空，可以很容易知道如果一个数组的长度是n，那么设计的队列的最大容量是n-1，因为假设head不动tail在插入第n个元素的时候会head重合，而这种情况队列被判定为空。
代码：
	template<class T>
	class MyQueue
	{
		T *data;
		int head, tail, length; //队首、队尾、数组长度
	public:
		MyQueue(int length = 10){
			this->length = length;
			head = tail = 0;
			data = new T[length];
			if(!data){
				std::cerr << "new memory error" << std::endl;
			}
		}
		//判断是否为空
		bool empty(){
			return head == tail;
		}
		//判断是否满了
		bool full(){
			return length - 1 == (tail + length - head) % length; //因为tail可能比head还小，所以这里加上一个length.
		}
		//插入元素
		bool push(T e){
			if(full())
				return false;
			data[tail++] = e;
			tail %= length;
			return true;
		}
		//删除元素
		void pop(){
			if(empty())
				return;
			head = (head + 1) % length;
		}
		//获取队首元素
		T front(){
			//note：这里有一个逻辑问题，在取元素的时候是否应该判断是否为空。实际上一般是在调用的时候判断是否为空，然后进行取。如果这里再加一个为空判断就有点多余，还有就是这种异常可以认为不是“取”这个动作引起的，而是使用这个动作不当引起的。所以这里不加上为空判断，而是直接取元素。
			return data[head];
		}
		//获取大小
		int size(){
			return (tail + length - head) % length;
		}
		~MyQueue(){
			//释放内部数组
			delete data;
		}
	};


208,stl中的stack拷贝是深拷贝还是浅拷贝
答案：
通过测试发现stack的拷贝是深拷贝。进一步推测stl中的各种数据结构的拷贝构造函数应该都是做了深拷贝的处理。


209，写一个算法：使用来个栈实现数据的升序排序。
分析：
一个栈当做结果栈，里面的数据是从小到大进行排序的，而另一个栈是传入栈。我们可以先从传入栈中拿出一个元素，然后和结果栈中的最顶端的元素相比较，如果结果栈的顶端比较大就将结果栈的栈顶压入传入栈，一直压到合适的栈顶，然后将取出来的元素压入结果栈。重复这个步骤一直到传入栈为空，返回结果栈，整个算法结束。
代码：
	/**
	* 将一个stack中的元素进行升序排序
	*
	* @param stack<int> src 要排序的栈
	* @return stack<int> 排好序的栈
	*/
	stack<int> SortStack(stack<int> src){
		stack<int> result; //结果栈
		int tmp;
		while(!src.empty()){
			//取出输入栈的顶端元素
			tmp = src.top();
			src.pop();
			//将结果栈中比当前要插入的元素更大的都再压入输入栈
			while(!result.empty() && result.top() > tmp){
				src.push(result.top());
				result.pop();
			}
			//将元素插入到结果栈的栈顶，此时结果栈保持了升序
			result.push(tmp);
		}
		return result;
	}


210，如何使用两个stack实现一个queue。
分析：
我们可以使用一个stack进行插入，而另一个进行取出，如果取出的栈中没有元素，那么将插入的栈中所有的元素全部弹出到取出栈，然后栈顶就是最早插入的元素。
代码：
	/**
	* 使用两个stack实现的queue
	*/
	template<class T>
	class MyQueue
	{
	private:
		stack<T> in, out; //插入栈、读取栈
	public:
		bool empty(){
			return in.empty() && out.empty();
		}
		T front(){
			//如果输出栈为空，将输入栈的所有元素压入输出栈
			if(out.empty()){
				//将输入栈中的所有元素都压入输出栈
				while(!in.empty()){
					out.push(in.top());
					in.pop();
				}
			}
			//取出输出栈的栈顶元素 返回
			return out.top();
		}
		void push(T e){
			out.push(e);
		}
		void pop(){
			//如果输出栈为空，将输入栈的所有元素压入输出栈
			if(out.empty()){
				while(!in.empty()){
					out.push(in.top());
					in.pop();
				}
			}
			//弹出输出栈的栈顶元素
			if(!out.empty())
				out.pop();
		}
		int size(){
			return in.size() + out.size();
		}
	};


211,树的基本概念
分析：
树是n个节点的有限集。森林是互不相交的树的集合。一个节点的度是这个节点所有的子节点的数量，而一棵树的度是这个树中所有节点的度的最大值。树中节点的最大层数构成树的高度（也是深度）。有序数是从左到右子节点是有顺序区别的，无序数各个子节点没有顺序上的区别。
关于树的四个基本性质：
1）一棵树的节点数等于所有节点的度的和加1。这个性质可以通过下面的观察得到：从树叶开始往上看，每一层节点都是上一层节点进行度数统计的时候的子节点，只存在一个例外，就是根节点，根节点不是任何节点的子节点。所以所有的节点数量减一是所有节点的度数和。
2）度为m的树第i层最多存在m^(i-1)个节点。
3）高度为h的m叉树至多有(m^h-1)/(m-1)。这一点性质可以通过上面的性质2推出来，就是每一个节点的度数都为m的情况，构成了一个等比数列。
4）具有n个节点的m叉树的最小高度是ceil(logm(n*(m-1) + 1))。这个性质其实是上面的性质3的另一种表述，通过上面的性质3可以知道n <= (m^h-1)/(m-1)，转换一下就可以得到性质4。关于向上取整，意思是可能最后一层放不满。
关于二叉树：
二叉树是有序树，左右节点如果交换，那么表示的是另一棵不同的树。值得注意的是二叉树并不是简单的度为2的有序树。度为2表示一棵数的节点的最大的度，那么度为2至少需要存在三个节点。但是二叉树即使是空树也还是一个概念上的二叉树。同样二叉树即使另一个节点是空的，也存在左右之分，也就是这种左右的顺序不是简单的向有序树那样只是相对于兄弟节点而言。对于树的性质1应用到二叉树上面，可以得到叶子节点n0与度为2的节点数量n2的关系存在n0 = n2 + 1（当然这个前提是树非空）。


212，一个度数为4的树，其中存在20个度数为4的节点，10个度数为3的节点，1个度数为2的节点，10个度数为1的节点。那么这个树的叶子节点个个数是多少。
分析：
因为树的度数为4，而所给的条件中只有度数为0的节点数量没有给出。所以可以通过树的性质1：一个数的所有节点的数量等于所有节点的度的和加上1。列出一个一元等式，即可求解出叶子节点。
具体的，设叶子节点为n0，那么： 20 + 10 + 1 + 10 + n0 =  20 * 4 + 10 * 3 + 1 * 2 + 10 * 1 + n0 * 0 + 1(最后这个1表示额外的差值)。可以求得n0 = 82


213，一棵二叉树中度为1的节点数量为8，叶子节点的数量为3，那么这个树一共有多少节点。
分析:
这里隐藏了度为2的节点数量为叶子节点减一也就是2。所以所有的节点数量是8 + 3 + 2 = 13


214，一个完全二叉树中有770个节点，那么 叶子节点的数量是多少。
分析：
完全树表示节点是一层一层的铺满的，对于二叉树，那么度为1的节点要么为0要么为1(最后可能出现一个叶子节点没有兄弟)。又n0 = n2 + 1，可以知道除了度为1的节点外，在二叉树中其他的节点的和一定是奇数。现给出了节点的总数量是770，这是一个偶数，那么说明这个完全二叉树中度为1的节点的数量应该是1，所以n0 + n0 -1 + 1 = 770，n0 = 385


215，二叉树的广度优先访问算法
分析：
利用给队列，首先将根节点放入队列。然后进入一个循环：只要队列不为空，从队列取出一个元素，访问这个元素的内容，然后将这个元素的左右节点都插入到队列中。当循环结束的时候就访问到了整个树。
代码：
	struct Node
	{
		int data;
		Node *left, *right;
	};

	/**
	* 对一个二叉树进行广度优先访问
	*
	* @param Node *T 要访问的二叉树
	*/
	void WideFirst(Node * T){
		if(!T)
			return;
		std::queue<Node*> q;
		Node * t = nullptr;
		q.push(T);
		std::cout << "{";
		while(!q.empty()){
			//访问节点的内容
			t = q.front();
			std::cout << " " << t->data;
			//将节点的左右节点都插入队列
			if(t->left)
				q.push(t->left);
			if(t->right)
				q.push(t->right);
			//节点访问完毕，从度列中移除
			q.pop();
		}
		cout << " }" << endl;
	}


216,给出二叉树的非递归的形式的先序、中序、后续遍历代码
分析：
先序分析：
先序的访问顺序是先根节点然后左子树（访问左子树必定先要访问左子节点），待整个左子树访问完毕之后再去访问整个右子树（访问右子树必定先访问右子节点）。所以可以先从根节点开始一直e->left访问所有的左边的节点，在这个过程中使用栈保存所有的e->right（除非为空不保存），然后当e->left为空的时候就说明要访问上一个保存的right节点，这个时候从栈中取出最近的一个right节点，然后可以视为把它当做一个“根节点”重复上面的步骤，整个循环结束的条件是e->left为空了并且栈为空取不出来元素了。
先序代码：
	struct Node
	{
		int data;
		Node *left, * right;
	};

	/**
	* 使用非递归的方式，进行先序遍历二叉树
	*
	* @param Node *T 要遍历的二叉树
	*/
	void PreOrderWithoutRecursion(Node * T){
		std::stack<Node*> s; //用于保存后续要访问的右子树(右子节点)
		Node * p = T;
		std::cout << "{";
		while(p || !s.empty()){
			if(p){
				//如果p不为空就访问p
				std::cout << " " << p->data;
				//将p的右子节点入栈，作为后续的待访问节点
				if(p->right)
					s.push(p->right);
				//接下来访问p的左子节点
				p = p->left;
			}else{
				//p为空，就从栈中取出最近的待访问节点，赋值给p
				p = s.top();
				s.pop();
			}
		}
		std::cout << " }" << std::endl;
	}
中序分析：
中序和先序有点类似，但是中序应该首先将根节点和e->left一直到空的节点都保存到栈。如果e->left为空了就从栈中取出来一个节点进行访问，然后将这个节点的右子节点当做“根节点”重复进行上述操作，如果右子节点为空或者访问结束就从栈中取出下一个节点。循环结束的条件是节点指针e->right为空并且栈中没有元素可以取出。
中序代码：
	/**
	* 使用非递归的方式，进行中序遍历二叉树
	*
	* @param Node *T 要遍历的二叉树
	*/
	void InOrderWithoutRecursion(Node * T){
		std::stack<Node*> s; //用于保存后续要访问的左子树(左子节点)
		Node * p = T;
		std::cout << "{";
		while(p || !s.empty()){
			if(p){
				//将p压入栈
				s.push(p);
				p = p->left;
			}else{
				//p为空，从栈中取出一个节点访问，然后将指针置到右子树
				p = s.top();
				s.pop();
				std::cout << " " << p->data;
				p = p->right;
			}
		}
		std::cout << " }" << std::endl;
	}
后序遍历分析：
首先，和中序一样，将根节点和e->left全部进行保存到栈。当e->left为空的时候可以认为一个左子树访问完毕，这个时候从栈中取出一个元素，去访问其右子树，对于右子树的访问，因为可以认为是一个递归，所以可以套入一个循环中只是调整“根节点”。当右子树访问完毕之后，就可以访问栈中之前取出来的元素，然后将其从栈中移除，移除这个操作可以认为是一个“左子树”的访问完毕(这个时候可以把循环中的e置空，效果可以认为是将一个左子树看做了null)。重复上面的过程一直到最后一个将e置为null并且栈中没有元素。现在分析一个麻烦问题：因为在从栈中取出一个元素如果其右子树不为空，那么先要访问其右子树，也就是这个时候这个元素是仍然保存在栈中的，那么其右子树访问完毕之后，再取到这个元素的时候如何避免重复又去访问其右子树。这个问题是后序遍历与另两种遍历的相比的麻烦所在（因为节点是后与其右子树得到访问，节点在访问右节点之前是不能出栈的）。解决这个问题的一个好的解决方案是，设置一个指针变量，保存每一次访问的节点。因为一个节点的右子节点是紧邻它之前的一个访问元素，那么在访问一个节点之前只需要查看该节点的右子节点是否是保存的最近访问节点就知道是否该将这个元素出栈了。
后序代码：
	/**
	* 使用非递归的方式，进行后序遍历二叉树
	*
	* @param Node *T 要遍历的二叉树
	*/
	void PostOrderWithoutRecursion(Node * T){
		std::stack<Node*> s; //用于保存后续要访问的左子树(左子节点)
		Node * p = T;
		Node * l = nullptr; //保存最后一个访问节点
		std::cout << "{";
		while(p || !s.empty()){
			if(p){
				//将p压入栈
				s.push(p);
				p = p->left;
			}else{
				//p为空，从栈中取出一个节点，如果其右节点为空或者已经访问完毕就访问这个节点然后弹出，否则访问其右子树
				p = s.top();
				if(!p->right || p->right == l){
					//右节点访问过，就访问当前节点
					cout << " " << p->data;
					//记录最后访问的节点
					l = p;
					s.pop();
					p = nullptr; //当前分支访问完毕，重置循环判定条件，让循环接着从栈中取出元素
				}else{
					p = p->right; //可以认为有了一个新的“根节点”入栈
				}
			}
		}
		std::cout << " }" << std::endl;
	}


217，两颗二叉树，在左右子树可以进行旋转的情况下，如果判断两个二叉树是否相同。
分析：
如果是书写递归，这个会从语意上很容易完成，首先判断当前给的两个根节点是否相同，然后判断左右子树是否都相等（因为涉及到旋转，所以会有两种情况一种是左边对左边一种是左边对应另一颗树的右边）.
代码：
	struct Node
	{
		int data;
		Node *left, * right;
	};

	/**
	* 在二叉树的左右子树可以旋转的情况下，判读两个二叉树是否相同
	*
	* @param Node * T1 比较的二叉树1
	* @param Node * T2 比较的二叉树2
	* @return bool 如果两个二叉树相同返回true，否则返回false 
	*/
	bool Equal(Node * T1, Node * T2){
		if(!T1 && !T2)
			//两个都是空树
			return true;
		else if(!T1 || !T2)
			//其中只有一个是空树
			return false;
		if(T1->data == T2->data){
			return Equal(T1->left, T2->left) && Equal(T1->right, T2->right) ||
					Equal(T1->left, T2->right) && Equal(T1->right, T2->left);
		}else{
			//根节点的值不一样
			return false;
		}
	}

218，使用递归求解二叉树的深度。
分析：
一个二叉树的深度是根节点到树叶的路径中的最长者。如果使用递归求解深度，二叉树的深度等于根节点的左右子树的深度的较大者然后加1.
代码：
	typedef struct Node
	{
		int data;
		Node *left, *right;
	} *PNode;

	int GetHeight(PNode T){
		if(!T)
			return -1; //空树的高度是-1，注意这种写法下，第一层根节点的深度是0，表示第0层。但是对于根节点有的书上说的是第1层，有的书上说的是第0层，这里存在理解上的小差异。
		return 1 + std::max(GetHeight(T->left), GetHeight(T->right));
	}


219，求一个二叉树中相距最远的两个节点之间的距离。两个节点之间的距离指的是连通这两个节点的路径上的路径长。
分析：
两个最远的节点可以是一个节点在左子树，一个节点在右子树，也可能是两个节点都在同一个子树上。如果采用递归可以这样想：求解左右子树上的最远距离，然后求解通过根节点的最远距离。通过根节点的距离的计算应该是左右子树中的最深的节点分别通过根节点相遇。这样就会发现递归的过程中需要保留下来左右子树的高度和左右子树的距离这两个数据。我们可以设计一个算法这个算法的返回值是一个复杂结构，结构两个部分分别保存距离和高度。对于空树，高度这里可以认为是-1，距离是0（因为我们的认知好像距离不能为负数），只有一个节点的树高度是0距离是0。
代码：
	struct DistanceAndHeight
	{
		int height;
		int distance;
	};

	struct Node
	{
		int data;
		Node * left, * right;
	};

	/**
	* 同时获取一个二叉树的中的最远的两个节点的距离和这个二叉树的高度
	* 
	* @param Node * T   要获取数据的二叉树
	* @return DistanceAndHeight 返回二叉树中最远的两个节点的距离和二叉树的高度组成的一个复合结构
	*/
	DistanceAndHeight GetDistanceAndHeight(Node * T){
		DistanceAndHeight dh;
		if(!T){
			//空树
			dh.height = -1;
			dh.distance = 0;
			return dh;
		}
		//求解左右子树的高度和距离
		DistanceAndHeight dhl = GetDistanceAndHeight(T->left),
						  dhr = GetDistanceAndHeight(T->right);
		//通过左右子树的高度来求解整个树的高度
		dh.height = 1 + (dhl.height > dhr.height ? dhl.height : dhr.height);
		//通过左右子树的高度来求解通过根节点的最远的两个节点的距离
		dh.distance = 2 + dhl.height + dhr.height; //分别加上的是左右子树到根节点的路径1
		if(dh.distance < dhl.distance)
			dh.distance = dhl.distance;
		if(dh.distance < dhr.distance)
			dh.distance = dhr.distance;
		return dh;
	}

	/**
	* 获取一个二叉树的最远的两个节点的距离
	*
	* @paramn Node * T 要获取的二叉树
	* @return int 返回二叉树中最远的两个节点的距离
	*/
	int GetDistance(Node * T){
		return GetDistanceAndHeight(T).distance;
	}
	

220，一个二叉树上面每一个节点上存放一个int，寻找所有满足路径上的节点的和是一个给定的int的路径。这个路径节点不需要一定通过根节点或者是叶节点。
分析：
如果使用递归的思路，可以这样考虑，要根节点的时候在左右子树寻找sum减去根节点的值，不要根节点的时候在左右子树寻找sum。这个算法的复杂度个人推出来的是n*n，整个递归的基是树是空树。上述表述存在一个问题：如果根节点采用了，那么下面分析左右子树的时候左右节点必须也被采用，否则路径就会断掉，解决这个问题的方法是在递归的函数中传入之前的已经采用的节点(也可以只存节点的值)集合，如果判断这个集合是空的，那么当前的根节点是可以不要的，否则必须采用当前的节点。
代码：
	/**
	* 在一个已经确定了一部分路径的前提下，在一个子树上寻找节点和是某一个sum的的路径
	* 
	* @param Node *T 要操作的二叉子树
	* @param int sum 要寻找的节点值之和
	* @param std::vector<int> valuesAdded 在进入这个子树之前已经确定保存了的节点
	*/
	void FindRouteImpl(Node * T, int sum, std::vector<int> valuesAdded){
		if(!T)
			return;
		if(!valuesAdded.size()){
			//已经保存的节点值的集合为空，那么可以在左右子树中寻找满足和为sum的路径
			FindRouteImpl(T->left, sum, valuesAdded);
			FindRouteImpl(T->right, sum, valuesAdded);
		}

		valuesAdded.push_back(T->data);
		//判断路径
		if(T->data == sum){
			//打印路径
			std::cout << "{";
			for(auto item = valuesAdded.begin(); item != valuesAdded.end(); item++){
				std::cout << " " << *item;
			}
			std::cout << " }" << std::endl;
		}
		//采用当前的根节点的前提下，在左右子树寻找sum-T->data
		FindRouteImpl(T->left, sum - T->data, valuesAdded);
		FindRouteImpl(T->right, sum - T->data, valuesAdded);
	}

	/**
	* 在一个二叉树上面寻找节点的和是某一个整数的所有路径
	* 
	* @param Node * T 要查询的二叉树
	* @param int sum 节点值构成的目标和
	*/
	void FindRoute(Node * T, int sum){
		std::vector<int> v;
		FindRouteImpl(T, sum, v);
	}
下面是书籍上给出的另一种从下往上进行查询的方法：从根节点开始保存每一条的路径，然后在保存的路径的末端开始进行回溯（这样节点的末端是一定会使用上的），一直进行节点的值的累加，如果出现了给定的sum，就进行路径的打印。
自底向上的递归求解代码：
	/**
	* 从下向根节点查找路径上节点值的和是某一个int的所有路径
	*
	* @param Node * T 当前查找到的二叉树子树
	* @param int sum 要计算的目标和
	* @param std::vector<int> valuesFromRoot 记录的是从根节点向下到当前节点之前的路径节点的值
	*/
	void FindRouteFromBottom2Top(Node *T, int sum, std::vector<int> valuesFromRoot){
		if(!T)
			return;
		valuesFromRoot.push_back(T->data);
		//从当前的元素向后根节点回溯
		int size = valuesFromRoot.size();
		int sum1 = sum; //另存一个值在循环里面使用
		for(int i = size -1; i >= 0; i--){
			sum1 -= valuesFromRoot[i];
			if(!sum1){
				//打印路径
				std::cout << "{";
				for(int j = i; j <= size -1; j++){
					std::cout << " " << valuesFromRoot[j];
				}
				std::cout << " }" << endl;
			}
		}
		//向下一层递归
		FindRouteFromBottom2Top(T->left, sum, valuesFromRoot);
		FindRouteFromBottom2Top(T->right, sum, valuesFromRoot);
	}
	/**
	* 在一个二叉树上面寻找节点的和是某一个整数的所有路径
	* 
	* @param Node * T 要查询的二叉树
	* @param int sum 节点值构成的目标和
	*/
	void FindRoute(Node * T, int sum){
		std::vector<int> v;
		FindRouteFromBottom2Top(T, sum, v);
	}
	

221，已知先序和后序遍历，能不能确定一棵二叉树。
分析：
不能，如果已知先序和中序，或者是已知后序和中序，或者是知道先序和层序。这是可以确定一棵二叉树的。但是如果知道先序和后序是没有办法确定一棵二叉树的，原因是先序是从前到后依次读取，而后序是从后到前依次读取，没有办法确定层序和左右关系。


222，已知一个二叉树的先序和中序序列。序列每一个项各不相同，如果确定这个二叉树。
分析：
先读取一个先序，然后在中序中找到这个先序元素，这个作为根元素，将中序序列分割成了左右两边，左边的是左子树，右边的右子树。然后可以使用递归的思想，取得左右子树之后追加到原来的根元素上。这个递归的base是中序为空的时候直接返回null。可以分析得到算法的复杂度是二次的。根据实际需要考虑是否需要进行异常处理（例如如果输入的先序和中序是错的，根本不可能是同一个树上的）