1，extern的作用
答案：
extern的作用有两个：
①：用于变量或者函数前，用以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他的模块中寻找定义。extern int g_Int只是一个申明，这样在编译阶段不会报错，编译器会在链接阶段寻找其定义。
②：extern "C" void fun(int a,int b);用来告诉编译器在编译这个函数的时候按照C规定的规则去翻译相应的函数名而不是C++的。C++中由于存在函数的重载，所以会有不同。

2，strstr函数
答案：
strstr(const char* s1, const char* s2)是查找s1中是否存在子字符串s2，如果存在就返回第一次出现的位置（地址），否则返回NULL。

3，windows下线程的优先级问题
参考：
每一个线程都有一个“优先级”，范围是0~31,0最低，31最高。当系统决定哪个线程需要调度的时候，首先查看是否存在优先级为31的可调度线程，如果存在，就从中选择一个进行调度。当该线程的时间片达到之后，系统查看是否有另一个优先级为31的可调度线程，如果存在就调度它。只要有一个优先级为31的，那么系统不会调度0~30的线程。
高优先级的线程会打断低优先级的线程，即使低优先级的线程的时间片只用了一半。
当系统引导的时候，系统创建了一个特殊的线程，成为“zero page”（0页）线程。它是整个系统中唯一的一个优先级为0的线程，当系统没有任何其他线程需要执行的时候，该线程负责将系统中所有的RAM页面清零（也就是资源回收）
对于进程而言，windows有一个“优先级类”的概念。这些优先级类作用于进程的所有线程。windows 2000/xp/2003/vista支持六个优先级类：
①：Real-time
②：High
③：Above normal
④：Normal
⑤：Below normal
⑥：Idle
一个进程应该避免使用“实时”优先级类，因为使用该优先级类会导致其他进程中的线程很难被调度，甚至会打断或者抢断系统线程的执行。高优先级类也尽量避免使用，除非有特殊的工作需要使用这个优先级类。
当一个进程的“优先级类”被确定以后，接下来就考虑这个进程中各个线程之间的优先级关系，对于进程中的线程而言，有一个“相对线程优先级”的概念，可以确定一个进程中的多个线程间的优先级关系。Windows支持7中“相对线程优先级”：
①：Time-critical: 关键时间（最高的相对线程优先级）
②：Heightest: 最高
③：Above Normal
④：Normal
⑤：Below Normal
⑥：Lowest：最低
⑦：Idle：空闲
程序中使用“优先级类”和“相对线程优先级”，windows负责映射到具体的0~31的优先级上，对于不同的版本的windows，这种映射关系可能不同。


4，交换x与y的值
答案：
最常用的写法：c = a; a = b; b = c;
利用加法不使用第三个变量：a += b; b = a -b; a = a-b;这种写法有一个问题就是可能出现加法溢出。
利用异或不使用第三个变量（一般最优写法）： a ^= b; b ^= a; a ^= b; 这种写法没有溢出问题。


5，指针的自加与引用
答案：
指针的自加，得到的新地址取决于指针的类型，例如 int *p; 那么p++实际上是让p的地址增加四个字节，而 int *p[10]由于p是指向一个10个元素的int数组，那么每次p的自增会导致p向前移动sizeof(int) * 10。
指针的引用写法是 int * &p; 使用指针的引用是为了方便修改指针的值。


6，前置++与后置++
答案：
前置++表达式的值是++之后的值，而后置++表达式的值是++之前的原来的变量值。


7，inline的作用
答案：
引入内联函数是为了解决函数调用中断影响程序执行效率的问题。inline函数在编译的时候，编译器会将调用的表达式用函数体进行替换，这样做会增加目标程序的代码量，也就是用目标代码的增加来换取程序执行时间的节省。内联函数是编译阶段进行替换，而不是像一般函数那样在运行时被调用。
inline函数的定义如下:
inline int add(int x, int y, int z){
	return x+y+z;
}
内联函数一般不能含有复杂的逻辑，例如内联函数里面不能存在循环语句和switch语句(可以有简单的if)。
在类结构中直接定义的函数默认是内联的。


8，ifndef的作用
答案：
ifndef是if not defined的缩写，是预处理功能（包括文件包括、宏定义、条件编译）中的条件编译，可以根据是否定义一个变量来进行分支选择。
#ifndef主要的目的是防止文件的重复包含和编译。有时候也用于调试开关等。

9，kmp算法
答案：
KMP算法在一个字符串中快速查找子字符串的线性复杂度算法。其核心是利用一个next数组，在每一次出现不匹配的时候，并不会像传统的O(n*n)的算法那样，在要查找的字符串中接着从头开始匹配待查找的子字符串，而是通过查询next数组，在保持父字符串遍历指针不回溯的情况下，从待查找的子字符串的某一个位置进行新的查找。由于要查询的父字符串的索引一直没有回溯，最终将复杂度压缩到了O(n)。算法最关键的地方是构建next数组，next数组理论上的构成是next[i]表示待查找的子字符串的i脚标的字符串不匹配的时候，下一次从next[i]重新进行匹配，为了找到这个next[i]做法是查找之前已经比配的子字符串的部分，比较它的前缀跟后缀的最长重合部分，这个就是next[i]。但是鉴于复杂度的考虑，一般不会重复比对一个子串的前缀与后缀，而是通过前一个next[i-1]的关系进行线性构造next[i]，这个构造基于一下事实：如果要查找的子字符串s，其s[i] = s[next[i-1]]那么可以得出 next[i] = next[i-1] + 1。如果s[i] != s[next[i-1]] 那么假设k = next[i-1]，进一步比较s[i] 与 s[next[k]]，上面出现了一个递归描述，只要控制要base，也就是next[0] = -1和next[1] = 0就可以实现线性构造next数组。


10，函数调用方式
答案：
C++中函数调用的方式有stdcall、cdecl、fastcall、thiscall、naked call
首先，调用函数时，计算机常用栈来存储传递给函数的参数。函数调用时，迪奥者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得数据，并进行计算。函数计算结束以后，或调用者或函数本身修改栈，使其恢复原状。C++中的各种调用方式的区别就在于当参数多于一个时按照什么顺序将参数压栈和函数调用之后由谁将栈恢复原状。
1)__stdcall
stdcall调用方式又被称为Pascal调用方式。在Microsoft C++系列的C/C++编译器中，使用	PASCAL宏、WINAPI宏和CALLBACK宏来指定函数的调用方式为stdcall。
形式： int __stdcall function(int a, int b)
C语言中__stdcall的特点：
	---参数从右向左一次压栈
	---由被调用函数自己来恢复栈
	--- 函数名自动加前导下划线，后面紧跟着一个@，其后紧跟着参数的尺寸(所有参数所占的字节数) 例如上面的 function(int a, int b)会被翻译为 _function@8。注意这个函数名称可以用汇编直接调用。
C++编译时__stdcall特点：
	---以“？”标识函数名的开始，后面跟上函数名
	---函数名后面以"@@YG"标识参数列表的开始，后面跟上参数列表。
	---参数列表以代号标识： 
		X-void D-char 
		E-unsigned char
		F-short H-int I-unsigned int
		J-long K-unsigned long
		M-float N-double _N-bool
		PA-表示指针，后面的代号表名指针的类型，如果相同类型的指针重复连续出现，就用一个"0"代替，一个"0"代表重复一次。
	---参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型，指针类型为PA加上所指数据类型
	---参数列表后以"@Z"标识整个名称的结束，如果该函数无参数，那么以"Z"的标识结束(此时参数类型为X，实际会以XZ结束)。例如void __stdcall function(int a, int b)编译之后的名称是?function@@YGXHH@Z 而void __stdcall function()编译之后的名称是 ?function@@YGXXZ
----扩展： pascal语言是一种老的教学语言，采用的是__stdcall但是它的入栈顺序是从左到右。C++标准调用方式是__stdcall的，window api系统调用都是__stdcall的，但是C++中是从右到左的入栈顺序。（VC中的默认调用方式还是cdel的，所以会看到很多函数前面加上了WINAPI字样）
2）__cdecl
cdecl调用方式又称为C调用方式，是C Declaration的缩写。是C语言的缺省调用方式（也就是没有__stdcall之类的形式符，C程序默认就是cdecl的）。
形式：
	int function(int a, int b)  //缺省默认
	int __cdecl function(int a, int b) //指明调用方式
C语言编译时__cdecl特性：
	参数从右向左依次压栈
	由调用者恢复栈，由于是由调用者来恢复栈，所以C调用方式允许函数的参数个数是不固定的。例如调用 void function(int a, int b)的过程是：push b, push a, call function 然后add esp,8 最后这个add esp，8就是清理栈。
	函数名自动加前导下划线，例如void function(int a)就被翻译为 _function。可以看到被调用者不会要求调用者传递多少参数，调用者传递过多或者过少都不会产生编译阶段的错误。
C++编译时__cdecl特性：
	函数命名的时候和__stdcall基本一样，只是一点就是原来的参数列表是@@YG开头 而__cdecl调用的参数列表开头是@@YA
3）fastcall
fastcall是一种快速调用方式，前两个参数用exc和edx进行传递，后面的参数向__stdcall那样传递,从右向左进行入栈，函数编译之后的名称规则和__stdcall一样，调用完成之后被调用者清理栈，函数编译之后的名称和__stdcall基本一样，只是函数列表的开始是@@YI。
形式：
	int fastcall function(int a, int b)
4）thiscall
thiscall调用方式是唯一一种不能显示指定的修饰符。它是C++成员函数的缺省调用方式。由于成员函数的调用还有一个this指针，因此必须使用这种特殊的调用方式。
thiscall特性：
	参数从右向左入栈
	如果参数个数确定，this指针通过ecx传递给调用者，如果参数个数不确定，this指针在所有的参数都入栈之后被压栈。
	参数个数不确定时，由调用者清理栈，参数个数确定时，由函数清理栈。
5）naked call
一种很少见的调用方式，一般高级程序设计语言不常见。
函数的申明调用方式和实际调用方式必须一致，否则必然产生编译器的混乱。


11，重载函数
答案：
重载函数是函数的一种特殊情况，指的是几个功能相近的同名函数，但是这些函数的形式参数（参数的个数、类型、顺序）必须不同，也就是同一个函数名完成不同的运算，这就是重载函数。重载函数常常用来实现功能类似而实际处理数据类型不同的问题。两个重载函数之间必然存在参数的个数或者参数的类型的不完全相同。
定义：
	同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。
为何要有重载函数：
	对于同一个功能，数据类型的不同的函数取一个名称增加程序的可读性，方便使用。
	类的构造函数跟类名相同，如果没有重载机制，那么要实例化不同的对象，就不方便。
	操作符重载，本质上是函数重载，它大大丰富了已有操作符的含义，方便使用，例如+可以连接字符串等。指的注意的重载不能改变操作符的优先级。
重载函数的调用匹配：
为了确定哪个重载函数最合适，需要依次按照下列的判断规则
	1）精确匹配：参数匹配而不用做任何的转换（或者是微不足道的转换，例如数组名到指针）
	2）提升匹配：即整数提升（如bool到int char到int  short到int  float到double等）
	3) 使用标准转换匹配：如int到double、double到int、double到long double、Derived*到Base*、T*到void*、int到unsigned int
	4）使用用户自定义匹配。
	5）使用省略号匹配：void function(int x,...)


12，合并两个有序链表
答案：
可以写出 O(M+N)的算法，方法是设置两个指针分别定位在两个链表的头部，进行两个链表的遍历。如果存在某一个链表中的数据数据小于另一个链表就将这个链表的节点追加到新的链表中同时向后移动这个链表的指针，如果两个链表中的数值相同，就将其中的一个节点追加到新的链表中，同时将两个链表的指针都向后移动一位。如果其中一个链表已经遍历完成，那么将另一个链表中剩下的数据完全拷贝到新的链表中。至此，所有的合并操作完成。

13，从100亿条数据中找出重复最多的前10条
答案：
由于数据量比较大，所以不能一次性加入内存，首先可以利用散列，将100亿条记录分割成一批数量较小(例如，模上10001，每一个相同模结果的记录放到同一个文件中)的数据，这种分割算法，保证只要两个记录是相同的就一定会被映射到同一个文件中。然后对每一个记录文件，构建一个AVL，每一个节点保留一个属性用来记录出现的次数，如果插入相同的记录，就将记录数加1。最后遍历AVL树，取出所有的节点，然后按照记录出现的次数构建最大堆，使用 O(10*log(n))的时间复杂度找出每一个文件中的出现次数前10的记录。将这10001个文件中所有的前十综合起来也就是 10001 * 10条记录放到一起，构造优先队列，使用最大堆取出出现次数最多的前10.（凡是海量数据处理，一定涉及到hash，这也是mapreduce的原理）


14，设计一个双向链表，并且提供可以根据值删除元素的函数。
答案：
跟单向链表相比，删除的时候最主要的不同是要修改指向前面的指针，在删除头的时候要修改头而在删除尾的时候还得修改尾部。核心的代码大致如下：
	typedef int ElementType; /*利用抽象的数据结构，方便一会可能进行的修改和复用*/

	struct Node
	{
		ElementType val;
		Node * previous;
		Node * next;
	};

	struct DoubleLinkedList
	{
		Node * head;
		Node * tail;
	};

	/*
		按照值删除元素
	@param DoubleLinkedList* L 要操作的链表
	@param ElementType val 要删除的值
	@version 1.0 功能性实现
	@version 2.0 细节优化：由于是双向链表，所以不用向单链表那样，删除之前还需要保存上一个节点。这里去除掉循环里面的previous保存
	*/
	void DeleteByVal(DoubleLinkedList * L, ElementType val){
		if(!L)
			return;
		Node *p = L->head, *previous = NULL, *next = NULL;
		for(;p && val != p->val; p = p->next){
			//version 2.0 双向链表不用保存了
			//previous = p; //保存要删除节点的前一个节点
		}
		if(p){
			//找到了值，进行删除
			next = p->next;
			previous = p->previous;  //version 2.0
			if(previous)
				previous->next = next;
			else
				L->head = next; //删除的是头节点，需要修改头结点指针
			if(next)
				next->previous = previous;
			else
				L->tail = previous; //删除的是尾节点，需要修改尾部指针
			//删除p
			delete p;
		}
	}

15，二叉树多种遍历的实现
答案：
对于二叉树的遍历，一般又可以分为先序、中序和后序。其中先序遍历类似与DFS，而后序遍历可以用来计算一个目录的大小(目录中所有的子目录和文件的大小相加然后加上目录本身的文件大小（目录本身也是文件，在有的系统中也是算独立大小的）)，中序遍历一般用于一些数学表达式之类的遍历。各种遍历的大致代码如下：
	typedef int ElementType;

	struct Node
	{
		ElementType val;
		Node * left;
		Node * right;
	};

	typedef Node* BinaryTree;

	/*
		C++11增加了一批的to_string()函数，这里由于MingW版本低，所以自己利用流实现以个to_string
	*/
	std::string to_string(int n){
		ostringstream stream;
		stream << n;
		return stream.str();
	}

	/*
		二叉树的先序遍历,递归实现
	@param BinaryTree T 要遍历的二叉树
	@return std::string 遍历之后得到的结果字符串
	*/
	std::string PreOrder(BinaryTree T){
		std::string toReturn  = "";
		if(!T)
			return toReturn; //空树
		//获取树根的值
		std::string root = to_string(T->val);
		//遍历左子树
		std::string left = PreOrder(T->left);
		//遍历右子树
		std::string right = PreOrder(T->right);
		//添加根节点的值
		toReturn += root;
		//添加左右子树到返回结果
		if(left.length())
			toReturn += string(" ") + left;
		if(right.length())
			toReturn += string(" ") + right;
		return toReturn;
	}


	/*
		二叉树的中序遍历,递归实现
	@param BinaryTree T 要遍历的二叉树
	@return const std::string & 遍历之后得到的结果字符串
	*/
	std::string InOrder(BinaryTree T){
		std::string toReturn = "";
		if(!T)
			return toReturn; //空树
		//遍历左子树
		std::string left = InOrder(T->left);
		//获取树根的值
		std::string root = to_string(T->val);
		//遍历右子树
		std::string right = InOrder(T->right);
		//添加左子树到返回结果
		toReturn = left;
		//添加根节点的值到返回结果
		if(toReturn.length())
			toReturn += " " + root;
		else
			toReturn += root;
		//添加右子树到返回结果
		if(right.length())
			toReturn += " " + right;
		return toReturn;
	}


	/*
		二叉树的后序遍历,递归实现
	@param BinaryTree T 要遍历的二叉树
	@return const std::string & 遍历之后得到的结果字符串
	*/
	std::string PostOrder(BinaryTree T){
		std::string toReturn = "";
		if(!T)
			return toReturn; //空树
		//获取树根的值
		std::string root = to_string(T->val);
		//遍历左子树
		std::string left = PostOrder(T->left);
		//遍历右子树
		std::string right = PostOrder(T->right);
		//添加左右子树到返回结果
		if(left.length()){
			if(toReturn.length())
				toReturn += " " + left;
			else
				toReturn += left;
		}
		if(right.length()){
			if(toReturn.length())
				toReturn += " " + right;
			else
				toReturn += right;
		}
		//添加树根
		if(toReturn.length())
				toReturn += " " + root;
			else
				toReturn += root;
		return toReturn;
	}


16，有读和写的两个线程和一个队列，读线程从队列中读数据，写线程往队列中写数据。
答案：
可以多个同时读，但是读的时候不能写，写的时候不能读。

17，stack  heap  memory-pool


18，TCP流量控制和拥塞控制机制



19，写一个函数，返回一个字符串中只出现一次的第一个字符串。


20，求数组中第k大的数的位置


21，面向对象多态的实现机制。


22，内联函数什么时候不展开

23，成员初始化列表有什么用，什么时候必须使用成员初始化列表进行初始化


24，指针和引用的区别


25，创建空类，默认有哪些函数


26，有10万个ip段，这些ip之间不重合，随便给出一个ip，求属于哪一个ip段。


27，网络编程范式，非阻塞connect


28，linux中互斥的方法，多线程编程，进程间通信


29，一个数一维数轴上有不同的线段，求重复最长的两个线段


30，有向带权图的最短路径


31，内存溢出与内存泄露的区别


32，利用互斥量和条件变量设计一个消息队列，具有一下功能：①创建消息队列（消息中所含的元素） ②消息队列中插入消息 ③取出一条消息（阻塞方式）  ④取出第一消息（非阻塞方式）。 注意：互斥量、条件变量和队列由系统给出。


33，非递归实现二叉树遍历

34，设计一个内存管理策略，要求可以保证多线程时安全、防止内容越界等，效率不能低于malloc/free


35，有一个虚拟存储系统，若进程在内存中占3页（开始时内存为空），采用先进先出(FIFO)页面淘汰算法，当执行 1,2,3,4,5,1,2,5,1,2,3,4,5访问序列后，会发生多少缺页。


36，某页式存储管理系统中，地址寄存器长度24，其中号位14，则主存的分块大小是多少字节


37，重载运算符


38，struct和class的区别与联系

39，函数指针与指针函数
答案:
指针函数指的是返回值类型是指针类型的的函数。函数指针是指向一个函数类型的指针。


40，大端小端


41，如何判断单链表是否有环


42，一个进程中多线程可以共享栈吗
答案：
不可以。线程是调度单位，进程是内存管理单位。每一个线程有自己独立的栈，并且不能共享。但是对于堆，所有线程是共享的。


43，同一个进程，多个线程可以共享register set(寄存器组)吗
答案：
由于线程是一个独立的调度单位，所以不能共享寄存器组。但是多个线程可以共享data section(数据段)和 file fd(文件描述符)


44，如何区分ABCDE类ip
答案：
首先每一个ip由4个字节组成，这里仅讨论ip4情况。
A类：
A类ip中第一个字节指明网络，后三个字节指明网络上的主机。
第一个字节是 0~127。也就是说第一个字节的高位必须是0. 但是0和127这种全0和全1的被保留。但是由于第一个字节的全0和127开头的被用作特殊用途，所以实际可以分配的1~126（1.0.0.1~126.255.255.254）。127.0.0.1是回环测试用的固定ip。A类中的10.0.0.0到10.255.255.255是私有地址。每一个A类网络可以提供主机地址个数是2^24-2(其中主机地址全0用于标识网络，全1用于广播网络)。A类占ip总数的50%，默认的A类地址子网掩码是255.0.0.0
B类：
B类地址前两个字节是网络地址，后两个字节是主机地址。B类的第一个字节的前两位必须是10，所以B类的网段个数是 2^14。每一个B类网络可以提供的主机地址个数是2^16-2.
B类的范围是128.0.0.0~191.255.255.254。其中172.16.0.0~172.31.255.255是私有地址。169.254.0.0~169.254.255.255是保留地址，如果ip设置自动获取，而网络上没有找到dhcp服务器就从169.254.0.0~169.254.255.255中临时获取一个ip。默认子网掩码255.255.0.0
C类：
前三个字节是网路地址，后一个字节是主机地址。最高位必须是110。C类的网段个数是2^13。每一个C类网路可以提供2^8-2个主机地址。C类表示的范围是192.0.0.0~223.255.255.255。C类地址分配给小型网路，一般的局域网和校园网，它可连接的主机数量是最少的，采用把所属的用户分为若干的网段进行管理。其中192.168.0.0~192.168.255.255是私有地址。
D类：
D类地址，第一个字节以1110开头，它是一个专门保留的地址。D类并不指向特定的网络，目前多被用在多点广播中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。地址范围是224.0.0.0~239.255.255.255。
E类：
以1111开头，也是保留地址。第一个字节的范围是240~255,主要用于Internet实验和开发。


45，什么是私有网路地址
答案：
私有网路地址就是在互联网上不适用，而被用在局域网中的地址。A类是10.0.0.0~10.255.255.255  B类是172.16.0.0~172.31.255.255 C类是192.168.0.0~192.168.255.255


46，虚函数可以是static的吗，为什么
答案：
不可以。
虚函数是一种特殊的成员函数，用来实现运行时的多态。static函数中没有this指针而virtual方法内部隐藏了this指针。static函数是在编译时绑定的，而virtual函数是在运行是绑定的。


47，指针与引用的区别
答案：
指针是一个变量，指向内存储的一个存储单元，而引用跟原来的变量其实是同一个东西，只不过是原来的变量的一个别名。
具体的区别包括： 
①，指针可以是多级，但是引用只能是一级，不存在 int &&a; 
②，指针可以是空，但是引用不能为NULL，并且指针在定义的时候必须初始化。
③，指针的值在初始化之后可以进行修改，但是引用初始化之后不能改变。
④，sizeof引用得到的是所指向变量的大小，而sizeof指针得到的是指针的大小。
⑤，对指针和引用进行自加的操作意义是不一样的，引用是对原来的变量进行自加，但是指针是在当前保存的地址上加上sizeof原来的变量类型。

48，下列定义数组的方式在C++中是合法的有那些：
	1）deifine N 100
	int x[N];  //这个合法，是正确的，进行宏替换，编译器可以识别到正确的数组长度
	2) const int N = 10;
	int x[N];  //C++中可以使用const变量进行数组长度的定义。但是在C语言中这样书写是不正确的，二者的const关键字有所区别.
	3）int length = 10;
	int x[lenght]; //这种写法不对，尽管在gcc中，编译器进行了优化，可以通过编译。


49, 考虑这么一个问题，一个数组int arr[] = {2,3,4,5}，定义一种运算，f[i]为数组上除了arr[i]其他所有的其他数据元素的乘积。要求复杂度尽可能的低
答案：
1）显而易见的思路：分别计算每一个f[i] = arr[0] * .... * arr[i-1] * arr[i+1] * .... * arrp[n-1]。这个实现算法的时间复杂度是 O(n*n)。空间复杂度可以达到O(0),因为直接将要计算的结果保存在要返回的数组中。
2）稍微有点经验的判断，就会发现上面的乘法进行了重复的计算，而且这个重复的量是很大的。一个利用空间换取时间的策略是：用O(n)从左到右扫描数组将前0~i-1项的乘积的结果保存为一个数组left[i]，同样用O(n)从右往左进行扫描，可以构建一个后i+1~n-1的乘积的结果数组right[i](两个结果数组中的边界情况的乘积设置为1)。最后利用这两个中间存储的状态数组计算result[i] = left[i] * right[i]。整个算法的复杂度大致为O(3n)，空间复杂度是两个中间状态的保存数组为O(2n)
3）对于上面第二种算法，可进一步的优化其空间复杂度，利用经验可以知道这样的相邻的状态的值可简单递推的一般都存在空间复杂度的可能优化。可以这样考虑，先将left数组的值直接保存到result数组中，然后用一个中间变量存储i+1~n-1之间的元素的乘积，每一次向这个中间值上追加上新的因子的同时也就可以将这个乘积直接乘到原来的对应的result[i]上。这个改良后的算法时间复杂度依然是O(3n)(指的注意的是从右往左进行遍历的时候出列计算右边的乘积，还将左右两部分的乘积相乘计算出result[i]这一动作至于其中),这个算法的空间复杂度为O(1)，只用到了一个中间变量.
对于算法3）这种最有的代码大致如下：
	int * cal(int * input,int n){
		int * result = new int[n];
		if(!result){
			std::cout << "new memory fail" << std::endl;
			return nullptr;
		}
		int right = 1;
		//计算左边的0~i-1的乘积
		result[0] = 1;
		for(int i = 1; i < n-1; ++i){
			result[i] = result[i-1] * input[i-1];
		}
		//从右往左进行遍历 计算right 计算result
		for(int i = n - 2; i >= 0; --i){
			right *= input[i+1];
			result[i] *= right;
		}
		return result;
	}


50，在n个整数的序列中，要计算出最大值和最小值，至少需要多少次比较：A.2n-2 B.3n/2 C.n-1 D.4n/3
答案与分析：
结果是 B.3n/2
1）按照一般性写法，用两个变量分别保存最大和最小值，初始的时候将这两个值都设置为arr[0]，然后遍历这个数组，通过对每一个元素与最大最小值的比较和互换最终确定这个序列的最大和最小值。这个比较的次数是 2(n-1)
2）因为要计算的是最大和最小值，可以先进行没两个两个的比较，将这个比较中间较大的放到一个数组，将较小的放到一个数组。然后利用上面1）的描述分别在两个子序列中找出最大和最小值（这个算法如果要追求不用空间上的优化，可以直接将奇数位设置为较小，偶数位设置为较大，不过这样导致了输入数组的更改）。这个算法的复杂度是 n/2 + (n/2 - 1) + (n/2 - 1)近似为3n/2
----下界分析：能够优化上面思路1）的部分，应该是在尽可能的不让每一个数据都和最大最小值进行比较，而如果对于任意一个数只要知道它不能是最大值就不用和最大值比较，同样的分析适用于最小值。那么这个优化方案也就是在内部两两配对进行分组。这样与最大值最小值的比较次数缩减了一半，从2n-2次缩减为n-1次（这个分析并不是最糟糕的情况，糟糕的情况下，内部比较的两个值是一样的，那么这个数据要同时进入两个组），但是内部产生了n/2次比较。所以要同时计算出最大最小值需要的比较次数应该不少于3n/2。
利用额外的数组空间进行算法2）的实现代码大致如下：
	void cal2(int input[], int length, int &max, int &min){
		if(!input || length <= 0){
			std::cerr << "the input array is null or empty" << std::endl;
			return;
		}
		int * low = new int[length];
		if(!low){
			std::cerr << "new memory fail" << std::endl;
			return;
		}
		int * high = new int[length];
		if(!high){
			std::cerr << "new memory fail" << std::endl;
			delete [] low;
			return;
		}
		//对输入的input进行分组
		int lowLen = 0, highLen = 0;
		//如果是奇数，那么将最后一个元素先加入到两个数组中
		if(length / 2)
			low[lowLen++] = high[highLen++] = input[length -1];
		for(int i = 0; i < length - 1; i += 2){
			if(input[i] <= input[i+1]){
				//一个小细节，如果相邻的这两项相等，那么两个相同的项进入到两个数组，这种处理没有向任何一遍倾斜，不会造成一头大一头小的两个数组.
				low[lowLen++] = input[i];
				high[highLen++] = input[i+1];
			}else{
				low[lowLen++] = input[i+1];
				high[highLen++] = input[i];			
			}
		}
		//在high中寻找最大值  在low中寻找最小值  由于lowLen和highLen其实是一样的，所以下面的代码（其实上面的分组代码中的变量二者也可使用一个）中两个for是可合并的，这里暂不给出合并的代码
		max = high[0];
		min = low[0];
		for(int i = 1; i < lowLen; ++i){
			if(min > low[i])
				min = low[i];
		}
		for(int i = 1; i < highLen; ++i){
			if(max < high[i])
				max = high[i];
		}
		//资源释放
		delete [] low;
		delete [] high;
	}


51，在32位系统和64位系统中 int * p; sizeof(p)的结果分别是多少
答案：
一个指针对应存储的是地址，至于占用多少个字节，一般所用的地址总线的条数有关。32位和64位说的便是地址总线的条数，这个也就是一个地址的位数。所以在32为系统上一个指针占用32位，也就是4个字节，在64位系统上一个指针占用64位也就是8个字节。上面的结果分别是4和8


52，在一个数组中，存在一个元素出现的次数超过了数组长度的1/2，找出这个元素。
--问题延伸： 如果是在一个数组中，已知一个元素出现的次数超过了1/3，又如何找出这个元素
答案与分析：
一个一般性的想法：将数组进行排序，那么arr[n/2]就是目标元素，原因很简单这个元素个数超过数组长度一半的元素无论是从数组左边开始都是较小值还是从数组最后面往前排都是较大值，由于其个数超过了总长度的一般，所以中间位置一定是这个元素。如果用快排之类的排序这个直观算法的复杂度是O(nlog(n))
如果一个元素已知出现的次数超过了1/2，那么也就是这个元素的个数超过了其他所有元素的总和。假设使用一个计数，初始为0，这个计数在出现的元素的要找的出现次数超过1/2的元素的时候就进行计数加一，在出现的元素不是要找的出现次数超过1/2的元素的时候就进行减一，那么遍历这个数组之后的结果这个计数一定是大于0的。因为只是进行了一次遍历，这个算法的复杂度是O(n)
上面的思路，仅仅是根据条件是如果已知有这么一个元素的个数超过了1/2，是通过这个已经的性质进行求解输出的。但是如果前提并不知道是否存在次数超过1/2的元素的时候，这个求解就可能是失效的。也即是这种思路只能在确定存在这个元素的前提下找到它而没有办法证明超过1/2的元素一定存在。给定一个简单的例子，一个数组中每个元素都不一样，并且数组长度为奇数(>=3)，通过上面的思想会找到最后一个元素，然后这种情况下是不存在某一个元素的个数超过总的元素个数的一半的。对于可能并不存在次数超过1/2的情况，可以再次遍历一次这个数组进行出现次数的验证。通过反证法可以很容易的得到如果确实存在次数超过了数组长度的一半的元素那么最后的标记元素一定是这个目标元素，那么上面的一次遍历验证也就是有效的。
上述的代码逻辑大致如下：


53, -1 >> 1这个表达式的值是多少，为什么
答案：
移位操作，是进行二进制的内存结构进行左移一个比特位或者右移一个比特位。如果是左移那么低位会补充0，如果右移，那么高位会补充符号位。这里的-1高位的符号位是1，由于原来的内存二进制表示形式为 1...1..1如果进行右移一位并且在高位进行补1，那么结果还是1...1...1(全1)，结果还是-1

54，如果表示最大的整型数字
答案：
如果是进行10进制表示，由于数字规律性不强，不容易记忆。可以进行16进制的表示： 0x7fffffff 或者使用 -1 - 0x80000000


55，找出一个数组中所有满足下面条件的元素：这个元素的所有的左边的元素小于等于它，右边的所有的元素都大于等于它。
答案：
1）一个显而易见的常规分析是：对于每一个元素，遍历它的前后所有元素进行判断。这个算法的复杂度是O(n*n)
2）上面的O(n*n)算法，很明显做了很多次的重复比较，存在优化的空间。假设我们构建两个数组leftMax和rightMin分别表示一个元素左边包括其自身的最大值和一个元素右边包括其自身的最小值，那么只要对应的leftMax[i] <= rightMin[i]，这个i就是符合要求的。实际考虑到内存的开销，可以只使用一个数组leftMax或者是rightMin，记录下来单边的的最值情况，然后从另一边进行遍历，在遍历计算另一边的最值的时候同时判断i是不是符合要求。
只是用rightMin数组的代码大致如下：
	std::vector<int> cal2(int input[], int length){
		std::vector<int> result;
		if(!input || length <= 0){
			std::cerr << "the input array is null or its length is no more than 0" << std::endl;
			return result;
		}
		int *rightMin = new int[length];
		if(!rightMin){
			std::cerr << "new memory fail" << std::endl;
			return result;
		}
		//构建righMin数组
		rightMin[length -1] = input[length -1];
		for(int i = length -2; i >= 0; --i){
			if(input[i] < rightMin[i+1])
				rightMin[i] = input[i];
			else
				rightMin[i] = rightMin[i+1];
		}

		//从左向右计算leftMax
		int leftMax = 0x8fffffff; 
		for(int i = 0; i < length; ++i){
			//获取前面0~i的最大值
			if(input[i] > leftMax)
				leftMax = input[i];
			if(leftMax <= rightMin[i])
				result.push_back(i);
		}
		//释放资源
		delete [] rightMin;
		return result;
	}
	

56，如何在字符串s1中查询是否包含另一个字符串s2
答案：
在一个字符串中查找另一个字符串，一般存在BF算法和KMP算法，其中BF算法的复杂度是O((M-N)*N)，而KMP算法的复杂度是O(M+N)。
BF算法：
从s1[0]~s1[M-N]为其实字符的长度为N的子字符串一次与s2进行比对，如果找到就返回这个子字符串的起始位置，否则最后返回-1.
KMP算法：
BF算法的一个最大的问题是，每一次如果没有找到就将s1中的比较的起始位置向前移动1.而KMP算法是在每一次如果不出现了不匹配，s2中的位置指针并不会进行回溯，而是通过调整s2中的要比较的下一个位置进行新的比较，这个位置的确定依赖于一个next数组，next[i]表示s2[i]与s1中的字符不匹配的时候的时候下一个s2中的直接用来与s1中现在的位置上的字符进行比对的位置。KMP算法中的next数组的构建分析如下：对于s2="aaacXbbb"如果在X字符处不匹配，那么由于前面的aaac已经匹配了，就分析这个aaac的前缀aaa与后缀aac他们重合的部分是aa，那么由于前面已经有两个重合的了next数组应该执行2也就是从第三个元素进行匹配。上面对next[i]只是从理论上给出一个描述，实际操作计算的时候这个复杂度还是太高，可以进行进一步的优化。这个优化基于以下事实：为了计算next[i+1],首先考虑next[i]，如果数组中s2[i] = s2[next[i]]那么就可直接设置next[i+1] = next[i] + 1;如果数组s2[i] != s2[next[i]]，那么问题转换为将s2[next[i]]"替换"（并不是真实的内存替换，可以想象为替换效果）为s2[i]之后重新计算next[next[i]]，这个值就是最后的要求的next[i+1]。上面的问题为一个递归问题，现在只需要找到这个问题的base。可以观察到当i=0的时候，如果出现了不匹配，那么s1中的指针应该向前一定一位，从s2的开头重新进行匹配，所以这里形象的理解为next[0]=-1,也就是使用s2中一个越界的位置与当期不符合的s1的位置进行重新匹配（并且认为是匹配成功的）。
BF算法的代码大致如下：
	int BF(const char * s1, const char * s2){
		assert(s1 && s1);  //assert宏用于在debug的模式下进行检测，如果是release的模式会自动删除这个宏
		int M = strlen(s1), N = strlen(s2);
		if(M < N)
			return -1;
		for(int i = 0; i <= M - N; ++i){
			int j = i,k = 0; //j为s1中位置的移动脚标  k为s2中位置的移动脚标
			for(; k < N; ++j,++k){
				if(s1[j] != s2[k])
					break;
			}
			if(k == N)
				//找到了
				return i;
		}
		return -1;
	}
	
KMP算法的代码大致如下：
	int KMP(const char *s1, const char * s2){
		assert(s1 && s2);
		int M = strlen(s1), N = strlen(s2);
		if(M < N)
			return -1;
		//构建next数组
		int *next = new int[N];
		if(!next){
			std::cerr << "new memory fail" << std::endl;
			return -1; //异常处理，这里本来应该是抛出异常的，这里暂时写作返回-1
		}
		next[0] = -1; //base
		for(int i = 1; i < N; ++i){
			int j = next[i-1];
			while(j != -1 && s2[j] != s2[i-1]){
				//回溯
				j = next[j];
			}
			//注意：当next[i-1]为-1的时候。需要直接将s1中的指针向前移动，也就是“s2[-1]与s1中的目前的位置相对齐进行比较并且认为是符合要求的(符合要求也就是next[i] = next[i-1] + 1)”
			next[i] = next[i-1] + 1;
		}

		/*上面我个人书写的寻找next[i]的代码，网络上其他的寻找next数组的代码如下	---START*/
		/*写法1：严格迭代，使用next[i]与之前的其他已知的next，迭代出next[i+1]*/
		int j = next[0] = -1; //记录上一个的next[i]
		//递推next[i+1]
		for(int i = 0; i < N -1;){
			if(j == -1 || s2[i] == s2[j]){
				//s2[i]与上一个next位置的元素匹配（包括next 为 -1的时候的默认与当前元素的匹配）
				next[++i] = ++j;
			}else{
				//调整j  接着寻找next[i+1]
				j = next[j];
			}
		}
		/*上面我个人书写的寻找next[i]的代码，网络上其他的寻找next数组的代码如下	---END*/

		//查找子字符串的位置
		int i = 0; j = 0;
		while(i < M && j < N){
			if(j == -1 || s1[i] == s2[j]){
				//这里包含了next[i] = -1这一特殊情况
				i++;
				j++;
			}else
				j = next[j];  //不匹配，下一次s1中的指针不动，s2中的下一个比对位置移动到next[j]
		}
		
		//释放资源
		delete[] next;
		return j < N ? -1 : i - N;
	}


57，在C++中如下写法是否存在问题 char * s = "hello world"
答案：
编译通不过，因为这是C++，不是C. 在C++中字符串常量(存在常量区)是不能直接赋值给char*的(包括形参为char*，没有办法直接通过字符串常量进行传递)，因为常量区的字符串是不能进行更改的，而通过char*传递违反了这个规则。与C语言一样，C++中允许使用常量字符串对char数组进行初始化，也即是 char s[] = "hello world" 是合法的写法。在C++中常量区的字符串可以直接传递给一个string类型，这里不是简单的指针传递，这里是进行了内容的复制. 还有一点 const char* s = "hello"是合法的，因为是const类型的指针，所以不会涉及到内容的更改，保证了安全性。


58,在C++中如下写法是否正确： const char * s = "hello world"
答案：
正确  因为const char * 指向常量区，并不会对常量区的内容进行潜在的修改，所以编译是通的过的。但是char * s = "hello"是编译通不过的，原因是设计到常量区的内容不能更改，而如果使用char * 指针进行引用可能进行潜在更改。（C语言中是可以使用 char * s = "hello"的，但是常量区也是不能更改的，这里虽然是可以赋值的，但是不能利用这个指针进行常量区的内容的更改，否则程序会崩溃）


59，给定两个字符串s1和s2，判断是否s2可以通过s1做循环移位得到。
分析与答案：
给定字符串s[] = "abcd"，其循环移位之后的字符串可以有一下四个（也就是每一个元素都可能是起始的第一个字符）：
abcd
bcda
cdab
dabc
按照一般性的分析，将在这些字符串中（利用KMP）寻找是否存在s2就可得到最终的结果。
现在要分析的一点就是，如果一个字符串的长度比较大，如果采用事先存储所有循环移位得到的字符串那么需要使用 N*(N-1)的额外空间，在很多程序中这是不可接受的，如果保存上一个循环移位字符串的起始字符的位置，那么，可以对每一个循环移位后的字符串进行判断之后用同一个空间保存下一个移位之后的字符串，这个需要额外的空间为O(N)（可以使用O(1)直接在原来的字符串上面进行修改，不过这设计到原来输入字符串的完整性问题）。实际上,这种相邻的字符串之间的规律很统一，明显可以进行空间复杂度的优化。可以这么考虑用一个变量保存其实的位置索引，这个位置索引的范围应该是[0,length-1]，然后对于每一个其实的位置i，用另一个变量j进行保存i，再对s[j++%length]在j < (length  + i)的情况下进行分析就取得了一个完整的循环移位后的数组。
如果使用一个额外的数组进行每一次的移位得到的字符串进行保存，那么常用的KMP算法直接对这个字符串进行处理即可。如果是通过s[j++%length]进行在原字符串上的访问，那么对于KMP算法的传入参数和内部的处理需要一些改良。值得注意的是如果使用一个额外的数组进行每一次移位字符串的保存，那么每一次移动会设计到O(n)的数据移动，这个相对于使用O(n*(n-1))的额外空间的处理在时间复杂度上没有改良。如果使用s[j++%length]进行访问呢？这个虽然不涉及到每一的元素的移动，但是又多了一个"%length"的运算。从上面的分析，可以看出，目前的思路对于时间的复杂度为O(N*N + N*(N+M))(其中N为s1长度,M为s2的长度)是没有改良的。
改良时间复杂度：
上面描述的算法的时间复杂度O(M*(M+N) + M*M)(M为s1的长度，N为s2的长度)明显太高，影响了算法的实用性。考虑到以下事实：我们要寻找的是s2，由于s2是固定了，如果我们对每一个移位字符串都进行KMP，那么里面进行next数组的计算就是重复的。另外，由于对于每一个移位之后的字符串，使用KMP都会进行从前向后移动的匹配，而多个KMP之间这种尝试性匹配也是存在高度的重复的。
改良复杂度的方案如下：对于abcd我们可以通过在这个字符串后面加上abc构成一个abcdabc字符串。在保证要查找的s2的长度小于容器字符串s1的长度的前提下，如果找到了s2,那么s2一定是重新构建的abcdabc的子串。通过这种转化，可以使用一个KMP算法，复杂度O(2*M - 1 + N)查找s2是否存在在s1的移位字符串中。
同样，由于改良之后的算法的空间复杂度为O(2*M)，如果要进行空间复杂度的优化，可以考虑在原来的字符串上面使用s1[j++%length]这种访问方式，将空间复杂度降低到O(1)
改良了时间复杂度(O(2*M -1 + N))和空间复杂度(O(1))(这里的空间分析没有加入next数组的构建空间，如果加上这一部分，最终的结果应该是O(N))的最佳算法如下：
	int cal3(const char * s1, const char * s2){
		assert(s1 && s2);
		int M = strlen(s1), N = strlen(s2);
		if(M < N)
			return -1;
		//构建next数组
		int *next = new int[N];
		if(!next){
			std::cerr << "new memory fail" << std::endl;
			return -1;
		}
		next[0] = -1;
		//利用迭代计算next[i+1]
		int j = -1; //上一个合适的next
		for(int i = 0; i < N - 1;){
			if(-1 == j || s2[i] == s2[j]){
				//得到next[i+1]
				next[++i] = ++j; 
			}else
				j = next[j];  //回溯，继续计算next[i+1]
		}

		j = -1; //s2中的指针
		int i = 0; //s1中指针
		//说明一下这里的i<(2*M -1)的原因，这里的i的边界是cal2算法中的边界，也就是假设将s1后面添加上s1[0~M-2]构成一个长度为2*M -1的字符串数组
		for(; i < (2 * M -1) && j < N;){
			while(-1 != j && s1[i%M] != s2[j]){
				j = next[j];
			}
			i++;
			j++;
		}
		//释放next数组
		delete [] next;
		return j == N ? i - N : -1;
	}	


60，C/C++中函数的默认返回值类型是什么，如果这个返回值在函数中没有提供又会返回一个什么
分析与答案：
在C/C++中，函数的默认返回值类型是int，也就是说如果没有提供返回值类型，那么这个返回值类型就是int。所以如果要定义一个返回值的类型为void的，一定要明确的指出。
一个函数的返回值没有提供，对于不同的编译器，这个行为是未定义的，返回的是垃圾值。


61，将一个字符串转化为一个int数据，要求考虑各种异常情况。
分析与答案：
这是一本书上的题目，这里给出书上面其本身的主要分析点。
	1）拿一个int保存返回的结果，初始化为0.字符串本身从前往后进行遍历，每次对返回的结果 * 10 + 当前的字符 - '0'.这是正常的运行逻辑。但是这里存在一个符号位的问题，也就是第一位要判断一下是否是符号位，如果是 - ，那么最终的结果需要 * -1。
	2）存在一下可能异常的情况：
		字符串表示的数字，用int存储不下，导致了溢出
		输入的字符串中存在非法的字符，例如第一个字符不是0~9也不是符号位
	这里对于溢出的情况，直接返回0，对于非法字符，会返回非法字符之前的运算结果，但是可以提供一个参数用于接受运行结果是否为非法，这个参数如果不提供那么对于结果调用者不考虑进行验证。如果提供了这个参数，在出现发非法的字符的时候，可以将这个参数设置为非法的状态提供给调用者进行检查
后续补充：
	1）编码的过程中，发现一个小的细节点，由于负数的符号位后面可表示的正数会比正数可以表示的返回大1。那么如果单独的剔除符号位进行统一的后面的纯数字的分析，对于这个最大的负数，计算结果会是溢出。查看书上的代码，其代码的判定为 "num > std::numeric_limits<int>::max()"的时候判定为溢出，也就是其本身的代码也没有注意到这个特殊的情况.
	2）要修复这个小bug，可以对每次要加上的部分都先与符号(1或者-1)相乘，然后在追加到最终的结果中。而不是在正数结果出来之后再添加上符号.
	3）如果叠加的结果是最终的结果，那么可能出现负数。就需要修改原来的溢出判断机制。判断的方案是：如果符号位为负并且叠加的结果为整数或者符号位为正并且叠加的结果为负，那么最后的结果就溢出了。注意，上面的溢出判断不可以统一为用符号(1或者-1)与叠加的结果相乘，如果是负就溢出如果为正就每溢出，原因还是那个边界情况，最大的负数与-1相乘得到的正数是int保存不下的，最终还是个负数。
实际编码：
	/*
		将一个字符串转换为int
	@param const char* str 要转换的字符串
	@param bool * validate=nullptr 用于计算结果合法性检查，这个参数可以不传入。如果这个参数进行了传入，那么在计算结果合法的时候会将值设置为true，否则会设置为false
	@return int 转换之后的int，如果出现了溢出会直接返回0
	@version 1.0 基本实现功能，存在第一个小的bug，就是这里的
	*/
	int StringToInt(const char * str, bool *validate=nullptr){
		if(!str)
			return 0; 
		int length = strlen(str);
		if(!length)
			return 0;
		int minus = 1, i = 0;
		if(str[0] == '+'){
			i++;
		}else if(str[0] == '-'){
			i++;
			minus = -1;
		}
		
		if(validate)
			*validate = true;

		int result = 0; //返回值
		for(; i < length; ++i){
			if(str[i] < '0' || str[i] > '9'){
				//遇到非法字符
				if(validate)
					*validate = false;
				break;
			}
			result *= 10;
			result += (str[i] - '0') * minus; //version2.0 每次追加的结果都与符号相乘
			if(!(-1 == minus && result <= 0 || 1 == minus && result >= 0)){
				//溢出了
				result = 0;
				break;
			}
		}
		//其实这里并不用判断是否overflow 因为前面如果溢出了会将result置为0. 但是个人认为这里这么写可以进行更好的语意表达
		/*version 2.0 符号的处理放到了叠加上 不在这里进行最后的处理
		if(!overflow){
			result *= minus;
		}
		*/
		return result;
	}

62, 如何判断一个字符串s1中的字符是否在s2中全部存在。
答案与分析：
这里的全部存在应该包括存在的次数，也就是说在s1中一个字符出现了n次那么在s2中出现的次数不能少于n。一般性的思路是构建一个256长度的hash数组，这个数组中的值保存的是每个assic字符出现的次数，先扫描s2，一个字符出现了一次就将对应的值加一，然后扫描s1，每一个字符如果出现就将对应的hash数组中的字符计数减一。最后扫描这个hash数组，如果存在某一个字符出现的次数是负数，那么就说明s1存在某个字符出现的次数比s2中多，结果返回false。如果这个hash数组中的所有的值都是非负，那么返回true。
其他的思路：
	可以给每一个字符分配一个素数，一共有256个素数，然后遍历s2，将每一个出现的字符对一个的素数进行相乘，得到一个很大的数。然后在扫描s1，用每一个出现的字符对应的素数去除这个“很大的数”，如果不能整除，那么结果就是false，如果能够整除，那么就将这个“很大的数”重置为除法的结果，然后接着遍历s2进行上述的操作一直到s2的末尾返回true。
	另一种思路是将s1，s2都进行排序，然后遍历s1，s2，如果s2中的字符没有匹配到s1中的就直接后移，如果s2中和s1中字符匹配了，就将s1和s2都进行后移。最后判断s1中的位置是否已经移动到末尾就可以得到最终的结果。对于这一种思路，我曾经分析过是否可以在s1和s2遍历都没有到最后的时候就可以判断到不匹配的情况返回false。实际上可以考虑这么个情况s1="ac" s2="abbbbbbbc"可以看到在遍历到 c > b的时候，只能按照上面的描述一直移动s2的位置指针，一直到最后才能匹配到c字符。目前没有分析到可以在遍历结束前判断出最终的结果的方案。另一方面，排序操作会修改输入的数据，这种行为在很多场合是不合适的（而进行原来的数据拷贝然后进行操作又会有额外的空间开销）.
利用hash表进行判定的代码大致如下：
	bool AllCharsInString(const char * src, const char * dest){
		assert(src && dest);
		int nums[256] = {0}; //保存每一个字符出现的次数
		int M = strlen(src), N = strlen(dest);
		//遍历src 增加相应字符出现次数的计数
		for(int i = 0; i < M; ++i){
			nums[src[i]]++;
		}
		//遍历dest 减少相应字符出现的次数计数
		for(int i = 0; i < N; ++i){
			nums[dest[i]]--;
		}
		//遍历nums数组  如果出现了一个字符的次数小于0那么直接返回false  表示这个字符在src中出现的次数少于dest中的
		for(int i = 0; i < 256; ++i){
			if(nums[i] < 0)
				return false;
		}
		return true;
	}

63，如果进行一个字符串中的按照单词进行逆转，例如"Today is Friday!"进过逆转之后成为"Friday! is Today"
分析：
一种思路是先将整个字符串进行按字符翻转，例如上面的"Today is Friday!"翻转之后就成为"!yadirF si yadoT"，然后在对这个翻转之后的字符串中的每一个单词进行翻转。这种翻转思路是直接在原来的字符串上面进行操作。
另一种思路是从后向前，获取到最后一个单词（如果是多个连续的空格，我个人采取将多个空格保留也认为是一个单词）然后在递归的翻转前面的部分，并且将结果追加到最后的那个单词的后面。这一种思路不会对原来的字符串进行修改（不过也可以将最终的结果再拷贝回原来的字符串中）,如果使用char*类型的返回那么返回的新的字符串的空间需要调用者进行释放，在这里为了编码方便可以使用C++中string类型进行操作(编码方便，内存也更好管理)。
使用翻转的思路代码如下：
	/*
		按照字符翻转一个字符串
	@param char * str 要翻转的字符串
	@param int num 要翻转的字符个数，默认为-1表翻转整个字符串
	*/
	void Reverse(char * str, int num = -1){
		assert(nullptr != str);
		if(num < 0)
			num = strlen(str);
		for(char * p = str, *q = str + num - 1, tmp; p < q;p++,q--){
			tmp = *p;
			*p = *q;
			*q = tmp;
		}
	}


	/*
		按单词进行一个字符串的翻转，这里直接在原字符串上面进行操作	
	*/
	void ReverseByWord(char * str){
		assert(nullptr != str);
		//先翻转整个字符串
		Reverse(str);
		//遍历翻转之后的字符串，对于非空格的单词进行翻转
		int length = strlen(str);
		for(int i = 0, j = 0; i < length; i = j){
			//将i移动到第一个不是空格的字符上
			while(str[i] == ' '){i++;}
			//将j移动到i后面的第一个空格
			for(j = i; j < length && str[j] != ' '; j++){}
			if(i < j){
				//翻转单词
				Reverse(str + i, j - i);
			}
		}
	}
使用递归的思路的代码如下：
	/*
		使用递归的思想，进行字符串按单词的翻转
	@param std::string str 要操作的字符串
	@param int num 要翻转的字符数量, 如果提供的是负数表示翻转整个字符串
	@param 翻转之后得到的字符串
	@note： 这里提供一个num参数，是因为考虑到递归中如果全部使用string.substr来获取前面的子串,那么对于单词很短，整个字符串很长的情况会造成很大的额外内存开销。所以保存一个变量表示当前要翻转的范围
	*/
	std::string ReverseByWord(std::string & str, int num = -1){
		if(num < 0)
			num = str.length();
		if(!num){
			//递归的base
			return "";
		}
		std::string toReturn = "";
		int i = num - 1, j = i;
		while(i >= 0 && str[i] == ' '){
			//空格直接追加到结果集中，因为空格即使进行翻转，结果也是一样的。
			toReturn += ' ';
			i--;
		}
		for(j = i; j >= 0 && str[j] != ' '; --j){};
		if(j < i){
			//将单词追加到结果中
			toReturn += str.substr(j + 1, i - j);
		}
		return toReturn + ReverseByWord(str, j + 1); 
	}


64，删除一个字符串中出现的指定的模式串的字符。例如"abccdd" 删除指定的模式"cd"之后就成为了"ab"
分析：
正常思路，是遍历查询的s1，然后用其中的每一个字符与模式串s2中的字符一一比对。设s1、s2的长度是M、N，那么这个算法的复杂度是O(M*N)。更一般的算法是，利用一个hash表（一般这个hash表的长度是256，但是特定情况下可能会更小，例如如果假设都是小写字母，那么只需要26就行了，不过这个对于空间复杂度的优化很不明显而且要进行char - 'a'这样的计算，增加了计算指令），先遍历s2，将s2中存在的字符对应的hash表中的值设置为true，然后遍历s1，对于每一个字符去查询hash表，如果存在就删除（如果重新构建一个新的字符串，这里的删除是一次忽略）.
另一个依赖于高级数据结构的算法是，将所有的字符分配一个不同的素数，然后遍历s2，将s2中这些对应的素数相乘，得到一个很大的数，然后遍历s1，用每一字符对应的素数去除得到的那个“很大的数”，如果可以整除，就将这个字符删除.
使用hash算法复杂度为 O(M + N + 256)的算法如下:
	/*
		删除一个字符串中的可能出现的一系列字符
	@param char * str 要处理的字符串
	@param char * mode 包含要被删除的字符的模式字符串
	@return char * 删除之后的字符串 如果内部运行异常会返回null
	@note: 这个函数内部申请的资源需要调用者释放
	*/
	char * DeleteCharsInMode(const char * str, const char * mode){
		assert(str && mode);
		bool hash[256] = {0};
		int M = strlen(str), N = strlen(mode);
		char * toReturn = (char*)malloc((M + 1) * sizeof(char));
		if(!toReturn)
			return nullptr;
		//遍历mode 设置hash
		for(int i = 0; i < N; ++i){
			hash[mode[i]] = true;
		}
		//遍历str 构建返回值
		int lenReturn = 0;
		for(int i = 0; i < M; ++i){
			if(!hash[str[i]])
				toReturn[lenReturn++] = str[i];
		}
		toReturn[lenReturn++] = '\0';
		//重新开辟空间
		toReturn = (char*)realloc(toReturn, lenReturn);
		if(!toReturn)
			return nullptr;
		return toReturn;
	}


65,设计一个trim函数，去掉一个字符串前后的空格，将中间的空格多个连续的空格转换为一个
分析：
常见api中的trim有trim_left trim_right trim，但是他们一般的不会合并中间的空格.这里的实现策略是从左往右进行扫描，首先跳过最前面的空格，然后添加第一个单词(到下一个空格部分之前)。接下来的处理就很统一，如果一直是空格就往后移动，如果遇到非空格就记录下紧邻上一个连续空格的非空格的位置，然后一直向后移动到空格，在这个单词添加到最终的结果之前向结果中添加一个空格，循环上面的过程一直到遍历结束，就得到最终的trim之后的字符串。
大致代码如下：
	char * trim(const char * s){
		assert(s);
		int length = strlen(s);
		char * toReturn = (char*)malloc((length + 1) * sizeof(char));
		if(!toReturn)
			return nullptr;
		int i = 0, j = 0, k = 0;
		//处理最前面的空格
		while(i < length && s[i] == ' '){ i++;}
		//处理第一个单词
		for(j = i; j < length && s[j] != ' '; ++j){
			toReturn[k++] = s[j];
		}
		//处理中间和最后的空格和单词
		while(i < length){
			//略过空格
			for(i = j; i < length && s[i] == ' '; ++i){}
			//获取单词结束位置
			for(j = i; j < length && s[j] != ' '; ++j){}
			//如果i < j也就是存在单词 那么将一个空格和单词添加到结果中
			if(i < j){
				toReturn[k++] = ' ';
				for(int x = i; x < j; ++x)
					toReturn[k++] = s[x];
			}
		}
		toReturn[k++] = '\0';
		//重新分配合适空间
		toReturn = (char*)realloc(toReturn, k * sizeof(char));
		if(!toReturn)
			return nullptr; //注意，这里完全可以不去判断是否为null，因为toReturn为null的时候直接返回toReturn对于最终的结果是一样的，但是这里这么写可以让逻辑更清晰
		return toReturn;
	}

66，找出一个字符串中第一个只出现一次的字符。例如abaccdeff，会输出b。假设所有的字符都是assic的。
分析：
利用一个hash结构存储每一个字符出现的次数，遍历输入的字符串，填充这个hash。由于要找到“第一个”，那么再遍历一次输入的字符串，如果找到某一个字符刚好出现次数是1的就返回。
	/*
		获取一个字符串中第一个只出现一次的字符
	@param const char * str 要查找的字符串
	@return 如果找到了就返回这个字符串中第一个只出现一次的字符。如果没有这样的字符存在就返回 '\0'
	*/
	char GetOnlyOnce(const char * str){
		assert(nullptr != str);
		int hash[256] = {0}; //保存每一个assic字符出现的次数
		//遍历字符串  填充hash
		const char * p = str;
		for(;*p;p++)
			hash[*p]++;
		//遍历字符串，判断字符出现的次数
		for(p = str; *p; p++){
			if(1 == hash[*p])
				break;
		}
		return *p;
	}


67，如何判断一个字符串中是否所有的字符都是不同的。
分析：
利用hash结构存储是否一个字符在字符串中存在，然后遍历这个输入字符串，对于当前字符对应在hash结构中不存在，就将状态设置为已经存。如果hash中给出的结果是已存在，那么这个字符就出现了2次，直接可以返回false。这如果要降低空间的要求，可以考虑使用bit-map，因为一个位已经够用来表示一个字符的是否已经出现的状态了。
大致的代码如下：
	bool AllDifferentInString(const char * str){
		assert(nullptr != str);
		bool hash[256] = {0}; //保存每一个assic字符是否已经出现 
		for(const char * p = str; *p; p++){
			if(hash[*p])
				return false;
			hash[*p] = true;
		}
		return true;
	}


68，memcpy和strcpy的区别
答案：
memcpy和strcpy都是C标准库的函数。strcpy只能用于复制字符串，而memcpy可以用于任何连续结构(例如数组、结构体、类)的内存空间的拷贝。strcpy不仅会复制字符串的内容，还会复制字符串的结束符。strcpy由于是用'\0'判断复制结束的，所以不用长度，而memcpy是通过第三个参数指定要复制的长度的。两个函数的签名为 char * strcpy(char * dest, const char * src) 和  void* memcpy(void * dest, void * src, size_t n)

69,一个字符串中只有a~z的字符，如何使用最小的空间来计算这个字符串中到底有哪些字符。
答案：
由于只有26个字符，那么一个int就可以搞定。用一个int的每一位存一个字符对应的状态，为1表示存在，为0表示不存在。设置一个int result = 0 遍历这个字符串，如果一个字符存在就，就将result | (1 << (*str++ - 'a'))重置这个result。遍历完成之后，再遍历这个int，初始计数器i=0,使用 result & (1 << i++) ，判断这个结果为1还是0，如果是1表示相应的字符存在。


70，设计一个strcpy函数
答案：
主要的细节点有：对于字符串为null的断言  源字符串需要用const修饰，这样更严谨  返回原来的目标字符串，方便链式操作
代码如下：
	char * strcpy(char * dest, const char * src){
		assert(dest && src);
		char * toReturn = dest;
		while(*dest++ = *src++){}
		return toReturn;
	}

71，将字符串中所有的空格替换成"%20"。函数的签名形式为 void ReplaceFunc(char str[], int length)
分析：
通过函数的签名，可发现对于空间的保证是由调用者去实现的。对于空格的替换，如果是从前往后进行，那么由于替换之后的字符串比空格更长，会导致对后面还没有替换和拷贝的原来的内容进行了覆盖。所以这个函数的逻辑应该是从后往前进行覆盖。
代码如下：
	/*
		将一个字符串中的所有空格替换为"%20"
	@param char str[] 要处理的字符串
	@param int length 要处理的字符串的长度
	*/
	void ReplaceFunc(char str[], int length){
		int newLen = length; //新的替换后的字符串的长度
		for(int i = 0; i < length; ++i){
			if(str[i] == ' ')
				newLen += 2;
		}
		str[newLen] = '\0';  //添加新的结束符
		//从后往前遍历str 保存替换结果
		for(int i = length - 1, j = newLen -1; i >= 0; --i){
			if(str[i] == ' '){
				str[j--] = '0';
				str[j--] = '2';
				str[j--] = '%';
			}else
				str[j--] = str[i];
		}
	}
问题延伸：
	1）这个函数的经过简单的修改，可以实现对于任意的字符用某一个字符串进行替换
	2）更一般的，对一个字符串中的某一个子串进行匹配替换，可以考虑使用KMP（为了避免重复的运算，需要适应的改良）从前往后查找，用一个新的空间保存替换之后的结果返回。这个就有些像正则里面的repacleAll了，当然也可以设定一种只替换第一个匹配的子串。这里对于KMP的运用更多的是一种思想，对于不同的子串，由于匹配模式一样，所以next属猪只需要构建一次；还有要计算需要存储的结果字符串的空间开销的时候遍历了一次字符串，这个时候，可以把KMP查询到的一系列的子串的位置保存下来，这样接下来的替换就不用再进行查找了。
	3）和2）相似的问题是提供一个模式字符串，要求对输入字符串与模式串中的所有匹配的字符替换某一个字符串
这里对于延伸问题3）的代码：
	/*
		延伸： 将一个字符串中的所有与模式串中字符匹配的元素都替换为某一个字符串
	@note: 这里不在原来的字符串上面进行操作，而是将结果返回一个新的字符串，资源需要调用者进行释放
	*/
	char * ReplaceByMode(const char * str, const char * mode, const char * replace){
		assert(str && mode && replace);
		int length = strlen(str), newLen = length, replaceLen = strlen(replace);
		//利用模式串 构造hash
		bool hash[256] = {0};
		while(*mode){
			hash[*mode] = true;
			mode++;
		}
		//计算新的数据空间
		for(int i = 0; i < length; ++i){
			if(hash[str[i]])
				newLen += replaceLen - 1;
		}
		char * result = new char[newLen + 1];
		if(!result){
			std::cerr << "new memory fail" << std::endl;
			return nullptr;
		}
		result[newLen] = '\0';
		//遍历原字符串  填充结果字符串
		for(int i = 0, j = 0; i < length; ++i){
			if(hash[str[i]]){
				//进行替换
				for(int k = 0; k < replaceLen; ++k)
					result[j++] = replace[k];
			}else{
				//直接复制原来的字符
				result[j++] = str[i];
			}
		}
		return result;
	}
对于问题2）进行子串的替换的线性代码如下:
	/*
		延伸： 将一个字符串中的所有某个子字符串替换为另一个字符串
	@note: 这里不在原来的字符串上面进行操作，而是将结果返回一个新的字符串，资源需要调用者进行释放
	*/
	char * ReplaceSubStr(const char * str, const char * substr, const char * replace){
		assert(str && substr && replace);
		int length = strlen(str), newLen = length, subLen = strlen(substr), replaceLen = strlen(replace);
		if(!subLen){
			std:: cerr << "the substring is null" << std::endl;
			return nullptr;
		}
		//构建next数组
		int *next = new int[subLen];
		if(!next){
			std::cerr << "new memory fail" << std::endl;
			return nullptr;
		}
		next[0] = -1;
		//迭代计算next[i+1]
		for(int i = 0, j = -1; i < subLen -1;){
			if(j == -1 || substr[i] == substr[j]){
				next[++i] = ++j;
			}else{
				j = next[j]; //回溯
			}
		}

		//在原字符串中查询目标子字符串出现的位置
		std::vector<int> pos; //保存查找到的子串的位置
		int sub = replaceLen -  subLen; //用于替换的字符串与原子字符串的长度差

		for(int i = 0, j = 0; i < length;){
			if(j == -1 || str[i] == substr[j]){
				i++;
				j++;
				//如果匹配完成  就将位置添加到容器
				if(j == subLen){
					pos.push_back(i - subLen);
					//修正返回结果字符串的长度
					newLen += sub;
					//重置j 表示开始下一个位置的查询
					j = 0;
				}
			}else
				j = next[j];
		}
		//开辟返回结果的字符串空间
		char * result = new char[newLen + 1];
		if(!result){
			std::cerr << "new memory fail" << std::endl;
			return nullptr;
		}
		result[newLen] = '\0';
		//遍历原字符串到最后一个找到的子串  填充结果字符串
		int size = pos.size();
		int i = 0, j = 0;
		for(int k = 0; k < size; ++k){
			//复制查询到子串之前的部分
			for(; i < pos[k]; ++i)
				result[j++] = str[i];
			//将查询到的子串替换为目标字符串
			for(int t = 0; t < replaceLen; ++t)
				result[j++] = replace[t];
			i = pos[k] + subLen;
		}
		//复制最后查询到的子串之后的其他部分
		for(; i < length; ++i)
			result[j++] = str[i];
		//释放资源
		delete [] next;
		return result;
	}

72，C++中struct可以有无参数的构造方法吗，有继承与多态吗，与class的区别是什么
答案：
C++中的struct与class都可以有各种构造方法，都有继承与多态。二者最大的区别是struct中的默认权限是public的而class中的默认权限是private的。

73，C/C++中的位域是什么，有什么用
答案：
在有些信息进行存储的时候，不需要一个完整的字节，而只需要一个或者几个二进制位，为了节省存储空间，C语言提供了以一种可以指定数据所占位数的数据结构，称为位域。在使用位域的时候字段的类型应该为整型(包括无符号整型和其他的数字类型例如bool char short)或者枚举，在类型名与变量名后面可跟上冒号加上变量占用的位数。格式如下：
	unsigned int SN:4; //占用4个位
	unsigned u:1; //1个二进制位
	int :2; //占用2个二进制位  并且为匿名
在结构体中可以使用匿名的位域字段来提供间距：
	struct reg{
		unsigned int s:4;
		unsigned int :4;
		bool good:4;
	}
	对于上面的结构体的变量的初始化，直接略忽略占位的部分就可：
		reg r = {14,true};
-----note: 和其他的类型一样，如果提供的初始化或者赋值的值超过了位域的范围，会将低位的内容赋给变量。

74，C++由哪两部分组成。
答案：
C++语言由核心语言和标准库两个部分组成。核心语言主要是一系列的关键词组成，提供了一些数据类型和结构控制。如果仅仅使用核心语言，不能执行一些输入输出或者更复杂的操作，这个时候就需要使用标准库函数了。使用标准库的函数需要使用using namespace std 或者使用std::cout 这种形式进行引用，而使用核心语言没有这些限制。


75，结构体和共用体的内存占用与所有成员所占的空间之和是什么关系，与其中的最大的元素的所占空间的大小又是什么关系
答案：
结构体的占用空间的大小是大于等于所有成员的空间之和的，原因是可能由于对齐的问题，会需要额外的空间。共用体和结构体一样都是从低地址开始存放元素，也会先出现对齐的情况。共用体的空间为各个成员中占用最大的那个的内存（有的成员可能由于需要对齐出现扩充内存）


76,关于printf函数，参数的入栈是从左往右还是从右往左，对于每一种数据类型入栈的空间大小是多少
答案：
printf函数的入栈顺序是从右往左的，这样依次出栈打印的结果就是从左往右的。对于数据类型，如果是char short 等小于4个字节的元素入栈，入栈的时候会占用4个字节，这样printf("%d",'a'）这样的输出结果的正确性得到了保证，如果数据的类型不满4个字节进行填充到4个字节，当数据的类型是无符号的时候高位统一填充1，如果是有符号的时候高位填充符号位。如果数据的类型大于4个字节的时候，参数以实际的所占字节数入栈。对于字符串的类型，入栈的是一个指向字符串的指针。

77，long long x = 0x0102030405060708 在小端的机器上，printf("%x",x)输出的结构是多少
答案：
小端的机器是高位存放在高字节，低位存在在低字节。这里x入栈之后低字节存放的是0x05060708。然后%x是以16进制的形式打印一个int，所以这里输出的结果是栈顶的0x05060708

78,枚举类型占用多少个字节
答案：
枚举是一系列的枚举常量的集合，其本身类型占用4个字节，相当于一个unsigned int

79,小端机器上，下面的程序执行的结果是多少
	struct S{
		unsigned short a:5;
		unsigned short b:5;
		unsigned short c:6;
	} s = {16,4,0};
	prinft("%d",*(short*)&s);
结果与分析：
上面的s的内存结构为 0000000010010000 将其转换为short然后输出结果为144. 其实这里的结果就是4 * 2^5 + 16 = 4 * 32 + 16

80，sizeof是函数吗？sizeof int 这样的写法是否正确。int i = 1; cout << sizeof(i++); 之后i的结果是多少。那些情况下使用sizeof会被编译器判定为非法
分析与答案：
sizeof本身是一个运算符，不是函数，如果计算传入是一个变量，那么后面用不用括号括起来都是可以的，如果是传入了一个类型例如int，那么这个传入的类型必须使用括号包起来。所以上面的 sizeof int是不合法的。
另一个注意的点是，sizeof的结算结果是在编译阶段，所以一般不会对其中的表达式进行实际的计算，如果是传入一个函数的执行表达式，那么这个函数的执行表达式不会执行，sizeof只会去查看这个函数的返回值类型。所以sizeof(i++)，运算符只会去查看i的变量类型而不会实际执行i++，另一方面这是一个表达式而不是函数传参，所以i++不会执行，也就是说sizeof(i++)之后i的结果是不会发生变化的。类型的 int func(){printf("hello"); return 0;} sizeof(func())这个func里面的打印语句也是不会执行的。
sizeof操作符不能对函数、不确定的类型(void)和表达式 和位域成员进行直接的计算。例如下面的写法是错误
	int func(){}; sizeof(func);
	void func(){}; sizeof(func());
	struct S{unsigned u1:1; unsigned u2: 2;}s; sizeof(s.u1);
-----note: 另一点要说明的是sizeof的结果与具体的平台有关，例如int的结构在32位系统上一般可以认为是4，而在16位机上为16

81，void func(char s[100]){ cout << sizeof s; } 输出的结果是多少
答案：
当数组用作形参的时候，会弱化为指针，这个时候进行sizeof获取到的是一个指针的大小，这里的结果是4.
-----note: 这里常常用来和引用传参相比较，引用传递的参数如果使用sizeof取得的就是原来的引用的变量的空间大小. 例如void fun(char (&s)[100]){cout << sizeof(s);} 由于s引用了一个100长度的数组，所以结果为100

82，没有任何成员的struct和class，它们的sizeof的结果是多少
答案：
结果是1. 对于没有任何成员的结构体或者是类，他们创建的对象空间都是1.这一字节是用来标识不同的对象的。这样对于不同的对象进行取地址之类的操作才有意义。空的class和struct也得存储，所以编译器为他们分配了一个字节的空间用于占位。

83，关于struct和union空间的计算问题原则
答案：
struct和union都是从低地址向高地址进行元素的存放的。所以计算的时候也是从申明的顺序进行分析。按照这个顺序主要考虑的原则有以下两点：
1）整个struct或者union的空间必须是其中的最大的元素的所占空间的整数倍。这里值得注意的对于数组元素，进行考虑的是其基础数据类型大小而不考虑整个数组的长度，数组从本质上来说也是一系列的类型相同的元素的连续存储。如果最大的元素所占的空间超过了4，例如是8，在windows下面一般可以认为这个struct或者union的空间必须是8的整数倍。但是在linux+gcc的环境下，如果最大的成员空间超过了4，那么就规定整个数据空间只需要为4的倍数就行。
另一方，可以使用伪指令 "#pragma pack"指定需要按照多少个字节进行对齐。#pragma pack(n)指定用n个字节进行对齐，但是如果在struct或者union中最大的元素的空间比n小，那么还是会以那个最大元素空间进行对齐。也就是说最终按照多少个字节进行对齐取决与这里设置的n与实际结构中的最大元素的空间的较小者。可以使用#paragma pack()取消用户自定义的对齐方式。这种使用伪指令通知编译器对齐方式的地方一定要在struct和union的定义之前。
2）从低地址向高地址存放元素的时候，在判断一个元素的时候，其前面的元素的所占空间的总和必须是当前这个元素的空间的整数倍，如果不是就在前面元素的后面进行填充实现对齐。如果是linux+gcc的环境下，一个元素的大小如果超过4，那么前面的元素的空间的总和只要为4的整数倍就行。当然对齐的方式是可以按照上面说的使用#paragma pack(n)进行设置的。如果设置一个n=2那么只需要是是2的整数倍就行。
----note:对于union的空间的分析，一个小技巧就是先把union当做struct进行分析，然后取得其中元素所占空间的最大值（考虑到对齐，可能这个空间需要填充）


84，对于结构体中存在位域的情况，如果计算结果体的大小
答案：
从前往后进行扫描，如果相邻的位域的类型是相同的，那么会进行压缩，多个相同的类型的位域进行压缩共同占用一个位域的类型的空间大小。如果相邻的位域相加的结果是大小小于一个sizeof他们的类型，那么后一个位域会紧邻着放。如果相邻的位域的空间大小之和大于一个sizeof相应的类型，那么后面的位域需要放置到下一个相应的类型的空间。多个相同类型的位域的压缩之后的空间是其基本类型的整数倍。但是对于Linux+gcc环境或者是Dev-C++环境，不论位域是何种数据类型，每个位域都是占用实际的空间大小（无论后面是不是位域，无论相邻的位域类型是否相同），也就是一个字节一个字节的空间向后延伸。
如果相邻的位域的类型不相同，在vs中是不是采用压缩的，而在Dev-C++和Linux+gcc中无论相邻的字段类型是否相同，都以实际占用的字节进行压缩。
如果一个位域后面不是位域，那么不会进行压缩，这个位域还是占用原来的类型的空间的大小，但是在Dev-C++和Linux+gcc的环境中，即使后面不是（相同类型的）位域，这个字段所占的空间也还是压缩之后的实际字节数。
整个结构体的大小是最宽基础数据类型的整数倍。这里的基础数据类型包括位域的数据类型。
例子：
	struct{
		int i1:4;
		int x;  
	}
	分析：i1后面不是位域，如果在vs中整个i1就要占用4个字节，整个struct占用8个字节。如果是在Linux+gcc环境中，i1占用1个字节，然后紧邻着放x，最后由于基础数据类型的最大空间是4，整个空间在1+5的基础上进行扩展为8.


85，下面的struct占用多少字节
	#paragma pack(8)
	struct S{
		union A{
			char a[13];
			int b;
		} a;
		void func(){};
		typedef void (*p)(int i);
		int i1:4;
		short s:2;
	}
	#paragma pack()
分析与解答：
首先union A占用13 + 3（与int对齐）= 16个空间。然后函数与typedef的部分不占用空间，因为这里只是定义了类型而没有定义相应类型变量。后面两个位域由于类型不同，在VS中不进行压缩分别占用4和2，然后short后面为了对齐int扩展2个字节。最终的结果是16 + 4 + 2 +2 = 24。如果在linux+gcc环境下，后面两个位域一共占用1个字节。16 + 1 不是int空间的整数倍，扩充3个字节之后的结果为20。由于这个结构体中的所有的基础数据类型都比设置的对齐空间8个字节要下，所以这里设置的8个字节的对齐没有产生作用。


86，下面的union的空间大小是多少
	#paragam pack(2)
	union U{
		char buff[13];
		int i;
	}
	#param pack()
分析与解答：
buff占用13，然后存放i，i占用4，并且这里设置了2个字节的对齐方式，所以 buff的空间需要为2的整数倍，所以最终的结果是 13 + 1 = 14


87，比较下面几个运算的优先级: 前置++  后置++  负号运算符  按位取反运算符~  移位运算符 赋值运算符  逻辑运算符   算数运算符
答案；
后置自增自减的优先级最高  结合的方向是从左往右
其次是负号运算符、前置自增自减、按位取反~和非运算！ 他们位于同一个优先级，谁先进行计算取决与结合方向上的顺序   他们的结合方向都是从右往左
紧邻的是算数运算符中的 / %  * 他们的结合方向是从左往右 
然后是算数运算符  + -  结合反向也是从左往右 
然后是移位运算符  结合的反向是从左往右 
然后是逻辑运算符中的  > >= < <=  结合方向是从左往右
然后是逻辑中的 == !=   结合方向是从左往右
然后是位运算中的 & ^ | 这三个运算符的优先级依次降低(& > ^ > |)  结合方向是从左往右
然后是逻辑中的 &&  结合方向从左往右
然后是逻辑中的  || 结合方向是从左往右
然后是是三目运算符?:  结合的方向是从右往左
然后是赋值运算符(= &= -= +=等等) 结合的方向是从右往左
最后是逗号运算符  结合的方向是从左往右

-----note: 上面的整体规律符合: 后置自增 > (前置自增、~、！、符号运算符) > 算数运算符(内部又是乘除 > 加减) > 移位运算符  >  逻辑比较（其中== != 要比 < <= > >=要低） > 位运算符(内部 & > ^ > |) > 逻辑连接(&& > ||)  > 三目?: >  赋值 > 逗号
---note：对于结合的方向，从右往左的有前置自增 赋值 逗号  三目运算符

88，表达式与语句区别
答案：
语句通常是以分号结尾的（语句可以分为说明性语句和可执行性语句），语句没有值而表达式有。


89，什么是左值，什么是右值
答案：
一个赋值表达式，左右两边的变量分别有着不同的角色，对于左边的元素这个变量代表的是它所在的存储单元的地址，而对于右边的元素我们需要的是它的值。这样一个变量名有了两种特性，我们把一个变量名代表的单元地址成为该变量名的左值，而把一个名字的值成为该变量名的右值。

90，下列的转换是否合法：int n = 0; int i = &n; 
答案：
不合法，在C++中不允许int和指针的直接转换(包括int到指针和指针到int)，如果没有进行自己的转换就直接进行赋值会编译通不过。但是指的注意的是这个问题在C语言中只是一个警告，也就是编译是ok的。

91,关于自增自减，下面的输出结果是什么
	void main(){
		int a, b, c, d;
		a = 5;
		b = 5;
		c = (a++) + (a++) + (a++);
		d = (++b) + (++b) + (++b);
		printf("a=%d, b=%d, c=%d, d=%d\n", a, b, c, d);
	}
分析与结果：
在这道题的书的说明上，说在VS2010中的结果是8,8,15,24，而在vc6.0 Dev-C++ gcc中的结果是8,8,15,22。也就是说这样写代码的结果可能是不同的编译器可能处理的可能不同。
在上面的说明的基础上，进行下面的分析：相加
前置的++是在表达式参与计算之后再对变量++，所以c中是5 +５+5 然后进行三次a的自加。而d中是先进行三次b的自增然后计算d的值 8 + 8 + 8。
关于gcc和dev中的结果是22的分析如为：由于汇编（将汇编代码转为二进制）的时候只能进行两个数的相加，所以(++b) + (++b) + (++b)被解释为(++b) + (++b)的结果(b两次自增变成7然后7 + 7)然后与 ++b进行相加，所以最终的结果为 14 + 8。这个解释虽然通了，但是同样的解释如果使用到c的计算那么就是10 + 7。而实际的结果又不是这样的。再次说明了这种书写的方式是不可预见的（对于不同的编译器结果可能不同），应该规避这种写法。例如d的计算可以修改为下面的形式：	
	++b;
	++b;
	++b;
	d = b + b + b;  //这样语意就是清晰而明了的

92，前置自增与后置自增的区别
答案：
前置自增表达式的值是变量自增之后的结果，实际操作的过程是取变量的地址将变量自增然后将自增之后的值送去寄存器。后置自增是取变量的地址，将值送入寄存器，然后增加内存中变量的值。由于++i是将i自增然后送去寄存器，所以++i是可以用作左值的，这个地址还是i。而i++首先将i的值送入了寄存器，然后将内存中的i的值进行自增，所以i++这个表达式的是一个临时变量，所以只能用作右值。