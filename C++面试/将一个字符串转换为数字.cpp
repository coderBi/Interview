#include <iostream>
#include <string.h>
using namespace std;

/*
题目描述：
	输入一个表示整数的字符串，把该字符串转换为整数并输出，例如输入字符串“345”，输出345
题目分析：
	这是一本书上的题目，这里给出书上面其本身的主要分析点。
		1）拿一个int保存返回的结果，初始化为0.字符串本身从前往后进行遍历，每次对返回的结果 * 10 + 当前的字符 - '0'.这是正常的运行逻辑。但是这里存在一个符号位的问题，也就是第一位要判断一下是否是符号位，如果是 - ，那么最终的结果需要 * -1。
		2）存在一下可能异常的情况：
			字符串表示的数字，用int存储不下，导致了溢出
			输入的字符串中存在非法的字符，例如第一个字符不是0~9也不是符号位
		这里对于溢出的情况，直接返回0，对于非法字符，会返回非法字符之前的运算结果，但是可以提供一个参数用于接受运行结果是否为非法，这个参数如果不提供那么对于结果调用者不考虑进行验证。如果提供了这个参数，在出现发非法的字符的时候，可以将这个参数设置为非法的状态提供给调用者进行检查
后续补充：
	1）编码的过程中，发现一个小的细节点，由于负数的符号位后面可表示的正数会比正数可以表示的返回大1。那么如果单独的剔除符号位进行统一的后面的纯数字的分析，对于这个最大的负数，计算结果会是溢出。查看书上的代码，其代码的判定为 "num > std::numeric_limits<int>::max()"的时候判定为溢出，也就是其本身的代码也没有注意到这个特殊的情况.
	2）要修复这个小bug，可以对每次要加上的部分都先与符号(1或者-1)相乘，然后在追加到最终的结果中。而不是在正数结果出来之后再添加上符号.
	3）如果叠加的结果是最终的结果，那么可能出现负数。就需要修改原来的溢出判断机制。判断的方案是：如果符号位为负并且叠加的结果为整数或者符号位为正并且叠加的结果为负，那么最后的结果就溢出了。注意，上面的溢出判断不可以统一为用符号(1或者-1)与叠加的结果相乘，如果是负就溢出如果为正就每溢出，原因还是那个边界情况，最大的负数与-1相乘得到的正数是int保存不下的，最终还是个负数。
*/

/*
	将一个字符串转换为int
@param const char* str 要转换的字符串
@param bool * validate=nullptr 用于计算结果合法性检查，这个参数可以不传入。如果这个参数进行了传入，那么在计算结果合法的时候会将值设置为true，否则会设置为false
@return int 转换之后的int，如果出现了溢出会直接返回0
@version 1.0 基本实现功能，存在第一个小的bug，就是这里的
*/
int StringToInt(const char * str, bool *validate=nullptr){
	if(!str)
		return 0; 
	int length = strlen(str);
	if(!length)
		return 0;
	int minus = 1, i = 0;
	if(str[0] == '+'){
		i++;
	}else if(str[0] == '-'){
		i++;
		minus = -1;
	}
	
	if(validate)
		*validate = true;

	int result = 0; //返回值
	for(; i < length; ++i){
		if(str[i] < '0' || str[i] > '9'){
			//遇到非法字符
			if(validate)
				*validate = false;
			break;
		}
		result *= 10;
		result += (str[i] - '0') * minus; //version2.0 每次追加的结果都与符号相乘
		if(!(-1 == minus && result <= 0 || 1 == minus && result >= 0)){
			//溢出了
			result = 0;
			break;
		}
	}
	//其实这里并不用判断是否overflow 因为前面如果溢出了会将result置为0. 但是个人认为这里这么写可以进行更好的语意表达
	/*version 2.0 符号的处理放到了叠加上 不在这里进行最后的处理
	if(!overflow){
		result *= minus;
	}
	*/
	return result;
}

int main(){
	//整数 未溢出
	cout << StringToInt("345") << endl;
	//负数 未溢出
	cout << StringToInt("-345") << endl;
	//溢出
	cout << StringToInt("345111111111111111111") << endl;
	//含有非法字符
	cout << StringToInt("-345aa11111111111111111") << endl;
	//边界问题，最小的负数
	cout << StringToInt("-2147483648") << endl;  //这个结果在V1.0中是存在bug的输出了0，被判定为溢出。在V2.0中修复了这个问题
	return 0;
}