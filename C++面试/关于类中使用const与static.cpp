#include <iostream>
using namespace std;

/*
概念：
	1）在类里面使用static修饰成员变量和成员方法表示这个变量或者方法不属于某一个特定的对象，而是属于这个类，被所有的这个类的对象所共享。static修饰的属性（如果没有同时被const修饰）的初始化必须在类的定义体的外部进行初始化。如果一个static的整型（包括bool char short int long1)virtual static void func）数据同时被const修饰，那么可以直接在类的定义体中初始化(这个是一个特例，但是仍然需要在类的外进行定义，只是不用初始化).
	2）在成员属性上面进行const修饰，表示属于一个对象上的一个常量，这种const属性（如果没有同时被static修饰）的初始化必须在构造函数的初始化列表中进行。如果同时被static修饰并且是整型(bool char short int long)数据，那么可在类的定义体的外部进行初始化。值得注意的是，多个同类型对象中的某一个相同的常量的值可能不同，这里的const是指的一个对象的const属性一旦初始化之后就不能更改。const如果作用在成员方法上，那么表示这个方法不能修改当前调用它的对象的属性（成员方法的调用隐含传递了一个this指针，而const就是修饰到了this指针的指向内容）。
	3）对于static关键字，如果是在类的定义体的外部进行初始化，不需要（也不能）带上static关键字，但是对于const关键字不能省略。
实测补充：（以下分析，都是基于类中的）
	1)对于static变量(无论是否同时有const的修饰)，如果没有进行初始化，在其他的地方没有进行引用的情况下没有编译错误，如果出现了引用就会报引用了未定义的变量的错误。这是因为类中只是对这个变量进行了一次申明（没定义）。
	2)通过测试,在类的定义体中，如果没有被static和const修饰，只要是基本的数据类型、指针类型、使用无参数构造函数的对象，都是可以在其中直接定义(初始化)的。
	3）static的变量如果要想在类的定义体中初始化必须借助const, static const对于基本类型可以直接初始化，但是由于是static的所以不能在构造函数内部和初始化列表中进行初始化。如果没有在类的定义体中直接初始化，那么需要在外部进行初始化.
	4）被const修饰的变量，如果没有被static修饰，就必须提供初始化，对于基本类型、指针类型、使用默认构造的对象可以直接值在类的定义体中初始化(类类型的属性在定义的时候不能在变量名后面加上括号)，一般const的初始化必须在初始化列表中进行。
*/

class Base
{
public:
	int x;
	static int s;
	Base(){
		//s = 121; //注意这里不是初始化，而上面类中只是对s进行了一次申明，所以s是没有定义的
		x = 110;
		cout << "construct base" << endl;
	}
	Base(int x){
		this->x = x;
	}
};

class Test
{
public:
	static int s; //static的变量，必须在类的定义体的外部进行初始化，这仅仅是一个申明，如果在其他的代码中没有引用到这个属性，是不会报错的，但是如果有引用，那么会显示未定义的错误。
	//static int s1 = 12;  //static的如果要想在类定义体中进行初始化，只有被const修饰的情况下,这里会提示禁止非const的static在内部进行初始化。
	static const int s2; //static const 依然只是申明，需要在外部定义
	static const int sc = 100;  //属于类，由于是整型数据可以在类的定义体中进行初始化，但是仍然需要在外部进行定义（这个是书上的描述，但是实际测试发现并不是必须还得在外部定义，是不是编译器有优化暂不清楚）。
	static const int sc2; //只是申明
	//const int c; //错误：C++中的const必须要要初始化，C语言中const可以不初始化，但是是一个不能修改的垃圾值
	const double c = 1.12;  //基础数据类型const，可以直接初始化

	int i = 99; //普通的成员变量，不被const和static修饰的时候，也可以直接初始化，不知道是不是优化
	Base base;
	Base b1(); //这里的解法会被解析为返回值为Base参数为空的b1函数。如果是要申明一个对象类型的属性，那么这里不能带上b1后面的括号。
	//Base b2(100); //错误，类的定义体中只能放对象类型属性的申明，他们的初始化应该在构造函数中进行，所以这里不能给b2传递参数，因为这里只是申明
	void print(){
		//cout << s << endl; //显示未定义，因为s只有申明没有定义。
		//cout << s2 << endl; //static const 仍然显示没有定义
		cout << sc << endl;
		cout << sc2 << endl;
		cout << this->c << "-----" << this->i << "----" << base.x << endl;
		//cout << b1.x << endl; //这里报错，说b1不是class的类型。原因是如果申明b1为一个属性成员，那么不能在b1的后面带上括号()，否则会解析为一个返回值为Base名字为b1的成员函数.
	}
};
//const int Test::sc; //这里如果没有在外部进行定义，通过测试编译也没有报错(是不是有内部的优化暂不清楚)
const int Test::sc2 = 111; //这里的定义不能省略，因为在类的定义体中也没有进行初始化

int main(){
	Test t;
	t.print();
	return 0;
}