#include <iostream>
using namespace std;

/*
分析思路：
	1）分析重写，与子类中的函数是否是virtual的无关
	2）一个virtual的函数与非virtual的函数同名，出现在一个类中也是构成重载
	3）子类中只要出现同名的函数，那么就对父类中所有的同名函数构成屏蔽，如果父类中存在同名同参数的函数，当这个函数的被virtual修饰的时候就构成重写（影响到多态），如果这个函数没有被virtual修饰，就只是屏蔽（重写的前提也是构成了屏蔽，只是有了多态的作用）。对于所有的存在在父类中的同名的参数不同的函数这个函数都构成了屏蔽，当然如果在子类中存在相应的同名不同参数的函数对父类的其他类型的同名函数构成重写或者屏蔽，那么只考虑在父类中多个函数的重载问题
	4）通过上面的描述可以看到，如果子类中没有出现与父类同名的函数，那么子类可以继承下来所有的这个名称的方法。但是只要子类中存在一个与父类中同名的函数，无论它的参数列表是什么样的无论是否是virtual的，都对父类的所有的同名函数构成了屏蔽。如果父类中存在同名同参数的virtual方法，那么又进一步构成了重写。也就是说一旦在子类中定义了一个与父类中同名的方法，那么要使用父类中的任意同名方法都需要带上作用域的调用sub.Base::func()
*/

class Base
{
public:
	void func1(){
		cout << "base func1" << endl;
	}
	//虽然是virtual的，但是与上面的函数构成了重载
	virtual void func1(int i){
		cout << "base func1---- " << i << endl;
	}

	void func2(){
		cout << "base func2" << endl;
	}
	//虽然是virtual的，但是与上面的函数构成了重载
	virtual void func2(int i){
		cout << "base func2.... " << i << endl;
	}
};

class Sub : public Base
{
public:
	//同名函数，参数列表完全一样，但是是没有构成重写(因为父类的相同的函数没有virtual关键字)，这里只是屏蔽(屏蔽同名同参数的父类函数，父类中同名不同参数的函数都会被这个函数屏蔽（无论他们是否为virtual的）)
	void func1(){
		cout << "sub func1" << endl;
	}
	//同名函数，参数列表在父类中找不到一样的，那么这个函数会对所有的父类中的同名方法构成了屏蔽（但是如果在子类中进行了重写，那么又在子类中有相应的重载）
	void func2(const string &s){
		cout << "sub func2---" << s << endl;
	}
};

int main(){
	Sub s;
	//同名同参数列表的子类函数对父类的同名同参数的函数形成屏蔽，但是不会屏蔽其他的函数
	s.func1(); //没有重写，构成屏蔽
	//s.func1(2); //调用错误，因为子类中的func1() 对同参数的父类同名函数构成屏蔽，同时对所有的不同参数列表的同名函数构成屏蔽，所以子类中找不到这个方法
	s.Base::func1(2); //可以指明要调用父类的某个方法

	//形参列表与父类中的任何一个同名的函数都不一样的函数对父类中所有的同名函数形成了屏蔽
	//s.func2(); //父类中所有同名的被屏蔽
	s.Base::func2(); 
	//s.func2(100); //父类中所有同名的被屏蔽
	s.Base::func2(100); 
	return 0;
}