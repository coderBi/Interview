#include <iostream>
using namespace std;

/*
问题描述：
	快慢指针与单向链表有环判定：一个单向链表，里面可能存在环，如果进行判定。如果存在环如果找到环的入口
分析：
下面给出网络上和各种书籍上关于使用快慢指针的一般性分析：
	使用一个快指针，每一次走两步，使用一个慢指针，每一次走一步。如果快指针达到了NULL那么说明没有环，否则如果快指针与慢指针在随后的移动过程中相遇那么说明这个链表有环。如果存在环，就将其中一个指针移到链表头，然后将两个指针都设置为步长为1，当两个指针再次相遇的时候就是入口。
其次是个人关于快慢指针的补充说明分析：
	1）一个链表如果有环，而且又是单向的，那么从环的入口开始，后续的所有节点都在环内。可以很容易得知，最大的环就是一个循环链表。如果有环，那么快指针先进入环内进行循环。从慢指针第一次进入环内进行分析，此时快指针无论位于环内的任何位置，可以考虑为接下来形成了快指针在环内对慢指针的一次追赶。又因为快指针每一次两步，而慢指针每一次一步，那么每一次移动实际上是快指针向着慢指针的方向多行进了1。由于当慢指针再次回到环的入口的时候刚好走了一圈，而快指针会刚好走了两圈。结合上面的追赶分析，每次追赶一步，那么在这一圈的过程中，快指针(走了两圈)一定会追上并与慢指针(走了一圈)重合过（由于每一次只是追赶一步，在第一次相遇之后，下一次相遇时慢指针刚好又走了一圈，所以这里可以得到在慢指针走的第一圈中有且仅有一次与快指针的相遇）
	2）关于快指针，为何步长为2，是不是可以为其他的步长。假设如果慢指针为1，快指针为3，那么每次追赶会是2步，这就有了一个问题，也就是快指针与慢指针不一定相遇，可能会出现跨过慢指针而跑到慢指针前面去。一个简单的例子，环长度为2，慢指针进来的时候，快指针在入口之外的另一个点，那么如果设置的步长为1和3，会出现快指针和慢指针永远不可能相遇的情况(因为快指针每次移动3，模上2实际上可以认为和慢指针一样每次只走了1)。进一步的分析，可以发现只要设置步长之差为1就可以满足快慢指针的使用要求(因为步长相差为1的两个数模上圈长只有在圈长为1的时候才是相同的结果，而圈长为1表示快慢指针始终重合)。所以说实际使用中为了方便设计了最简单的步长为1的组合：慢指针为1，快指针为2.
	3）关于环入口判定证明：假设在快慢指针第一次相遇的时候慢指针在环外走了x步在环内走了y步，环的长度为l，快指针已经在环内走了n圈，那么慢指针一共走了x + y步，快指针已经走了2 * (x + y)步。可以得到 2 * （x + y） = x + nl + y。nl = x + y。这个公式指出如果将一个指针返回链表起始点，另一个指针在这个相遇点，二者都设置为步长为1，当圈内的指针走了n圈之后，那么圈外面的指针恰好运动到这个相遇点，也就是说二者又会在这个相遇点重新相遇。结合前面步长都设置为1，那么这两个指针由于在这个相遇点重新相遇，很容易分析出，这个相遇点向后退y，又是环的入口处，二者也是相遇的。所以如果在有环的前提下，可以将其中一个指针移动到链表的起点然后将两个指针的步长都设置为1，当二者第一次相遇的时候就是环的入
*/

typedef struct Node
{
	int data;
	Node * next;
} *PNode;

/**
* 判定一个单向链表是否存在环，如果存在环就返回环入口指针
*
* @param PNode head 要判断的链表
* @return PNode 返回环的入口，如果不存在环就返回nullptr
*/
PNode IsLoop(PNode head){
	if(!head)
		return nullptr;
	PNode slow = head, fast = head; //慢指针、快指针
	while(fast && fast->next){
		slow = slow->next;
		fast = fast->next->next;
		if(slow == fast){
			//快慢指针相遇代表有环,寻找环入口
			slow = head;
			while(slow != fast){
				slow = slow->next;
				fast = fast->next;
			}
			return slow;
		}
	}
	//快指针退出了循环，走到了链表的末尾，说明没有环，返回nullptr
	return nullptr;
}


int main(){
	//测试
	PNode head = new Node[4];
	for(int i = 0; i < 3; ++i){
		head[i].data = i + 1;
		head[i].next = head + i + 1;
	}
	//无环测试
	head[3].next = nullptr; head[3].data = 4;
	PNode result = IsLoop(head);
	if(!result){
		cout << "没有检测到环" << endl; //结果无环
	}else{
		cout << "检测到环，环的入口在第" << result->data << "个元素上" << endl;
	}
	
	//有环测试
	head[3].next = head+1; head[3].data = 4;
	result = IsLoop(head);
	if(!result){
		cout << "没有检测到环" << endl;
	}else{
		cout << "检测到环，环的入口在第" << result->data << "个元素上" << endl; //结果有环存在在第2个元素上
	}
	return 0;
}