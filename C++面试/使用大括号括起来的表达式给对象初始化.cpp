#include <iostream>
using namespace std;

/*
	下面的代码太杂，如果要回看，只需要看这里的总结结论
1）通过测试，如果构造函数存在初始化列表不能使用{}对对象进行初始化
2）如果不存在初始化列表，那么即使构造函数是有参数的情况，也可以直接使用{}进行对象的初始化
3）这里还发现一个问题，就是存在引用类型的成员，不提供任何的构造函数(如果用户提供了，即使是无参的，那么也得在初始化列表中对引用类型的成员进行初始化)，也可以使用{}进行初始化（但是如果直接构造，那么就是没有初始化，因为调用了默认的构造函数，而默认的构造函数中没有进行引用变量的初始化）。对于这种存在引用类型的成员却不提供任何的构造函数的编译合法性（尽管实例化的时候不能直接构造）是不是优化的结果尚不清楚
*/

struct A
{
public:
	int a;
	int b;
};

class B
{
public:
	int a;
	int b;
};

struct C
{
public:
	int a;
	int b;
	C(int a, int b){
		this->a = a;
		this->b = b;
	}
};

class D
{
public:
	int a;
	int b;
	D(int a, int b){
		this->a = a;
		this->b = b;
	}
};

class E
{
public:
	int i;
};

/* 按道理，存在引用的类型，应该在初始化列表中进行初始化，但是这里没有提供构造函数，没有报错，是不是优化暂不清楚  START*/
class F
{
public:
	int i;
	E & e;
};

struct G
{
public:
	int i;
	E & e;
};
/* 按道理，存在引用的类型，应该在初始化列表中进行初始化，但是这里没有提供构造函数，没有报错，是不是优化暂不清楚  END*/

class H
{
public:
	int i;
	E & e;
	H(E & e): e(e){
		this->i = 333;
	}
};

struct I
{
public:
	int i;
	E & e;
	I(E & e): e(e){
		this->i = 444;
	}
};

/* 自定义构造函数必须提供引用类型的初始化 这里编译错误(但是注意，如果用户不提供任何的构造函数，上面的测试表明并不会报错)  START*/
/*
struct J
{
public:
	int i;
	E & e;
	J(){
		this->i = 1111;
	}
};*/
/* 自定义构造函数必须提供引用类型的初始化 这里编译错误(但是注意，如果用户不提供任何的构造函数，上面的测试表明并不会报错)  END*/

int main(){
	/* 以下4个初始化都是合法的，也即是说class与struct基本没有差别 */
	A a = {1,2};
	B b = {1,2};
	C c = {1,2};
	D d = {1,2};
	cout << d.b << endl;

	/*如果不存在初始化列表，那么也可以直接使用{}进行初始化*/
	E e = {999};
	F f = {121,e};
	G g = {121,e};
	cout << g.i << endl;

	//G x; //这就会报错，因为存在引用类型的成员没有初始化

	/*如果存在初始化列表就不能直接使用{}对这个类的对象进行初始化*/
	//H h = {121,e};
	//I i = {121,e};
	return 0;
}