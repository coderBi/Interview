#include <iostream>
using namespace std;


/*
题目描述：
	什么是显式转换
分析：
	显式转换又称为强制类型转换，是相对于隐式转换而言的。在引入四个强制类型转换操作符的之前，强制类型转换都是通过()中存放类型的形式书写。C++中存在4个强制转换的操作符:
	1）reinterpret_cast：这个操作符与直接使用()加上类型的转换是一个效果（reinterpret意思是重新解释）
	2）const_cast: 对于const指向的指针或者引用进行转换。如果是const引用或者指针只能使用这个操作符进行转换，如果使用另外的三个操作符进行转换会报错，同样如果使用const_cast转换非const指向的引用或者指针也是错误的（存在一个特例，就是const_cast这个转换是可以实现const属性的移除和添加，例如实现const指向到非const指向 double * p = const_cast<double*> pc; 其中pc为const double*）。
	3）static_cast: 对于所有的可以使用隐式转换和对象的下行转换(父类到子类，但是这里的转换是不进行类型的安全检查的)，可以使用static_cast。对于对象的上行（可以隐式转换）转换其实使用的是拷贝构造函数
	4）dynamic_cast: 动态转换，在运行时会进行类型的RTTI的判定，适用于存在继承关系的类的对象的转换。由于RTTI存放在虚函数表中（准确的说在虚函数表的首地址的上面的一个int），如果一个类中没有虚函数，那么就会出现编译错误（提示操作数必须包含多态类类型）。如果dynamic操作符的操作数是指针，在不能进行转换的时候会返回null，在操作数是引用的时候，如果不能正常转换会抛出异常。(注意，这个操作符只能接受指针或者引用类型，不能接受对象类型)
编码补充：
	1）对于static_cast，如果是下行转换，传入的参数类型不能是对象类型（除非定义了转换构造函数或者是类型转换函数），否则编译通不过。对于上行的传入参数为对象(可隐式)转换，其实就是调用的拷贝构造函数，但是在传参的时候进行了隐式的引用转换。
	2）static_cast对于指针和引用的下行转换是不假思索的，不进行类型检查的(只要这两个类型的存在继承关系，而不考虑真实的对象的内存结构。如果这里两个类型不存在继承关系，会编译通不过)
	3) 如果两个类不存在继承关系，那么如果使用static_cast在编译阶段会直接报错，但是如果是用dynamic_cast会给出一个警告，说是转换确定不会成功（返回null）
	4）对于多继承，两个父类之间不存在继承关系，所以不能直接使用static_cast转换，否则会产生编译错误。但是如果是使用dynamic_cast由于会检查对象的真实指向类型，所以可以转换成功。
*/

class A
{
public:
	int x = 111;
	virtual void func(){
		cout << "A... " << x << endl;
	}
};

class B : public A
{
public:
	int x = 222;
	virtual void func(){
		cout << "B... " << x << endl;
	}
};

class C
{
};

int main(){
	//移除const指向的属性
	const A * pa = new A;
	//pa->x = 22;  //编译报错，提示对read-only的对象的成员进行赋值操作
	A* pa2 = const_cast<A*>(pa);
	pa2->x = 222; //操作成功，因为将const指向变成了非const指向
	cout << pa2->x << endl; 
	//添加const指向
	pa = const_cast<const A*>(pa2);
	//pa->x = 111; //再次编译错误，对read-only的对象的成员进行赋值

	cout << "------测试分割线-----------" << endl;
	//使用static_cast上行转换（符合隐式转换）
	B b;
	cout << b.x << endl;
	//对象类型的转换
	A a = static_cast<A>(b); //调用拷贝构造函数
	cout << a.x << endl; //111
	//对象的引用的转换，对象的指针的转换相似
	A & ya = static_cast<A&>(b); //这里传入的其实不是引用而是一个对象，使用不规范，因为下面的下行转换就可以看到如果传入的是对象而不是引用会有问题
	cout << ya.x << endl; ///111
	//使用static_cast进行下行转换,和动态转换不同，这里不会进行类型安全检查
	//B b1 = static_cast<B>(a); //编译错误，因为上行的对象直接转换是调用的拷贝构造函数，而下行的时候没有找到可以隐式转换到构造函数（也没有定义相应的类型转换函数），所以这编译通不过

	//引用的下行转换（指针类似）
		//一种错误的示例
	B &b1 = static_cast<B&>(a); //注意，这里的参数应该是引用，如果不小心传了一个对象进去，由于引用和指针存储的数据是一样的，这里会导致指针乱指
	cout << b1.x << endl; //垃圾值，而且由于指针乱指，这里的情况不可测
		//正确传入引用为参数，得到正确结果
	B &b2 = static_cast<B&>(ya);  //正确传参
	cout << b2.x << endl; //222
	//C *pc1 = static_cast<C*>(&b); //编译通不过，因为不存在继承关系，不可能存在上行或者下行的关系

	cout << "------------测试分割线-------------" << endl;
	//动态转换,如果转换的类中没有虚函数，将导致编译错误，因为动态转换要到虚表中寻找RTTI。与static_cast相比，动态转换是运行是确定类型的，会进行类型安全性检查
	A *pa3 = dynamic_cast<A*>(&b);
	cout << pa3->x << endl; //111
	C *pc2 = dynamic_cast<C*>(&b); //与static_cast的编译error相比，这里只是给出一个警告，说是这种转换"can never succeed"。因为两个类不存在继承关系，所以这里的pc2在运行前就已经确定是nullptr
	cout << pc2 << endl; //0
	return 0;
}